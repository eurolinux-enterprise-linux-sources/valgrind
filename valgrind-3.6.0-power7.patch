svn diff -r11696:11700
svn diff -r2087:2088 VEX/
svn diff -r2126:2127 VEX/
svn diff -r2129:2130 VEX/
svn diff -r2135:2136 VEX/
svn diff -r2147:2148 VEX/
--- valgrind-3.6.0/exp-ptrcheck/h_main.c	(revision 11696)
+++ valgrind-3.6.0/exp-ptrcheck/h_main.c	(revision 11700)
@@ -1574,77 +1574,118 @@ static void get_IntRegInfo ( /*OUT*/IntR
       if (o == GOF(CR7_0))   goto none;
    }
 
+   // With ISA 2.06, the "Vector-Scalar Floating-point" category
+   // provides facilities to support vector and scalar binary floating-
+   // point operations.  A unified register file is an integral part
+   // of this new facility, combining floating point and vector registers
+   // using a 64x128-bit vector.  These are referred to as VSR[0..63].
+   // The floating point registers are now mapped into double word element 0
+   // of VSR[0..31]. The 32x128-bit vector registers defined by the "Vector
+   // Facility [Category: Vector]" are now mapped to VSR[32..63].
+
    /* Exact accesses to FP registers */
-   if (o == GOF(FPR0)  && is8) goto none;
-   if (o == GOF(FPR1)  && is8) goto none;
-   if (o == GOF(FPR2)  && is8) goto none;
-   if (o == GOF(FPR3)  && is8) goto none;
-   if (o == GOF(FPR4)  && is8) goto none;
-   if (o == GOF(FPR5)  && is8) goto none;
-   if (o == GOF(FPR6)  && is8) goto none;
-   if (o == GOF(FPR7)  && is8) goto none;
-   if (o == GOF(FPR8)  && is8) goto none;
-   if (o == GOF(FPR9)  && is8) goto none;
-   if (o == GOF(FPR10) && is8) goto none;
-   if (o == GOF(FPR11) && is8) goto none;
-   if (o == GOF(FPR12) && is8) goto none;
-   if (o == GOF(FPR13) && is8) goto none;
-   if (o == GOF(FPR14) && is8) goto none;
-   if (o == GOF(FPR15) && is8) goto none;
-   if (o == GOF(FPR16) && is8) goto none;
-   if (o == GOF(FPR17) && is8) goto none;
-   if (o == GOF(FPR18) && is8) goto none;
-   if (o == GOF(FPR19) && is8) goto none;
-   if (o == GOF(FPR20) && is8) goto none;
-   if (o == GOF(FPR21) && is8) goto none;
-   if (o == GOF(FPR22) && is8) goto none;
-   if (o == GOF(FPR23) && is8) goto none;
-   if (o == GOF(FPR24) && is8) goto none;
-   if (o == GOF(FPR25) && is8) goto none;
-   if (o == GOF(FPR26) && is8) goto none;
-   if (o == GOF(FPR27) && is8) goto none;
-   if (o == GOF(FPR28) && is8) goto none;
-   if (o == GOF(FPR29) && is8) goto none;
-   if (o == GOF(FPR30) && is8) goto none;
-   if (o == GOF(FPR31) && is8) goto none;
+   if (o == GOF(VSR0)  && is8) goto none;
+   if (o == GOF(VSR1)  && is8) goto none;
+   if (o == GOF(VSR2)  && is8) goto none;
+   if (o == GOF(VSR3)  && is8) goto none;
+   if (o == GOF(VSR4)  && is8) goto none;
+   if (o == GOF(VSR5)  && is8) goto none;
+   if (o == GOF(VSR6)  && is8) goto none;
+   if (o == GOF(VSR7)  && is8) goto none;
+   if (o == GOF(VSR8)  && is8) goto none;
+   if (o == GOF(VSR9)  && is8) goto none;
+   if (o == GOF(VSR10) && is8) goto none;
+   if (o == GOF(VSR11) && is8) goto none;
+   if (o == GOF(VSR12) && is8) goto none;
+   if (o == GOF(VSR13) && is8) goto none;
+   if (o == GOF(VSR14) && is8) goto none;
+   if (o == GOF(VSR15) && is8) goto none;
+   if (o == GOF(VSR16) && is8) goto none;
+   if (o == GOF(VSR17) && is8) goto none;
+   if (o == GOF(VSR18) && is8) goto none;
+   if (o == GOF(VSR19) && is8) goto none;
+   if (o == GOF(VSR20) && is8) goto none;
+   if (o == GOF(VSR21) && is8) goto none;
+   if (o == GOF(VSR22) && is8) goto none;
+   if (o == GOF(VSR23) && is8) goto none;
+   if (o == GOF(VSR24) && is8) goto none;
+   if (o == GOF(VSR25) && is8) goto none;
+   if (o == GOF(VSR26) && is8) goto none;
+   if (o == GOF(VSR27) && is8) goto none;
+   if (o == GOF(VSR28) && is8) goto none;
+   if (o == GOF(VSR29) && is8) goto none;
+   if (o == GOF(VSR30) && is8) goto none;
+   if (o == GOF(VSR31) && is8) goto none;
 
    /* FP admin related */
    if (o == GOF(FPROUND) && is4) goto none;
    if (o == GOF(EMWARN)  && is4) goto none;
 
-   /* Altivec registers */
-   if (o == GOF(VR0)  && sz == 16) goto none;
-   if (o == GOF(VR1)  && sz == 16) goto none;
-   if (o == GOF(VR2)  && sz == 16) goto none;
-   if (o == GOF(VR3)  && sz == 16) goto none;
-   if (o == GOF(VR4)  && sz == 16) goto none;
-   if (o == GOF(VR5)  && sz == 16) goto none;
-   if (o == GOF(VR6)  && sz == 16) goto none;
-   if (o == GOF(VR7)  && sz == 16) goto none;
-   if (o == GOF(VR8)  && sz == 16) goto none;
-   if (o == GOF(VR9)  && sz == 16) goto none;
-   if (o == GOF(VR10) && sz == 16) goto none;
-   if (o == GOF(VR11) && sz == 16) goto none;
-   if (o == GOF(VR12) && sz == 16) goto none;
-   if (o == GOF(VR13) && sz == 16) goto none;
-   if (o == GOF(VR14) && sz == 16) goto none;
-   if (o == GOF(VR15) && sz == 16) goto none;
-   if (o == GOF(VR16) && sz == 16) goto none;
-   if (o == GOF(VR17) && sz == 16) goto none;
-   if (o == GOF(VR18) && sz == 16) goto none;
-   if (o == GOF(VR19) && sz == 16) goto none;
-   if (o == GOF(VR20) && sz == 16) goto none;
-   if (o == GOF(VR21) && sz == 16) goto none;
-   if (o == GOF(VR22) && sz == 16) goto none;
-   if (o == GOF(VR23) && sz == 16) goto none;
-   if (o == GOF(VR24) && sz == 16) goto none;
-   if (o == GOF(VR25) && sz == 16) goto none;
-   if (o == GOF(VR26) && sz == 16) goto none;
-   if (o == GOF(VR27) && sz == 16) goto none;
-   if (o == GOF(VR28) && sz == 16) goto none;
-   if (o == GOF(VR29) && sz == 16) goto none;
-   if (o == GOF(VR30) && sz == 16) goto none;
-   if (o == GOF(VR31) && sz == 16) goto none;
+   /* Vector registers */
+   if (o == GOF(VSR0)  && sz == 16) goto none;
+   if (o == GOF(VSR1)  && sz == 16) goto none;
+   if (o == GOF(VSR2)  && sz == 16) goto none;
+   if (o == GOF(VSR3)  && sz == 16) goto none;
+   if (o == GOF(VSR4)  && sz == 16) goto none;
+   if (o == GOF(VSR5)  && sz == 16) goto none;
+   if (o == GOF(VSR6)  && sz == 16) goto none;
+   if (o == GOF(VSR7)  && sz == 16) goto none;
+   if (o == GOF(VSR8)  && sz == 16) goto none;
+   if (o == GOF(VSR9)  && sz == 16) goto none;
+   if (o == GOF(VSR10) && sz == 16) goto none;
+   if (o == GOF(VSR11) && sz == 16) goto none;
+   if (o == GOF(VSR12) && sz == 16) goto none;
+   if (o == GOF(VSR13) && sz == 16) goto none;
+   if (o == GOF(VSR14) && sz == 16) goto none;
+   if (o == GOF(VSR15) && sz == 16) goto none;
+   if (o == GOF(VSR16) && sz == 16) goto none;
+   if (o == GOF(VSR17) && sz == 16) goto none;
+   if (o == GOF(VSR18) && sz == 16) goto none;
+   if (o == GOF(VSR19) && sz == 16) goto none;
+   if (o == GOF(VSR20) && sz == 16) goto none;
+   if (o == GOF(VSR21) && sz == 16) goto none;
+   if (o == GOF(VSR22) && sz == 16) goto none;
+   if (o == GOF(VSR23) && sz == 16) goto none;
+   if (o == GOF(VSR24) && sz == 16) goto none;
+   if (o == GOF(VSR25) && sz == 16) goto none;
+   if (o == GOF(VSR26) && sz == 16) goto none;
+   if (o == GOF(VSR27) && sz == 16) goto none;
+   if (o == GOF(VSR28) && sz == 16) goto none;
+   if (o == GOF(VSR29) && sz == 16) goto none;
+   if (o == GOF(VSR30) && sz == 16) goto none;
+   if (o == GOF(VSR31) && sz == 16) goto none;
+   if (o == GOF(VSR32) && sz == 16) goto none;
+   if (o == GOF(VSR33) && sz == 16) goto none;
+   if (o == GOF(VSR34) && sz == 16) goto none;
+   if (o == GOF(VSR35) && sz == 16) goto none;
+   if (o == GOF(VSR36) && sz == 16) goto none;
+   if (o == GOF(VSR37) && sz == 16) goto none;
+   if (o == GOF(VSR38) && sz == 16) goto none;
+   if (o == GOF(VSR39) && sz == 16) goto none;
+   if (o == GOF(VSR40) && sz == 16) goto none;
+   if (o == GOF(VSR41) && sz == 16) goto none;
+   if (o == GOF(VSR42) && sz == 16) goto none;
+   if (o == GOF(VSR43) && sz == 16) goto none;
+   if (o == GOF(VSR44) && sz == 16) goto none;
+   if (o == GOF(VSR45) && sz == 16) goto none;
+   if (o == GOF(VSR46) && sz == 16) goto none;
+   if (o == GOF(VSR47) && sz == 16) goto none;
+   if (o == GOF(VSR48) && sz == 16) goto none;
+   if (o == GOF(VSR49) && sz == 16) goto none;
+   if (o == GOF(VSR50) && sz == 16) goto none;
+   if (o == GOF(VSR51) && sz == 16) goto none;
+   if (o == GOF(VSR52) && sz == 16) goto none;
+   if (o == GOF(VSR53) && sz == 16) goto none;
+   if (o == GOF(VSR54) && sz == 16) goto none;
+   if (o == GOF(VSR55) && sz == 16) goto none;
+   if (o == GOF(VSR56) && sz == 16) goto none;
+   if (o == GOF(VSR57) && sz == 16) goto none;
+   if (o == GOF(VSR58) && sz == 16) goto none;
+   if (o == GOF(VSR59) && sz == 16) goto none;
+   if (o == GOF(VSR60) && sz == 16) goto none;
+   if (o == GOF(VSR61) && sz == 16) goto none;
+   if (o == GOF(VSR62) && sz == 16) goto none;
+   if (o == GOF(VSR63) && sz == 16) goto none;
 
    /* Altivec admin related */
    if (o == GOF(VRSAVE) && is4) goto none;
@@ -1737,77 +1778,118 @@ static void get_IntRegInfo ( /*OUT*/IntR
       if (o == GOF(CR7_0))   goto none;
    }
 
+   // With ISA 2.06, the "Vector-Scalar Floating-point" category
+   // provides facilities to support vector and scalar binary floating-
+   // point operations.  A unified register file is an integral part
+   // of this new facility, combining floating point and vector registers
+   // using a 64x128-bit vector.  These are referred to as VSR[0..63].
+   // The floating point registers are now mapped into double word element 0
+   // of VSR[0..31]. The 32x128-bit vector registers defined by the "Vector
+   // Facility [Category: Vector]" are now mapped to VSR[32..63].
+
    /* Exact accesses to FP registers */
-   if (o == GOF(FPR0)  && is8) goto none;
-   if (o == GOF(FPR1)  && is8) goto none;
-   if (o == GOF(FPR2)  && is8) goto none;
-   if (o == GOF(FPR3)  && is8) goto none;
-   if (o == GOF(FPR4)  && is8) goto none;
-   if (o == GOF(FPR5)  && is8) goto none;
-   if (o == GOF(FPR6)  && is8) goto none;
-   if (o == GOF(FPR7)  && is8) goto none;
-   if (o == GOF(FPR8)  && is8) goto none;
-   if (o == GOF(FPR9)  && is8) goto none;
-   if (o == GOF(FPR10) && is8) goto none;
-   if (o == GOF(FPR11) && is8) goto none;
-   if (o == GOF(FPR12) && is8) goto none;
-   if (o == GOF(FPR13) && is8) goto none;
-   if (o == GOF(FPR14) && is8) goto none;
-   if (o == GOF(FPR15) && is8) goto none;
-   if (o == GOF(FPR16) && is8) goto none;
-   if (o == GOF(FPR17) && is8) goto none;
-   if (o == GOF(FPR18) && is8) goto none;
-   if (o == GOF(FPR19) && is8) goto none;
-   if (o == GOF(FPR20) && is8) goto none;
-   if (o == GOF(FPR21) && is8) goto none;
-   if (o == GOF(FPR22) && is8) goto none;
-   if (o == GOF(FPR23) && is8) goto none;
-   if (o == GOF(FPR24) && is8) goto none;
-   if (o == GOF(FPR25) && is8) goto none;
-   if (o == GOF(FPR26) && is8) goto none;
-   if (o == GOF(FPR27) && is8) goto none;
-   if (o == GOF(FPR28) && is8) goto none;
-   if (o == GOF(FPR29) && is8) goto none;
-   if (o == GOF(FPR30) && is8) goto none;
-   if (o == GOF(FPR31) && is8) goto none;
+   if (o == GOF(VSR0)  && is8) goto none;
+   if (o == GOF(VSR1)  && is8) goto none;
+   if (o == GOF(VSR2)  && is8) goto none;
+   if (o == GOF(VSR3)  && is8) goto none;
+   if (o == GOF(VSR4)  && is8) goto none;
+   if (o == GOF(VSR5)  && is8) goto none;
+   if (o == GOF(VSR6)  && is8) goto none;
+   if (o == GOF(VSR7)  && is8) goto none;
+   if (o == GOF(VSR8)  && is8) goto none;
+   if (o == GOF(VSR9)  && is8) goto none;
+   if (o == GOF(VSR10) && is8) goto none;
+   if (o == GOF(VSR11) && is8) goto none;
+   if (o == GOF(VSR12) && is8) goto none;
+   if (o == GOF(VSR13) && is8) goto none;
+   if (o == GOF(VSR14) && is8) goto none;
+   if (o == GOF(VSR15) && is8) goto none;
+   if (o == GOF(VSR16) && is8) goto none;
+   if (o == GOF(VSR17) && is8) goto none;
+   if (o == GOF(VSR18) && is8) goto none;
+   if (o == GOF(VSR19) && is8) goto none;
+   if (o == GOF(VSR20) && is8) goto none;
+   if (o == GOF(VSR21) && is8) goto none;
+   if (o == GOF(VSR22) && is8) goto none;
+   if (o == GOF(VSR23) && is8) goto none;
+   if (o == GOF(VSR24) && is8) goto none;
+   if (o == GOF(VSR25) && is8) goto none;
+   if (o == GOF(VSR26) && is8) goto none;
+   if (o == GOF(VSR27) && is8) goto none;
+   if (o == GOF(VSR28) && is8) goto none;
+   if (o == GOF(VSR29) && is8) goto none;
+   if (o == GOF(VSR30) && is8) goto none;
+   if (o == GOF(VSR31) && is8) goto none;
 
    /* FP admin related */
    if (o == GOF(FPROUND) && is4) goto none;
    if (o == GOF(EMWARN)  && is4) goto none;
 
-   /* Altivec registers */
-   if (o == GOF(VR0)  && sz == 16) goto none;
-   if (o == GOF(VR1)  && sz == 16) goto none;
-   if (o == GOF(VR2)  && sz == 16) goto none;
-   if (o == GOF(VR3)  && sz == 16) goto none;
-   if (o == GOF(VR4)  && sz == 16) goto none;
-   if (o == GOF(VR5)  && sz == 16) goto none;
-   if (o == GOF(VR6)  && sz == 16) goto none;
-   if (o == GOF(VR7)  && sz == 16) goto none;
-   if (o == GOF(VR8)  && sz == 16) goto none;
-   if (o == GOF(VR9)  && sz == 16) goto none;
-   if (o == GOF(VR10) && sz == 16) goto none;
-   if (o == GOF(VR11) && sz == 16) goto none;
-   if (o == GOF(VR12) && sz == 16) goto none;
-   if (o == GOF(VR13) && sz == 16) goto none;
-   if (o == GOF(VR14) && sz == 16) goto none;
-   if (o == GOF(VR15) && sz == 16) goto none;
-   if (o == GOF(VR16) && sz == 16) goto none;
-   if (o == GOF(VR17) && sz == 16) goto none;
-   if (o == GOF(VR18) && sz == 16) goto none;
-   if (o == GOF(VR19) && sz == 16) goto none;
-   if (o == GOF(VR20) && sz == 16) goto none;
-   if (o == GOF(VR21) && sz == 16) goto none;
-   if (o == GOF(VR22) && sz == 16) goto none;
-   if (o == GOF(VR23) && sz == 16) goto none;
-   if (o == GOF(VR24) && sz == 16) goto none;
-   if (o == GOF(VR25) && sz == 16) goto none;
-   if (o == GOF(VR26) && sz == 16) goto none;
-   if (o == GOF(VR27) && sz == 16) goto none;
-   if (o == GOF(VR28) && sz == 16) goto none;
-   if (o == GOF(VR29) && sz == 16) goto none;
-   if (o == GOF(VR30) && sz == 16) goto none;
-   if (o == GOF(VR31) && sz == 16) goto none;
+   /* Vector registers */
+   if (o == GOF(VSR0)  && sz == 16) goto none;
+   if (o == GOF(VSR1)  && sz == 16) goto none;
+   if (o == GOF(VSR2)  && sz == 16) goto none;
+   if (o == GOF(VSR3)  && sz == 16) goto none;
+   if (o == GOF(VSR4)  && sz == 16) goto none;
+   if (o == GOF(VSR5)  && sz == 16) goto none;
+   if (o == GOF(VSR6)  && sz == 16) goto none;
+   if (o == GOF(VSR7)  && sz == 16) goto none;
+   if (o == GOF(VSR8)  && sz == 16) goto none;
+   if (o == GOF(VSR9)  && sz == 16) goto none;
+   if (o == GOF(VSR10) && sz == 16) goto none;
+   if (o == GOF(VSR11) && sz == 16) goto none;
+   if (o == GOF(VSR12) && sz == 16) goto none;
+   if (o == GOF(VSR13) && sz == 16) goto none;
+   if (o == GOF(VSR14) && sz == 16) goto none;
+   if (o == GOF(VSR15) && sz == 16) goto none;
+   if (o == GOF(VSR16) && sz == 16) goto none;
+   if (o == GOF(VSR17) && sz == 16) goto none;
+   if (o == GOF(VSR18) && sz == 16) goto none;
+   if (o == GOF(VSR19) && sz == 16) goto none;
+   if (o == GOF(VSR20) && sz == 16) goto none;
+   if (o == GOF(VSR21) && sz == 16) goto none;
+   if (o == GOF(VSR22) && sz == 16) goto none;
+   if (o == GOF(VSR23) && sz == 16) goto none;
+   if (o == GOF(VSR24) && sz == 16) goto none;
+   if (o == GOF(VSR25) && sz == 16) goto none;
+   if (o == GOF(VSR26) && sz == 16) goto none;
+   if (o == GOF(VSR27) && sz == 16) goto none;
+   if (o == GOF(VSR28) && sz == 16) goto none;
+   if (o == GOF(VSR29) && sz == 16) goto none;
+   if (o == GOF(VSR30) && sz == 16) goto none;
+   if (o == GOF(VSR31) && sz == 16) goto none;
+   if (o == GOF(VSR32) && sz == 16) goto none;
+   if (o == GOF(VSR33) && sz == 16) goto none;
+   if (o == GOF(VSR34) && sz == 16) goto none;
+   if (o == GOF(VSR35) && sz == 16) goto none;
+   if (o == GOF(VSR36) && sz == 16) goto none;
+   if (o == GOF(VSR37) && sz == 16) goto none;
+   if (o == GOF(VSR38) && sz == 16) goto none;
+   if (o == GOF(VSR39) && sz == 16) goto none;
+   if (o == GOF(VSR40) && sz == 16) goto none;
+   if (o == GOF(VSR41) && sz == 16) goto none;
+   if (o == GOF(VSR42) && sz == 16) goto none;
+   if (o == GOF(VSR43) && sz == 16) goto none;
+   if (o == GOF(VSR44) && sz == 16) goto none;
+   if (o == GOF(VSR45) && sz == 16) goto none;
+   if (o == GOF(VSR46) && sz == 16) goto none;
+   if (o == GOF(VSR47) && sz == 16) goto none;
+   if (o == GOF(VSR48) && sz == 16) goto none;
+   if (o == GOF(VSR49) && sz == 16) goto none;
+   if (o == GOF(VSR50) && sz == 16) goto none;
+   if (o == GOF(VSR51) && sz == 16) goto none;
+   if (o == GOF(VSR52) && sz == 16) goto none;
+   if (o == GOF(VSR53) && sz == 16) goto none;
+   if (o == GOF(VSR54) && sz == 16) goto none;
+   if (o == GOF(VSR55) && sz == 16) goto none;
+   if (o == GOF(VSR56) && sz == 16) goto none;
+   if (o == GOF(VSR57) && sz == 16) goto none;
+   if (o == GOF(VSR58) && sz == 16) goto none;
+   if (o == GOF(VSR59) && sz == 16) goto none;
+   if (o == GOF(VSR60) && sz == 16) goto none;
+   if (o == GOF(VSR61) && sz == 16) goto none;
+   if (o == GOF(VSR62) && sz == 16) goto none;
+   if (o == GOF(VSR63) && sz == 16) goto none;
 
    /* Altivec admin related */
    if (o == GOF(VRSAVE) && is4) goto none;
--- valgrind-3.6.0/tests/check_isa-2_06_cap	(revision 0)
+++ valgrind-3.6.0/tests/check_isa-2_06_cap	(revision 11700)
@@ -0,0 +1,11 @@
+#!/bin/sh
+
+# We use this script to check whether or not the processor supports Power ISA 2.06.
+
+LD_SHOW_AUXV=1 /bin/true | grep  arch_2_06 > /dev/null 2>&1
+if [ "$?" -ne "0" ]; then
+	exit 1
+else
+	exit 0
+fi
+
--- valgrind-3.6.0/memcheck/mc_main.c	(revision 11696)
+++ valgrind-3.6.0/memcheck/mc_main.c	(revision 11700)
@@ -3864,7 +3864,7 @@ static UInt mb_get_origin_for_guest_offs
 static void mc_post_reg_write ( CorePart part, ThreadId tid, 
                                 PtrdiffT offset, SizeT size)
 {
-#  define MAX_REG_WRITE_SIZE 1408
+#  define MAX_REG_WRITE_SIZE 1664
    UChar area[MAX_REG_WRITE_SIZE];
    tl_assert(size <= MAX_REG_WRITE_SIZE);
    VG_(memset)(area, V_BITS8_DEFINED, size);
--- valgrind-3.6.0/memcheck/mc_machine.c	(revision 11696)
+++ valgrind-3.6.0/memcheck/mc_machine.c	(revision 11700)
@@ -200,98 +200,139 @@ static Int get_otrack_shadow_offset_wrk 
    if (o == GOF(VRSAVE)    && sz == 4) return -1;
    if (o == GOF(REDIR_SP)  && sz == 8) return -1;
 
-   tl_assert(SZB(FPR0) == 8);
-   if (o == GOF(FPR0) && sz == 8) return o;
-   if (o == GOF(FPR1) && sz == 8) return o;
-   if (o == GOF(FPR2) && sz == 8) return o;
-   if (o == GOF(FPR3) && sz == 8) return o;
-   if (o == GOF(FPR4) && sz == 8) return o;
-   if (o == GOF(FPR5) && sz == 8) return o;
-   if (o == GOF(FPR6) && sz == 8) return o;
-   if (o == GOF(FPR7) && sz == 8) return o;
-   if (o == GOF(FPR8) && sz == 8) return o;
-   if (o == GOF(FPR9) && sz == 8) return o;
-   if (o == GOF(FPR10) && sz == 8) return o;
-   if (o == GOF(FPR11) && sz == 8) return o;
-   if (o == GOF(FPR12) && sz == 8) return o;
-   if (o == GOF(FPR13) && sz == 8) return o;
-   if (o == GOF(FPR14) && sz == 8) return o;
-   if (o == GOF(FPR15) && sz == 8) return o;
-   if (o == GOF(FPR16) && sz == 8) return o;
-   if (o == GOF(FPR17) && sz == 8) return o;
-   if (o == GOF(FPR18) && sz == 8) return o;
-   if (o == GOF(FPR19) && sz == 8) return o;
-   if (o == GOF(FPR20) && sz == 8) return o;
-   if (o == GOF(FPR21) && sz == 8) return o;
-   if (o == GOF(FPR22) && sz == 8) return o;
-   if (o == GOF(FPR23) && sz == 8) return o;
-   if (o == GOF(FPR24) && sz == 8) return o;
-   if (o == GOF(FPR25) && sz == 8) return o;
-   if (o == GOF(FPR26) && sz == 8) return o;
-   if (o == GOF(FPR27) && sz == 8) return o;
-   if (o == GOF(FPR28) && sz == 8) return o;
-   if (o == GOF(FPR29) && sz == 8) return o;
-   if (o == GOF(FPR30) && sz == 8) return o;
-   if (o == GOF(FPR31) && sz == 8) return o;
+   // With ISA 2.06, the "Vector-Scalar Floating-point" category
+   // provides facilities to support vector and scalar binary floating-
+   // point operations.  A unified register file is an integral part
+   // of this new facility, combining floating point and vector registers
+   // using a 64x128-bit vector.  These are referred to as VSR[0..63].
+   // The floating point registers are now mapped into double word element 0
+   // of VSR[0..31]. The 32x128-bit vector registers defined by the "Vector
+   // Facility [Category: Vector]" are now mapped to VSR[32..63].
+
+   //  Floating point registers . . .
+   if (o == GOF(VSR0) && sz == 8) return o;
+   if (o == GOF(VSR1) && sz == 8) return o;
+   if (o == GOF(VSR2) && sz == 8) return o;
+   if (o == GOF(VSR3) && sz == 8) return o;
+   if (o == GOF(VSR4) && sz == 8) return o;
+   if (o == GOF(VSR5) && sz == 8) return o;
+   if (o == GOF(VSR6) && sz == 8) return o;
+   if (o == GOF(VSR7) && sz == 8) return o;
+   if (o == GOF(VSR8) && sz == 8) return o;
+   if (o == GOF(VSR9) && sz == 8) return o;
+   if (o == GOF(VSR10) && sz == 8) return o;
+   if (o == GOF(VSR11) && sz == 8) return o;
+   if (o == GOF(VSR12) && sz == 8) return o;
+   if (o == GOF(VSR13) && sz == 8) return o;
+   if (o == GOF(VSR14) && sz == 8) return o;
+   if (o == GOF(VSR15) && sz == 8) return o;
+   if (o == GOF(VSR16) && sz == 8) return o;
+   if (o == GOF(VSR17) && sz == 8) return o;
+   if (o == GOF(VSR18) && sz == 8) return o;
+   if (o == GOF(VSR19) && sz == 8) return o;
+   if (o == GOF(VSR20) && sz == 8) return o;
+   if (o == GOF(VSR21) && sz == 8) return o;
+   if (o == GOF(VSR22) && sz == 8) return o;
+   if (o == GOF(VSR23) && sz == 8) return o;
+   if (o == GOF(VSR24) && sz == 8) return o;
+   if (o == GOF(VSR25) && sz == 8) return o;
+   if (o == GOF(VSR26) && sz == 8) return o;
+   if (o == GOF(VSR27) && sz == 8) return o;
+   if (o == GOF(VSR28) && sz == 8) return o;
+   if (o == GOF(VSR29) && sz == 8) return o;
+   if (o == GOF(VSR30) && sz == 8) return o;
+   if (o == GOF(VSR31) && sz == 8) return o;
 
    /* For the various byte sized XER/CR pieces, use offset 8
-      in VR0 .. VR31. */
-   tl_assert(SZB(VR0) == 16);
-   if (o == GOF(XER_SO) && sz == 1) return 8 +GOF(VR0);
-   if (o == GOF(XER_OV) && sz == 1) return 8 +GOF(VR1);
-   if (o == GOF(XER_CA) && sz == 1) return 8 +GOF(VR2);
-   if (o == GOF(XER_BC) && sz == 1) return 8 +GOF(VR3);
-
-   if (o == GOF(CR0_321) && sz == 1) return 8 +GOF(VR4);
-   if (o == GOF(CR0_0)   && sz == 1) return 8 +GOF(VR5);
-   if (o == GOF(CR1_321) && sz == 1) return 8 +GOF(VR6);
-   if (o == GOF(CR1_0)   && sz == 1) return 8 +GOF(VR7);
-   if (o == GOF(CR2_321) && sz == 1) return 8 +GOF(VR8);
-   if (o == GOF(CR2_0)   && sz == 1) return 8 +GOF(VR9);
-   if (o == GOF(CR3_321) && sz == 1) return 8 +GOF(VR10);
-   if (o == GOF(CR3_0)   && sz == 1) return 8 +GOF(VR11);
-   if (o == GOF(CR4_321) && sz == 1) return 8 +GOF(VR12);
-   if (o == GOF(CR4_0)   && sz == 1) return 8 +GOF(VR13);
-   if (o == GOF(CR5_321) && sz == 1) return 8 +GOF(VR14);
-   if (o == GOF(CR5_0)   && sz == 1) return 8 +GOF(VR15);
-   if (o == GOF(CR6_321) && sz == 1) return 8 +GOF(VR16);
-   if (o == GOF(CR6_0)   && sz == 1) return 8 +GOF(VR17);
-   if (o == GOF(CR7_321) && sz == 1) return 8 +GOF(VR18);
-   if (o == GOF(CR7_0)   && sz == 1) return 8 +GOF(VR19);
-
-   /* Vector registers .. use offset 0 in VR0 .. VR31. */
-   if (o >= GOF(VR0)  && o+sz <= GOF(VR0) +SZB(VR0))  return 0+ GOF(VR0);
-   if (o >= GOF(VR1)  && o+sz <= GOF(VR1) +SZB(VR1))  return 0+ GOF(VR1);
-   if (o >= GOF(VR2)  && o+sz <= GOF(VR2) +SZB(VR2))  return 0+ GOF(VR2);
-   if (o >= GOF(VR3)  && o+sz <= GOF(VR3) +SZB(VR3))  return 0+ GOF(VR3);
-   if (o >= GOF(VR4)  && o+sz <= GOF(VR4) +SZB(VR4))  return 0+ GOF(VR4);
-   if (o >= GOF(VR5)  && o+sz <= GOF(VR5) +SZB(VR5))  return 0+ GOF(VR5);
-   if (o >= GOF(VR6)  && o+sz <= GOF(VR6) +SZB(VR6))  return 0+ GOF(VR6);
-   if (o >= GOF(VR7)  && o+sz <= GOF(VR7) +SZB(VR7))  return 0+ GOF(VR7);
-   if (o >= GOF(VR8)  && o+sz <= GOF(VR8) +SZB(VR8))  return 0+ GOF(VR8);
-   if (o >= GOF(VR9)  && o+sz <= GOF(VR9) +SZB(VR9))  return 0+ GOF(VR9);
-   if (o >= GOF(VR10) && o+sz <= GOF(VR10)+SZB(VR10)) return 0+ GOF(VR10);
-   if (o >= GOF(VR11) && o+sz <= GOF(VR11)+SZB(VR11)) return 0+ GOF(VR11);
-   if (o >= GOF(VR12) && o+sz <= GOF(VR12)+SZB(VR12)) return 0+ GOF(VR12);
-   if (o >= GOF(VR13) && o+sz <= GOF(VR13)+SZB(VR13)) return 0+ GOF(VR13);
-   if (o >= GOF(VR14) && o+sz <= GOF(VR14)+SZB(VR14)) return 0+ GOF(VR14);
-   if (o >= GOF(VR15) && o+sz <= GOF(VR15)+SZB(VR15)) return 0+ GOF(VR15);
-   if (o >= GOF(VR16) && o+sz <= GOF(VR16)+SZB(VR16)) return 0+ GOF(VR16);
-   if (o >= GOF(VR17) && o+sz <= GOF(VR17)+SZB(VR17)) return 0+ GOF(VR17);
-   if (o >= GOF(VR18) && o+sz <= GOF(VR18)+SZB(VR18)) return 0+ GOF(VR18);
-   if (o >= GOF(VR19) && o+sz <= GOF(VR19)+SZB(VR19)) return 0+ GOF(VR19);
-   if (o >= GOF(VR20) && o+sz <= GOF(VR20)+SZB(VR20)) return 0+ GOF(VR20);
-   if (o >= GOF(VR21) && o+sz <= GOF(VR21)+SZB(VR21)) return 0+ GOF(VR21);
-   if (o >= GOF(VR22) && o+sz <= GOF(VR22)+SZB(VR22)) return 0+ GOF(VR22);
-   if (o >= GOF(VR23) && o+sz <= GOF(VR23)+SZB(VR23)) return 0+ GOF(VR23);
-   if (o >= GOF(VR24) && o+sz <= GOF(VR24)+SZB(VR24)) return 0+ GOF(VR24);
-   if (o >= GOF(VR25) && o+sz <= GOF(VR25)+SZB(VR25)) return 0+ GOF(VR25);
-   if (o >= GOF(VR26) && o+sz <= GOF(VR26)+SZB(VR26)) return 0+ GOF(VR26);
-   if (o >= GOF(VR27) && o+sz <= GOF(VR27)+SZB(VR27)) return 0+ GOF(VR27);
-   if (o >= GOF(VR28) && o+sz <= GOF(VR28)+SZB(VR28)) return 0+ GOF(VR28);
-   if (o >= GOF(VR29) && o+sz <= GOF(VR29)+SZB(VR29)) return 0+ GOF(VR29);
-   if (o >= GOF(VR30) && o+sz <= GOF(VR30)+SZB(VR30)) return 0+ GOF(VR30);
-   if (o >= GOF(VR31) && o+sz <= GOF(VR31)+SZB(VR31)) return 0+ GOF(VR31);
+      in VSR0 .. VSR19. */
+   tl_assert(SZB(VSR0) == 16);
+   if (o == GOF(XER_SO) && sz == 1) return 8 +GOF(VSR0);
+   if (o == GOF(XER_OV) && sz == 1) return 8 +GOF(VSR1);
+   if (o == GOF(XER_CA) && sz == 1) return 8 +GOF(VSR2);
+   if (o == GOF(XER_BC) && sz == 1) return 8 +GOF(VSR3);
+
+   if (o == GOF(CR0_321) && sz == 1) return 8 +GOF(VSR4);
+   if (o == GOF(CR0_0)   && sz == 1) return 8 +GOF(VSR5);
+   if (o == GOF(CR1_321) && sz == 1) return 8 +GOF(VSR6);
+   if (o == GOF(CR1_0)   && sz == 1) return 8 +GOF(VSR7);
+   if (o == GOF(CR2_321) && sz == 1) return 8 +GOF(VSR8);
+   if (o == GOF(CR2_0)   && sz == 1) return 8 +GOF(VSR9);
+   if (o == GOF(CR3_321) && sz == 1) return 8 +GOF(VSR10);
+   if (o == GOF(CR3_0)   && sz == 1) return 8 +GOF(VSR11);
+   if (o == GOF(CR4_321) && sz == 1) return 8 +GOF(VSR12);
+   if (o == GOF(CR4_0)   && sz == 1) return 8 +GOF(VSR13);
+   if (o == GOF(CR5_321) && sz == 1) return 8 +GOF(VSR14);
+   if (o == GOF(CR5_0)   && sz == 1) return 8 +GOF(VSR15);
+   if (o == GOF(CR6_321) && sz == 1) return 8 +GOF(VSR16);
+   if (o == GOF(CR6_0)   && sz == 1) return 8 +GOF(VSR17);
+   if (o == GOF(CR7_321) && sz == 1) return 8 +GOF(VSR18);
+   if (o == GOF(CR7_0)   && sz == 1) return 8 +GOF(VSR19);
+
+   /* Vector registers .. use offset 0 in VSR0 .. VSR63. */
+   if (o >= GOF(VSR0)  && o+sz <= GOF(VSR0) +SZB(VSR0))  return 0+ GOF(VSR0);
+   if (o >= GOF(VSR1)  && o+sz <= GOF(VSR1) +SZB(VSR1))  return 0+ GOF(VSR1);
+   if (o >= GOF(VSR2)  && o+sz <= GOF(VSR2) +SZB(VSR2))  return 0+ GOF(VSR2);
+   if (o >= GOF(VSR3)  && o+sz <= GOF(VSR3) +SZB(VSR3))  return 0+ GOF(VSR3);
+   if (o >= GOF(VSR4)  && o+sz <= GOF(VSR4) +SZB(VSR4))  return 0+ GOF(VSR4);
+   if (o >= GOF(VSR5)  && o+sz <= GOF(VSR5) +SZB(VSR5))  return 0+ GOF(VSR5);
+   if (o >= GOF(VSR6)  && o+sz <= GOF(VSR6) +SZB(VSR6))  return 0+ GOF(VSR6);
+   if (o >= GOF(VSR7)  && o+sz <= GOF(VSR7) +SZB(VSR7))  return 0+ GOF(VSR7);
+   if (o >= GOF(VSR8)  && o+sz <= GOF(VSR8) +SZB(VSR8))  return 0+ GOF(VSR8);
+   if (o >= GOF(VSR9)  && o+sz <= GOF(VSR9) +SZB(VSR9))  return 0+ GOF(VSR9);
+   if (o >= GOF(VSR10) && o+sz <= GOF(VSR10)+SZB(VSR10)) return 0+ GOF(VSR10);
+   if (o >= GOF(VSR11) && o+sz <= GOF(VSR11)+SZB(VSR11)) return 0+ GOF(VSR11);
+   if (o >= GOF(VSR12) && o+sz <= GOF(VSR12)+SZB(VSR12)) return 0+ GOF(VSR12);
+   if (o >= GOF(VSR13) && o+sz <= GOF(VSR13)+SZB(VSR13)) return 0+ GOF(VSR13);
+   if (o >= GOF(VSR14) && o+sz <= GOF(VSR14)+SZB(VSR14)) return 0+ GOF(VSR14);
+   if (o >= GOF(VSR15) && o+sz <= GOF(VSR15)+SZB(VSR15)) return 0+ GOF(VSR15);
+   if (o >= GOF(VSR16) && o+sz <= GOF(VSR16)+SZB(VSR16)) return 0+ GOF(VSR16);
+   if (o >= GOF(VSR17) && o+sz <= GOF(VSR17)+SZB(VSR17)) return 0+ GOF(VSR17);
+   if (o >= GOF(VSR18) && o+sz <= GOF(VSR18)+SZB(VSR18)) return 0+ GOF(VSR18);
+   if (o >= GOF(VSR19) && o+sz <= GOF(VSR19)+SZB(VSR19)) return 0+ GOF(VSR19);
+   if (o >= GOF(VSR20) && o+sz <= GOF(VSR20)+SZB(VSR20)) return 0+ GOF(VSR20);
+   if (o >= GOF(VSR21) && o+sz <= GOF(VSR21)+SZB(VSR21)) return 0+ GOF(VSR21);
+   if (o >= GOF(VSR22) && o+sz <= GOF(VSR22)+SZB(VSR22)) return 0+ GOF(VSR22);
+   if (o >= GOF(VSR23) && o+sz <= GOF(VSR23)+SZB(VSR23)) return 0+ GOF(VSR23);
+   if (o >= GOF(VSR24) && o+sz <= GOF(VSR24)+SZB(VSR24)) return 0+ GOF(VSR24);
+   if (o >= GOF(VSR25) && o+sz <= GOF(VSR25)+SZB(VSR25)) return 0+ GOF(VSR25);
+   if (o >= GOF(VSR26) && o+sz <= GOF(VSR26)+SZB(VSR26)) return 0+ GOF(VSR26);
+   if (o >= GOF(VSR27) && o+sz <= GOF(VSR27)+SZB(VSR27)) return 0+ GOF(VSR27);
+   if (o >= GOF(VSR28) && o+sz <= GOF(VSR28)+SZB(VSR28)) return 0+ GOF(VSR28);
+   if (o >= GOF(VSR29) && o+sz <= GOF(VSR29)+SZB(VSR29)) return 0+ GOF(VSR29);
+   if (o >= GOF(VSR30) && o+sz <= GOF(VSR30)+SZB(VSR30)) return 0+ GOF(VSR30);
+   if (o >= GOF(VSR31) && o+sz <= GOF(VSR31)+SZB(VSR31)) return 0+ GOF(VSR31);
+   if (o >= GOF(VSR32) && o+sz <= GOF(VSR32)+SZB(VSR32)) return 0+ GOF(VSR32);
+   if (o >= GOF(VSR33) && o+sz <= GOF(VSR33)+SZB(VSR33)) return 0+ GOF(VSR33);
+   if (o >= GOF(VSR34) && o+sz <= GOF(VSR34)+SZB(VSR34)) return 0+ GOF(VSR34);
+   if (o >= GOF(VSR35) && o+sz <= GOF(VSR35)+SZB(VSR35)) return 0+ GOF(VSR35);
+   if (o >= GOF(VSR36) && o+sz <= GOF(VSR36)+SZB(VSR36)) return 0+ GOF(VSR36);
+   if (o >= GOF(VSR37) && o+sz <= GOF(VSR37)+SZB(VSR37)) return 0+ GOF(VSR37);
+   if (o >= GOF(VSR38) && o+sz <= GOF(VSR38)+SZB(VSR38)) return 0+ GOF(VSR38);
+   if (o >= GOF(VSR39) && o+sz <= GOF(VSR39)+SZB(VSR39)) return 0+ GOF(VSR39);
+   if (o >= GOF(VSR40) && o+sz <= GOF(VSR40)+SZB(VSR40)) return 0+ GOF(VSR40);
+   if (o >= GOF(VSR41) && o+sz <= GOF(VSR41)+SZB(VSR41)) return 0+ GOF(VSR41);
+   if (o >= GOF(VSR42) && o+sz <= GOF(VSR42)+SZB(VSR42)) return 0+ GOF(VSR42);
+   if (o >= GOF(VSR43) && o+sz <= GOF(VSR43)+SZB(VSR43)) return 0+ GOF(VSR43);
+   if (o >= GOF(VSR44) && o+sz <= GOF(VSR44)+SZB(VSR44)) return 0+ GOF(VSR44);
+   if (o >= GOF(VSR45) && o+sz <= GOF(VSR45)+SZB(VSR45)) return 0+ GOF(VSR45);
+   if (o >= GOF(VSR46) && o+sz <= GOF(VSR46)+SZB(VSR46)) return 0+ GOF(VSR46);
+   if (o >= GOF(VSR47) && o+sz <= GOF(VSR47)+SZB(VSR47)) return 0+ GOF(VSR47);
+   if (o >= GOF(VSR48) && o+sz <= GOF(VSR48)+SZB(VSR48)) return 0+ GOF(VSR48);
+   if (o >= GOF(VSR49) && o+sz <= GOF(VSR49)+SZB(VSR49)) return 0+ GOF(VSR49);
+   if (o >= GOF(VSR50) && o+sz <= GOF(VSR50)+SZB(VSR50)) return 0+ GOF(VSR50);
+   if (o >= GOF(VSR51) && o+sz <= GOF(VSR51)+SZB(VSR51)) return 0+ GOF(VSR51);
+   if (o >= GOF(VSR52) && o+sz <= GOF(VSR52)+SZB(VSR52)) return 0+ GOF(VSR52);
+   if (o >= GOF(VSR53) && o+sz <= GOF(VSR53)+SZB(VSR53)) return 0+ GOF(VSR53);
+   if (o >= GOF(VSR54) && o+sz <= GOF(VSR54)+SZB(VSR54)) return 0+ GOF(VSR54);
+   if (o >= GOF(VSR55) && o+sz <= GOF(VSR55)+SZB(VSR55)) return 0+ GOF(VSR55);
+   if (o >= GOF(VSR56) && o+sz <= GOF(VSR56)+SZB(VSR56)) return 0+ GOF(VSR56);
+   if (o >= GOF(VSR57) && o+sz <= GOF(VSR57)+SZB(VSR57)) return 0+ GOF(VSR57);
+   if (o >= GOF(VSR58) && o+sz <= GOF(VSR58)+SZB(VSR58)) return 0+ GOF(VSR58);
+   if (o >= GOF(VSR59) && o+sz <= GOF(VSR59)+SZB(VSR59)) return 0+ GOF(VSR59);
+   if (o >= GOF(VSR60) && o+sz <= GOF(VSR60)+SZB(VSR60)) return 0+ GOF(VSR60);
+   if (o >= GOF(VSR61) && o+sz <= GOF(VSR61)+SZB(VSR61)) return 0+ GOF(VSR61);
+   if (o >= GOF(VSR62) && o+sz <= GOF(VSR62)+SZB(VSR62)) return 0+ GOF(VSR62);
+   if (o >= GOF(VSR63) && o+sz <= GOF(VSR63)+SZB(VSR63)) return 0+ GOF(VSR63);
 
    VG_(printf)("MC_(get_otrack_shadow_offset)(ppc64)(off=%d,sz=%d)\n",
                offset,szB);
@@ -359,98 +400,139 @@ static Int get_otrack_shadow_offset_wrk 
    if (o == GOF(REDIR_SP)  && sz == 4) return -1;
    if (o == GOF(SPRG3_RO)  && sz == 4) return -1;
 
-   tl_assert(SZB(FPR0) == 8);
-   if (o == GOF(FPR0) && sz == 8) return o;
-   if (o == GOF(FPR1) && sz == 8) return o;
-   if (o == GOF(FPR2) && sz == 8) return o;
-   if (o == GOF(FPR3) && sz == 8) return o;
-   if (o == GOF(FPR4) && sz == 8) return o;
-   if (o == GOF(FPR5) && sz == 8) return o;
-   if (o == GOF(FPR6) && sz == 8) return o;
-   if (o == GOF(FPR7) && sz == 8) return o;
-   if (o == GOF(FPR8) && sz == 8) return o;
-   if (o == GOF(FPR9) && sz == 8) return o;
-   if (o == GOF(FPR10) && sz == 8) return o;
-   if (o == GOF(FPR11) && sz == 8) return o;
-   if (o == GOF(FPR12) && sz == 8) return o;
-   if (o == GOF(FPR13) && sz == 8) return o;
-   if (o == GOF(FPR14) && sz == 8) return o;
-   if (o == GOF(FPR15) && sz == 8) return o;
-   if (o == GOF(FPR16) && sz == 8) return o;
-   if (o == GOF(FPR17) && sz == 8) return o;
-   if (o == GOF(FPR18) && sz == 8) return o;
-   if (o == GOF(FPR19) && sz == 8) return o;
-   if (o == GOF(FPR20) && sz == 8) return o;
-   if (o == GOF(FPR21) && sz == 8) return o;
-   if (o == GOF(FPR22) && sz == 8) return o;
-   if (o == GOF(FPR23) && sz == 8) return o;
-   if (o == GOF(FPR24) && sz == 8) return o;
-   if (o == GOF(FPR25) && sz == 8) return o;
-   if (o == GOF(FPR26) && sz == 8) return o;
-   if (o == GOF(FPR27) && sz == 8) return o;
-   if (o == GOF(FPR28) && sz == 8) return o;
-   if (o == GOF(FPR29) && sz == 8) return o;
-   if (o == GOF(FPR30) && sz == 8) return o;
-   if (o == GOF(FPR31) && sz == 8) return o;
+   // With ISA 2.06, the "Vector-Scalar Floating-point" category
+   // provides facilities to support vector and scalar binary floating-
+   // point operations.  A unified register file is an integral part
+   // of this new facility, combining floating point and vector registers
+   // using a 64x128-bit vector.  These are referred to as VSR[0..63].
+   // The floating point registers are now mapped into double word element 0
+   // of VSR[0..31]. The 32x128-bit vector registers defined by the "Vector
+   // Facility [Category: Vector]" are now mapped to VSR[32..63].
+
+   //  Floating point registers . . .
+   if (o == GOF(VSR0) && sz == 8) return o;
+   if (o == GOF(VSR1) && sz == 8) return o;
+   if (o == GOF(VSR2) && sz == 8) return o;
+   if (o == GOF(VSR3) && sz == 8) return o;
+   if (o == GOF(VSR4) && sz == 8) return o;
+   if (o == GOF(VSR5) && sz == 8) return o;
+   if (o == GOF(VSR6) && sz == 8) return o;
+   if (o == GOF(VSR7) && sz == 8) return o;
+   if (o == GOF(VSR8) && sz == 8) return o;
+   if (o == GOF(VSR9) && sz == 8) return o;
+   if (o == GOF(VSR10) && sz == 8) return o;
+   if (o == GOF(VSR11) && sz == 8) return o;
+   if (o == GOF(VSR12) && sz == 8) return o;
+   if (o == GOF(VSR13) && sz == 8) return o;
+   if (o == GOF(VSR14) && sz == 8) return o;
+   if (o == GOF(VSR15) && sz == 8) return o;
+   if (o == GOF(VSR16) && sz == 8) return o;
+   if (o == GOF(VSR17) && sz == 8) return o;
+   if (o == GOF(VSR18) && sz == 8) return o;
+   if (o == GOF(VSR19) && sz == 8) return o;
+   if (o == GOF(VSR20) && sz == 8) return o;
+   if (o == GOF(VSR21) && sz == 8) return o;
+   if (o == GOF(VSR22) && sz == 8) return o;
+   if (o == GOF(VSR23) && sz == 8) return o;
+   if (o == GOF(VSR24) && sz == 8) return o;
+   if (o == GOF(VSR25) && sz == 8) return o;
+   if (o == GOF(VSR26) && sz == 8) return o;
+   if (o == GOF(VSR27) && sz == 8) return o;
+   if (o == GOF(VSR28) && sz == 8) return o;
+   if (o == GOF(VSR29) && sz == 8) return o;
+   if (o == GOF(VSR30) && sz == 8) return o;
+   if (o == GOF(VSR31) && sz == 8) return o;
 
    /* For the various byte sized XER/CR pieces, use offset 8
-      in VR0 .. VR31. */
-   tl_assert(SZB(VR0) == 16);
-   if (o == GOF(XER_SO) && sz == 1) return 8 +GOF(VR0);
-   if (o == GOF(XER_OV) && sz == 1) return 8 +GOF(VR1);
-   if (o == GOF(XER_CA) && sz == 1) return 8 +GOF(VR2);
-   if (o == GOF(XER_BC) && sz == 1) return 8 +GOF(VR3);
-
-   if (o == GOF(CR0_321) && sz == 1) return 8 +GOF(VR4);
-   if (o == GOF(CR0_0)   && sz == 1) return 8 +GOF(VR5);
-   if (o == GOF(CR1_321) && sz == 1) return 8 +GOF(VR6);
-   if (o == GOF(CR1_0)   && sz == 1) return 8 +GOF(VR7);
-   if (o == GOF(CR2_321) && sz == 1) return 8 +GOF(VR8);
-   if (o == GOF(CR2_0)   && sz == 1) return 8 +GOF(VR9);
-   if (o == GOF(CR3_321) && sz == 1) return 8 +GOF(VR10);
-   if (o == GOF(CR3_0)   && sz == 1) return 8 +GOF(VR11);
-   if (o == GOF(CR4_321) && sz == 1) return 8 +GOF(VR12);
-   if (o == GOF(CR4_0)   && sz == 1) return 8 +GOF(VR13);
-   if (o == GOF(CR5_321) && sz == 1) return 8 +GOF(VR14);
-   if (o == GOF(CR5_0)   && sz == 1) return 8 +GOF(VR15);
-   if (o == GOF(CR6_321) && sz == 1) return 8 +GOF(VR16);
-   if (o == GOF(CR6_0)   && sz == 1) return 8 +GOF(VR17);
-   if (o == GOF(CR7_321) && sz == 1) return 8 +GOF(VR18);
-   if (o == GOF(CR7_0)   && sz == 1) return 8 +GOF(VR19);
-
-   /* Vector registers .. use offset 0 in VR0 .. VR31. */
-   if (o >= GOF(VR0)  && o+sz <= GOF(VR0) +SZB(VR0))  return 0+ GOF(VR0);
-   if (o >= GOF(VR1)  && o+sz <= GOF(VR1) +SZB(VR1))  return 0+ GOF(VR1);
-   if (o >= GOF(VR2)  && o+sz <= GOF(VR2) +SZB(VR2))  return 0+ GOF(VR2);
-   if (o >= GOF(VR3)  && o+sz <= GOF(VR3) +SZB(VR3))  return 0+ GOF(VR3);
-   if (o >= GOF(VR4)  && o+sz <= GOF(VR4) +SZB(VR4))  return 0+ GOF(VR4);
-   if (o >= GOF(VR5)  && o+sz <= GOF(VR5) +SZB(VR5))  return 0+ GOF(VR5);
-   if (o >= GOF(VR6)  && o+sz <= GOF(VR6) +SZB(VR6))  return 0+ GOF(VR6);
-   if (o >= GOF(VR7)  && o+sz <= GOF(VR7) +SZB(VR7))  return 0+ GOF(VR7);
-   if (o >= GOF(VR8)  && o+sz <= GOF(VR8) +SZB(VR8))  return 0+ GOF(VR8);
-   if (o >= GOF(VR9)  && o+sz <= GOF(VR9) +SZB(VR9))  return 0+ GOF(VR9);
-   if (o >= GOF(VR10) && o+sz <= GOF(VR10)+SZB(VR10)) return 0+ GOF(VR10);
-   if (o >= GOF(VR11) && o+sz <= GOF(VR11)+SZB(VR11)) return 0+ GOF(VR11);
-   if (o >= GOF(VR12) && o+sz <= GOF(VR12)+SZB(VR12)) return 0+ GOF(VR12);
-   if (o >= GOF(VR13) && o+sz <= GOF(VR13)+SZB(VR13)) return 0+ GOF(VR13);
-   if (o >= GOF(VR14) && o+sz <= GOF(VR14)+SZB(VR14)) return 0+ GOF(VR14);
-   if (o >= GOF(VR15) && o+sz <= GOF(VR15)+SZB(VR15)) return 0+ GOF(VR15);
-   if (o >= GOF(VR16) && o+sz <= GOF(VR16)+SZB(VR16)) return 0+ GOF(VR16);
-   if (o >= GOF(VR17) && o+sz <= GOF(VR17)+SZB(VR17)) return 0+ GOF(VR17);
-   if (o >= GOF(VR18) && o+sz <= GOF(VR18)+SZB(VR18)) return 0+ GOF(VR18);
-   if (o >= GOF(VR19) && o+sz <= GOF(VR19)+SZB(VR19)) return 0+ GOF(VR19);
-   if (o >= GOF(VR20) && o+sz <= GOF(VR20)+SZB(VR20)) return 0+ GOF(VR20);
-   if (o >= GOF(VR21) && o+sz <= GOF(VR21)+SZB(VR21)) return 0+ GOF(VR21);
-   if (o >= GOF(VR22) && o+sz <= GOF(VR22)+SZB(VR22)) return 0+ GOF(VR22);
-   if (o >= GOF(VR23) && o+sz <= GOF(VR23)+SZB(VR23)) return 0+ GOF(VR23);
-   if (o >= GOF(VR24) && o+sz <= GOF(VR24)+SZB(VR24)) return 0+ GOF(VR24);
-   if (o >= GOF(VR25) && o+sz <= GOF(VR25)+SZB(VR25)) return 0+ GOF(VR25);
-   if (o >= GOF(VR26) && o+sz <= GOF(VR26)+SZB(VR26)) return 0+ GOF(VR26);
-   if (o >= GOF(VR27) && o+sz <= GOF(VR27)+SZB(VR27)) return 0+ GOF(VR27);
-   if (o >= GOF(VR28) && o+sz <= GOF(VR28)+SZB(VR28)) return 0+ GOF(VR28);
-   if (o >= GOF(VR29) && o+sz <= GOF(VR29)+SZB(VR29)) return 0+ GOF(VR29);
-   if (o >= GOF(VR30) && o+sz <= GOF(VR30)+SZB(VR30)) return 0+ GOF(VR30);
-   if (o >= GOF(VR31) && o+sz <= GOF(VR31)+SZB(VR31)) return 0+ GOF(VR31);
+      in VSR0 .. VSR19. */
+   tl_assert(SZB(VSR0) == 16);
+   if (o == GOF(XER_SO) && sz == 1) return 8 +GOF(VSR0);
+   if (o == GOF(XER_OV) && sz == 1) return 8 +GOF(VSR1);
+   if (o == GOF(XER_CA) && sz == 1) return 8 +GOF(VSR2);
+   if (o == GOF(XER_BC) && sz == 1) return 8 +GOF(VSR3);
+
+   if (o == GOF(CR0_321) && sz == 1) return 8 +GOF(VSR4);
+   if (o == GOF(CR0_0)   && sz == 1) return 8 +GOF(VSR5);
+   if (o == GOF(CR1_321) && sz == 1) return 8 +GOF(VSR6);
+   if (o == GOF(CR1_0)   && sz == 1) return 8 +GOF(VSR7);
+   if (o == GOF(CR2_321) && sz == 1) return 8 +GOF(VSR8);
+   if (o == GOF(CR2_0)   && sz == 1) return 8 +GOF(VSR9);
+   if (o == GOF(CR3_321) && sz == 1) return 8 +GOF(VSR10);
+   if (o == GOF(CR3_0)   && sz == 1) return 8 +GOF(VSR11);
+   if (o == GOF(CR4_321) && sz == 1) return 8 +GOF(VSR12);
+   if (o == GOF(CR4_0)   && sz == 1) return 8 +GOF(VSR13);
+   if (o == GOF(CR5_321) && sz == 1) return 8 +GOF(VSR14);
+   if (o == GOF(CR5_0)   && sz == 1) return 8 +GOF(VSR15);
+   if (o == GOF(CR6_321) && sz == 1) return 8 +GOF(VSR16);
+   if (o == GOF(CR6_0)   && sz == 1) return 8 +GOF(VSR17);
+   if (o == GOF(CR7_321) && sz == 1) return 8 +GOF(VSR18);
+   if (o == GOF(CR7_0)   && sz == 1) return 8 +GOF(VSR19);
+
+   /* Vector registers .. use offset 0 in VSR0 .. VSR63. */
+   if (o >= GOF(VSR0)  && o+sz <= GOF(VSR0) +SZB(VSR0))  return 0+ GOF(VSR0);
+   if (o >= GOF(VSR1)  && o+sz <= GOF(VSR1) +SZB(VSR1))  return 0+ GOF(VSR1);
+   if (o >= GOF(VSR2)  && o+sz <= GOF(VSR2) +SZB(VSR2))  return 0+ GOF(VSR2);
+   if (o >= GOF(VSR3)  && o+sz <= GOF(VSR3) +SZB(VSR3))  return 0+ GOF(VSR3);
+   if (o >= GOF(VSR4)  && o+sz <= GOF(VSR4) +SZB(VSR4))  return 0+ GOF(VSR4);
+   if (o >= GOF(VSR5)  && o+sz <= GOF(VSR5) +SZB(VSR5))  return 0+ GOF(VSR5);
+   if (o >= GOF(VSR6)  && o+sz <= GOF(VSR6) +SZB(VSR6))  return 0+ GOF(VSR6);
+   if (o >= GOF(VSR7)  && o+sz <= GOF(VSR7) +SZB(VSR7))  return 0+ GOF(VSR7);
+   if (o >= GOF(VSR8)  && o+sz <= GOF(VSR8) +SZB(VSR8))  return 0+ GOF(VSR8);
+   if (o >= GOF(VSR9)  && o+sz <= GOF(VSR9) +SZB(VSR9))  return 0+ GOF(VSR9);
+   if (o >= GOF(VSR10) && o+sz <= GOF(VSR10)+SZB(VSR10)) return 0+ GOF(VSR10);
+   if (o >= GOF(VSR11) && o+sz <= GOF(VSR11)+SZB(VSR11)) return 0+ GOF(VSR11);
+   if (o >= GOF(VSR12) && o+sz <= GOF(VSR12)+SZB(VSR12)) return 0+ GOF(VSR12);
+   if (o >= GOF(VSR13) && o+sz <= GOF(VSR13)+SZB(VSR13)) return 0+ GOF(VSR13);
+   if (o >= GOF(VSR14) && o+sz <= GOF(VSR14)+SZB(VSR14)) return 0+ GOF(VSR14);
+   if (o >= GOF(VSR15) && o+sz <= GOF(VSR15)+SZB(VSR15)) return 0+ GOF(VSR15);
+   if (o >= GOF(VSR16) && o+sz <= GOF(VSR16)+SZB(VSR16)) return 0+ GOF(VSR16);
+   if (o >= GOF(VSR17) && o+sz <= GOF(VSR17)+SZB(VSR17)) return 0+ GOF(VSR17);
+   if (o >= GOF(VSR18) && o+sz <= GOF(VSR18)+SZB(VSR18)) return 0+ GOF(VSR18);
+   if (o >= GOF(VSR19) && o+sz <= GOF(VSR19)+SZB(VSR19)) return 0+ GOF(VSR19);
+   if (o >= GOF(VSR20) && o+sz <= GOF(VSR20)+SZB(VSR20)) return 0+ GOF(VSR20);
+   if (o >= GOF(VSR21) && o+sz <= GOF(VSR21)+SZB(VSR21)) return 0+ GOF(VSR21);
+   if (o >= GOF(VSR22) && o+sz <= GOF(VSR22)+SZB(VSR22)) return 0+ GOF(VSR22);
+   if (o >= GOF(VSR23) && o+sz <= GOF(VSR23)+SZB(VSR23)) return 0+ GOF(VSR23);
+   if (o >= GOF(VSR24) && o+sz <= GOF(VSR24)+SZB(VSR24)) return 0+ GOF(VSR24);
+   if (o >= GOF(VSR25) && o+sz <= GOF(VSR25)+SZB(VSR25)) return 0+ GOF(VSR25);
+   if (o >= GOF(VSR26) && o+sz <= GOF(VSR26)+SZB(VSR26)) return 0+ GOF(VSR26);
+   if (o >= GOF(VSR27) && o+sz <= GOF(VSR27)+SZB(VSR27)) return 0+ GOF(VSR27);
+   if (o >= GOF(VSR28) && o+sz <= GOF(VSR28)+SZB(VSR28)) return 0+ GOF(VSR28);
+   if (o >= GOF(VSR29) && o+sz <= GOF(VSR29)+SZB(VSR29)) return 0+ GOF(VSR29);
+   if (o >= GOF(VSR30) && o+sz <= GOF(VSR30)+SZB(VSR30)) return 0+ GOF(VSR30);
+   if (o >= GOF(VSR31) && o+sz <= GOF(VSR31)+SZB(VSR31)) return 0+ GOF(VSR31);
+   if (o >= GOF(VSR32) && o+sz <= GOF(VSR32)+SZB(VSR32)) return 0+ GOF(VSR32);
+   if (o >= GOF(VSR33) && o+sz <= GOF(VSR33)+SZB(VSR33)) return 0+ GOF(VSR33);
+   if (o >= GOF(VSR34) && o+sz <= GOF(VSR34)+SZB(VSR34)) return 0+ GOF(VSR34);
+   if (o >= GOF(VSR35) && o+sz <= GOF(VSR35)+SZB(VSR35)) return 0+ GOF(VSR35);
+   if (o >= GOF(VSR36) && o+sz <= GOF(VSR36)+SZB(VSR36)) return 0+ GOF(VSR36);
+   if (o >= GOF(VSR37) && o+sz <= GOF(VSR37)+SZB(VSR37)) return 0+ GOF(VSR37);
+   if (o >= GOF(VSR38) && o+sz <= GOF(VSR38)+SZB(VSR38)) return 0+ GOF(VSR38);
+   if (o >= GOF(VSR39) && o+sz <= GOF(VSR39)+SZB(VSR39)) return 0+ GOF(VSR39);
+   if (o >= GOF(VSR40) && o+sz <= GOF(VSR40)+SZB(VSR40)) return 0+ GOF(VSR40);
+   if (o >= GOF(VSR41) && o+sz <= GOF(VSR41)+SZB(VSR41)) return 0+ GOF(VSR41);
+   if (o >= GOF(VSR42) && o+sz <= GOF(VSR42)+SZB(VSR42)) return 0+ GOF(VSR42);
+   if (o >= GOF(VSR43) && o+sz <= GOF(VSR43)+SZB(VSR43)) return 0+ GOF(VSR43);
+   if (o >= GOF(VSR44) && o+sz <= GOF(VSR44)+SZB(VSR44)) return 0+ GOF(VSR44);
+   if (o >= GOF(VSR45) && o+sz <= GOF(VSR45)+SZB(VSR45)) return 0+ GOF(VSR45);
+   if (o >= GOF(VSR46) && o+sz <= GOF(VSR46)+SZB(VSR46)) return 0+ GOF(VSR46);
+   if (o >= GOF(VSR47) && o+sz <= GOF(VSR47)+SZB(VSR47)) return 0+ GOF(VSR47);
+   if (o >= GOF(VSR48) && o+sz <= GOF(VSR48)+SZB(VSR48)) return 0+ GOF(VSR48);
+   if (o >= GOF(VSR49) && o+sz <= GOF(VSR49)+SZB(VSR49)) return 0+ GOF(VSR49);
+   if (o >= GOF(VSR50) && o+sz <= GOF(VSR50)+SZB(VSR50)) return 0+ GOF(VSR50);
+   if (o >= GOF(VSR51) && o+sz <= GOF(VSR51)+SZB(VSR51)) return 0+ GOF(VSR51);
+   if (o >= GOF(VSR52) && o+sz <= GOF(VSR52)+SZB(VSR52)) return 0+ GOF(VSR52);
+   if (o >= GOF(VSR53) && o+sz <= GOF(VSR53)+SZB(VSR53)) return 0+ GOF(VSR53);
+   if (o >= GOF(VSR54) && o+sz <= GOF(VSR54)+SZB(VSR54)) return 0+ GOF(VSR54);
+   if (o >= GOF(VSR55) && o+sz <= GOF(VSR55)+SZB(VSR55)) return 0+ GOF(VSR55);
+   if (o >= GOF(VSR56) && o+sz <= GOF(VSR56)+SZB(VSR56)) return 0+ GOF(VSR56);
+   if (o >= GOF(VSR57) && o+sz <= GOF(VSR57)+SZB(VSR57)) return 0+ GOF(VSR57);
+   if (o >= GOF(VSR58) && o+sz <= GOF(VSR58)+SZB(VSR58)) return 0+ GOF(VSR58);
+   if (o >= GOF(VSR59) && o+sz <= GOF(VSR59)+SZB(VSR59)) return 0+ GOF(VSR59);
+   if (o >= GOF(VSR60) && o+sz <= GOF(VSR60)+SZB(VSR60)) return 0+ GOF(VSR60);
+   if (o >= GOF(VSR61) && o+sz <= GOF(VSR61)+SZB(VSR61)) return 0+ GOF(VSR61);
+   if (o >= GOF(VSR62) && o+sz <= GOF(VSR62)+SZB(VSR62)) return 0+ GOF(VSR62);
+   if (o >= GOF(VSR63) && o+sz <= GOF(VSR63)+SZB(VSR63)) return 0+ GOF(VSR63);
 
    VG_(printf)("MC_(get_otrack_shadow_offset)(ppc32)(off=%d,sz=%d)\n",
                offset,szB);
--- valgrind-3.6.0/memcheck/mc_translate.c	(revision 11696)
+++ valgrind-3.6.0/memcheck/mc_translate.c	(revision 11700)
@@ -2936,6 +2936,7 @@ IRAtom* expr2vbits_Binop ( MCEnv* mce,
       case Iop_RoundF64toF32:
       case Iop_F64toI64S:
       case Iop_I64StoF64:
+      case Iop_I64UtoF64:
       case Iop_SinF64:
       case Iop_CosF64:
       case Iop_TanF64:
@@ -2972,6 +2973,7 @@ IRAtom* expr2vbits_Binop ( MCEnv* mce,
       case Iop_F64toI32U:
       case Iop_F64toI32S:
       case Iop_F64toF32:
+      case Iop_I64UtoF32:
          /* First arg is I32 (rounding mode), second is F64 (data). */
          return mkLazy2(mce, Ity_I32, vatom1, vatom2);
 
@@ -3452,6 +3454,7 @@ IRExpr* expr2vbits_Unop ( MCEnv* mce, IR
          return mkPCast16x8(mce,
                assignNew('V', mce, Ity_V128, unop(op, mkPCast8x16(mce, vatom))));
 
+      case Iop_I64UtoF32:
       default:
          ppIROp(op);
          VG_(tool_panic)("memcheck:expr2vbits_Unop");
--- valgrind-3.6.0/configure.in	(revision 11696)
+++ valgrind-3.6.0/configure.in	(revision 11700)
@@ -968,6 +968,38 @@ CFLAGS=$safe_CFLAGS
 AM_CONDITIONAL([HAS_ALTIVEC], [test x$ac_have_altivec = xyes])
 
 
+# Check that both: the compiler supports -mvsx and that the assembler
+# understands VSX instructions.  If either of those doesn't work,
+# conclude that we can't do VSX.  NOTE: basically this is a kludge
+# in that it conflates two things that should be separate -- whether
+# the compiler understands the flag vs whether the assembler 
+# understands the opcodes.  This really ought to be cleaned up
+# and done properly, like it is for x86/x86_64.
+
+AC_MSG_CHECKING([for VSX])
+
+safe_CFLAGS=$CFLAGS
+CFLAGS="-mvsx"
+
+AC_TRY_COMPILE(
+[
+#include <altivec.h>
+], [
+  vector unsigned int v;
+  __asm__ __volatile__("xsmaddadp 32, 32, 33" ::: "memory","cc");
+],
+[
+ac_have_vsx=yes
+AC_MSG_RESULT([yes])
+], [
+ac_have_vsx=no
+AC_MSG_RESULT([no])
+])
+CFLAGS=$safe_CFLAGS
+
+AM_CONDITIONAL(HAS_VSX, test x$ac_have_vsx = xyes)
+
+
 # Check for pthread_create@GLIBC2.0
 AC_MSG_CHECKING([for pthread_create@GLIBC2.0()])
 
--- valgrind-3.6.0/none/tests/ppc32/test_isa_2_06_part1.stdout.exp	(revision 0)
+++ valgrind-3.6.0/none/tests/ppc32/test_isa_2_06_part1.stdout.exp	(revision 11700)
@@ -0,0 +1,1023 @@
+Test VSX load/store instructions
+lxsdx: 01234567 89abcdef => 01234567 89abcdef
+lxsdx: 8899aabb 91929394 => 8899aabb 91929394
+
+lxsdx: 01234567 89abcdef => 01234567 89abcdef
+lxsdx: 89abcdef 00112233 => 89abcdef 00112233
+lxsdx: 8899aabb 91929394 => 8899aabb 91929394
+lxsdx: 91929394 a1a2a3a4 => 91929394 a1a2a3a4
+
+lxvd2x: 01234567 89abcdef 00112233 44556677 => 01234567 89abcdef 00112233 44556677
+lxvd2x: 8899aabb 91929394 a1a2a3a4 b1b2b3b4 => 8899aabb 91929394 a1a2a3a4 b1b2b3b4
+
+lxvd2x: 01234567 89abcdef 00112233 44556677 => 01234567 89abcdef 00112233 44556677
+lxvd2x: 89abcdef 00112233 44556677 8899aabb => 89abcdef 00112233 44556677 8899aabb
+lxvd2x: 8899aabb 91929394 a1a2a3a4 b1b2b3b4 => 8899aabb 91929394 a1a2a3a4 b1b2b3b4
+lxvd2x: 91929394 a1a2a3a4 b1b2b3b4 c1c2c3c4 => 91929394 a1a2a3a4 b1b2b3b4 c1c2c3c4
+
+lxvdsx: 01234567 89abcdef 01234567 89abcdef => 01234567 89abcdef 01234567 89abcdef
+lxvdsx: 8899aabb 91929394 8899aabb 91929394 => 8899aabb 91929394 8899aabb 91929394
+
+lxvdsx: 01234567 89abcdef 01234567 89abcdef => 01234567 89abcdef 01234567 89abcdef
+lxvdsx: 89abcdef 00112233 89abcdef 00112233 => 89abcdef 00112233 89abcdef 00112233
+lxvdsx: 8899aabb 91929394 8899aabb 91929394 => 8899aabb 91929394 8899aabb 91929394
+lxvdsx: 91929394 a1a2a3a4 91929394 a1a2a3a4 => 91929394 a1a2a3a4 91929394 a1a2a3a4
+
+lxvw4x: 01234567 89abcdef 00112233 44556677 => 01234567 89abcdef 00112233 44556677
+lxvw4x: 8899aabb 91929394 a1a2a3a4 b1b2b3b4 => 8899aabb 91929394 a1a2a3a4 b1b2b3b4
+
+lxvw4x: 01234567 89abcdef 00112233 44556677 => 01234567 89abcdef 00112233 44556677
+lxvw4x: 89abcdef 00112233 44556677 8899aabb => 89abcdef 00112233 44556677 8899aabb
+lxvw4x: 8899aabb 91929394 a1a2a3a4 b1b2b3b4 => 8899aabb 91929394 a1a2a3a4 b1b2b3b4
+lxvw4x: 91929394 a1a2a3a4 b1b2b3b4 c1c2c3c4 => 91929394 a1a2a3a4 b1b2b3b4 c1c2c3c4
+
+stxsdx: 01234567 89abcdef => 01234567 89abcdef
+
+stxsdx: 01234567 89abcdef => 01234567 89abcdef
+
+stxvd2x: 01234567 89abcdef 00112233 44556677 => 01234567 89abcdef 00112233 44556677
+
+stxvd2x: 01234567 89abcdef 00112233 44556677 => 01234567 89abcdef 00112233 44556677
+
+stxvw4x: 01234567 89abcdef 00112233 44556677 => 01234567 89abcdef 00112233 44556677
+
+stxvw4x: 01234567 89abcdef 00112233 44556677 => 01234567 89abcdef 00112233 44556677
+
+Test VSX logic instructions
+xxlxor: 01234567 89abcdef 00112233 44556677 xxlxor 8899aabb 91929394 a1a2a3a4 b1b2b3b4 => 89baefdc 18395e7b a1b38197 f5e7d5c3
+xxlxor: 89abcdef 00112233 44556677 8899aabb xxlxor 91929394 a1a2a3a4 b1b2b3b4 c1c2c3c4 => 18395e7b a1b38197 f5e7d5c3 495b697f
+xxlxor: 00112233 44556677 8899aabb 91929394 xxlxor a1a2a3a4 b1b2b3b4 c1c2c3c4 d1d2d3d4 => a1b38197 f5e7d5c3 495b697f 40404040
+xxlxor: 44556677 8899aabb 91929394 a1a2a3a4 xxlxor b1b2b3b4 c1c2c3c4 d1d2d3d4 7a6b5d3e => f5e7d5c3 495b697f 40404040 dbc9fe9a
+xxlor: 01234567 89abcdef 00112233 44556677 xxlor 8899aabb 91929394 a1a2a3a4 b1b2b3b4 => 89bbefff 99bbdfff a1b3a3b7 f5f7f7f7
+xxlor: 89abcdef 00112233 44556677 8899aabb xxlor 91929394 a1a2a3a4 b1b2b3b4 c1c2c3c4 => 99bbdfff a1b3a3b7 f5f7f7f7 c9dbebff
+xxlor: 00112233 44556677 8899aabb 91929394 xxlor a1a2a3a4 b1b2b3b4 c1c2c3c4 d1d2d3d4 => a1b3a3b7 f5f7f7f7 c9dbebff d1d2d3d4
+xxlor: 44556677 8899aabb 91929394 a1a2a3a4 xxlor b1b2b3b4 c1c2c3c4 d1d2d3d4 7a6b5d3e => f5f7f7f7 c9dbebff d1d2d3d4 fbebffbe
+xxlnor: 01234567 89abcdef 00112233 44556677 xxlnor 8899aabb 91929394 a1a2a3a4 b1b2b3b4 => 76441000 66442000 5e4c5c48 0a080808
+xxlnor: 89abcdef 00112233 44556677 8899aabb xxlnor 91929394 a1a2a3a4 b1b2b3b4 c1c2c3c4 => 66442000 5e4c5c48 0a080808 36241400
+xxlnor: 00112233 44556677 8899aabb 91929394 xxlnor a1a2a3a4 b1b2b3b4 c1c2c3c4 d1d2d3d4 => 5e4c5c48 0a080808 36241400 2e2d2c2b
+xxlnor: 44556677 8899aabb 91929394 a1a2a3a4 xxlnor b1b2b3b4 c1c2c3c4 d1d2d3d4 7a6b5d3e => 0a080808 36241400 2e2d2c2b 04140041
+xxland: 01234567 89abcdef 00112233 44556677 xxland 8899aabb 91929394 a1a2a3a4 b1b2b3b4 => 00010023 81828184 00002220 00102234
+xxland: 89abcdef 00112233 44556677 8899aabb xxland 91929394 a1a2a3a4 b1b2b3b4 c1c2c3c4 => 81828184 00002220 00102234 80808280
+xxland: 00112233 44556677 8899aabb 91929394 xxland a1a2a3a4 b1b2b3b4 c1c2c3c4 d1d2d3d4 => 00002220 00102234 80808280 91929394
+xxland: 44556677 8899aabb 91929394 a1a2a3a4 xxland b1b2b3b4 c1c2c3c4 d1d2d3d4 7a6b5d3e => 00102234 80808280 91929394 20220124
+xxlandc: 01234567 89abcdef 00112233 44556677 xxlandc 8899aabb 91929394 a1a2a3a4 b1b2b3b4 => 01224544 08294c6b 00110013 44454443
+xxlandc: 89abcdef 00112233 44556677 8899aabb xxlandc 91929394 a1a2a3a4 b1b2b3b4 c1c2c3c4 => 08294c6b 00110013 44454443 0819283b
+xxlandc: 00112233 44556677 8899aabb 91929394 xxlandc a1a2a3a4 b1b2b3b4 c1c2c3c4 d1d2d3d4 => 00110013 44454443 0819283b 00000000
+xxlandc: 44556677 8899aabb 91929394 a1a2a3a4 xxlandc b1b2b3b4 c1c2c3c4 d1d2d3d4 7a6b5d3e => 44454443 0819283b 00000000 8180a280
+
+Test lfiwzx instruction
+lfiwzx: 19088743 => 19088743.00
+lfiwzx: 2309737967 => 2309737967.00
+lfiwzx: 1122867 => 1122867.00
+
+Test P7 floating point convert instructions
+fcfids 0010000000000001 => (raw sp) 59800000)
+fcfids 00100094e0000359 => (raw sp) 598004a7)
+fcfids 3fe0000000000001 => (raw sp) 5e7f8000)
+fcfids 3fe00094e0000359 => (raw sp) 5e7f8002)
+fcfids 8010000000000001 => (raw sp) deffe000)
+fcfids 80100094e0000359 => (raw sp) deffdfff)
+fcfids bfe0000000000001 => (raw sp) de804000)
+fcfids bfe00094e0000359 => (raw sp) de803fff)
+fcfids 0020000000000b01 => (raw sp) 5a000000)
+fcfids 00000000203f0b3d => (raw sp) 4e00fc2d)
+fcfids 00000000005a203d => (raw sp) 4ab4407a)
+fcfids 8020000000000b01 => (raw sp) deffc000)
+fcfids 80000000203f0b3d => (raw sp) df000000)
+
+fcfidus 0010000000000001 => (raw sp) 59800000)
+fcfidus 00100094e0000359 => (raw sp) 598004a7)
+fcfidus 3fe0000000000001 => (raw sp) 5e7f8000)
+fcfidus 3fe00094e0000359 => (raw sp) 5e7f8002)
+fcfidus 8010000000000001 => (raw sp) 5f001000)
+fcfidus 80100094e0000359 => (raw sp) 5f001001)
+fcfidus bfe0000000000001 => (raw sp) 5f3fe000)
+fcfidus bfe00094e0000359 => (raw sp) 5f3fe001)
+fcfidus 0020000000000b01 => (raw sp) 5a000000)
+fcfidus 00000000203f0b3d => (raw sp) 4e00fc2d)
+fcfidus 00000000005a203d => (raw sp) 4ab4407a)
+fcfidus 8020000000000b01 => (raw sp) 5f002000)
+fcfidus 80000000203f0b3d => (raw sp) 5f000000)
+
+fcfidu 0010000000000001 => (raw sp) 4330000000000001)
+fcfidu 00100094e0000359 => (raw sp) 43300094e0000359)
+fcfidu 3fe0000000000001 => (raw sp) 43cff00000000000)
+fcfidu 3fe00094e0000359 => (raw sp) 43cff0004a700002)
+fcfidu 8010000000000001 => (raw sp) 43e0020000000000)
+fcfidu 80100094e0000359 => (raw sp) 43e00200129c0000)
+fcfidu bfe0000000000001 => (raw sp) 43e7fc0000000000)
+fcfidu bfe00094e0000359 => (raw sp) 43e7fc00129c0000)
+fcfidu 0020000000000b01 => (raw sp) 4340000000000580)
+fcfidu 00000000203f0b3d => (raw sp) 41c01f859e800000)
+fcfidu 00000000005a203d => (raw sp) 4156880f40000000)
+fcfidu 8020000000000b01 => (raw sp) 43e0040000000001)
+fcfidu 80000000203f0b3d => (raw sp) 43e00000000407e1)
+
+Test ftdiv instruction
+ftdiv: 3fd8000000000000 <=> 404f000000000000 ? 8 (CRx)
+ftdiv: 7ff7ffffffffffff <=> 404f000000000000 ? a (CRx)
+ftdiv: 404f000000000000 <=> fff8000000000000 ? a (CRx)
+ftdiv: 3fd8000000000000 <=> 0018000000b77501 ? a (CRx)
+ftdiv: 404f000000000000 <=> 7fe800000000051b ? a (CRx)
+ftdiv: 7fe800000000051b <=> 3fd8000000000000 ? a (CRx)
+ftdiv: 3fd8000000000000 <=> 7fe800000000051b ? a (CRx)
+ftdiv: 0123214569900000 <=> 3fd8000000000000 ? a (CRx)
+ftdiv: 7ff0000000000000 <=> 404f000000000000 ? e (CRx)
+ftdiv: fff0000000000000 <=> 404f000000000000 ? e (CRx)
+ftdiv: 404f000000000000 <=> 7ff0000000000000 ? e (CRx)
+ftdiv: 3fd8000000000000 <=> 8008340000078000 ? e (CRx)
+ftdiv: 0000000000000000 <=> 0000000000000000 ? e (CRx)
+ftdiv: 0000000000000000 <=> 8000000000000000 ? e (CRx)
+
+Test VSX move instructions
+xsabsdp: 01234567 89abcdef xsabsdp 8899aabb 91929394x => 0899aabb 91929394
+
+xscpsgndp: 8899aabb 91929394 xscpsgndp 01234567 89abcdefx => 81234567 89abcdef
+
+xsnabsdp: b1b2b3b4 c1c2c3c4 xsnabsdp 44556677 8899aabbx => c4556677 8899aabb
+
+xsnegdp: 01234567 89abcdef xsnegdp b1b2b3b4 c1c2c3c4x => 31b2b3b4 c1c2c3c4
+
+Test VSX permute instructions
+xxmrghw:
+        XA[11111111,22222222,33333333,44444444]
+        XB[55555555,66666666,77777777,88888888]
+   =>   XT[11111111,55555555,22222222,66666666]
+xxmrghw:
+        XA[00112233,44556677,8899aabb,ccddeeff]
+        XB[11111111,22222222,33333333,44444444]
+   =>   XT[00112233,11111111,44556677,22222222]
+xxmrglw:
+        XA[11111111,22222222,33333333,44444444]
+        XB[55555555,66666666,77777777,88888888]
+   =>   XT[33333333,77777777,44444444,88888888]
+xxmrglw:
+        XA[00112233,44556677,8899aabb,ccddeeff]
+        XB[11111111,22222222,33333333,44444444]
+   =>   XT[8899aabb,33333333,ccddeeff,44444444]
+xxpermdi DM=00:
+        XA[11111111,22222222,33333333,44444444]
+        XB[55555555,66666666,77777777,88888888]
+   =>   XT[11111111,22222222,55555555,66666666]
+xxpermdi DM=01:
+        XA[11111111,22222222,33333333,44444444]
+        XB[55555555,66666666,77777777,88888888]
+   =>   XT[11111111,22222222,77777777,88888888]
+xxpermdi DM=10:
+        XA[11111111,22222222,33333333,44444444]
+        XB[55555555,66666666,77777777,88888888]
+   =>   XT[33333333,44444444,55555555,66666666]
+xxpermdi DM=11:
+        XA[11111111,22222222,33333333,44444444]
+        XB[55555555,66666666,77777777,88888888]
+   =>   XT[33333333,44444444,77777777,88888888]
+xxsldwi SHW=0:
+        XA[11111111,22222222,33333333,44444444]
+        XB[55555555,66666666,77777777,88888888]
+   =>   XT[11111111,22222222,33333333,44444444]
+xxsldwi SHW=1:
+        XA[11111111,22222222,33333333,44444444]
+        XB[55555555,66666666,77777777,88888888]
+   =>   XT[22222222,33333333,44444444,55555555]
+xxsldwi SHW=2:
+        XA[11111111,22222222,33333333,44444444]
+        XB[55555555,66666666,77777777,88888888]
+   =>   XT[33333333,44444444,55555555,66666666]
+xxsldwi SHW=3:
+        XA[11111111,22222222,33333333,44444444]
+        XB[55555555,66666666,77777777,88888888]
+   =>   XT[44444444,55555555,66666666,77777777]
+
+Test VSX floating point instructions
+#0: xscmpudp fff0000000000000 <=> fff0000000000000 ? 2 (CRx)
+#1: xscmpudp fff0000000000000 <=> c0d0650f5a07b353 ? 8 (CRx)
+#2: xscmpudp fff0000000000000 <=> 8000000000000000 ? 8 (CRx)
+#3: xscmpudp fff0000000000000 <=> 0000000000000000 ? 8 (CRx)
+#4: xscmpudp fff0000000000000 <=> 0123214569900000 ? 8 (CRx)
+#5: xscmpudp fff0000000000000 <=> 7ff0000000000000 ? 8 (CRx)
+#6: xscmpudp fff0000000000000 <=> 7ff7ffffffffffff ? 1 (CRx)
+#7: xscmpudp fff0000000000000 <=> 7ff8000000000000 ? 1 (CRx)
+#8: xscmpudp c0d0650f5a07b353 <=> fff0000000000000 ? 4 (CRx)
+#9: xscmpudp c0d0650f5a07b353 <=> c0d0650f5a07b353 ? 2 (CRx)
+#10: xscmpudp c0d0650f5a07b353 <=> 8000000000000000 ? 8 (CRx)
+#11: xscmpudp c0d0650f5a07b353 <=> 0000000000000000 ? 8 (CRx)
+#12: xscmpudp c0d0650f5a07b353 <=> 0123214569900000 ? 8 (CRx)
+#13: xscmpudp c0d0650f5a07b353 <=> 7ff0000000000000 ? 8 (CRx)
+#14: xscmpudp c0d0650f5a07b353 <=> 7ff7ffffffffffff ? 1 (CRx)
+#15: xscmpudp c0d0650f5a07b353 <=> 7ff8000000000000 ? 1 (CRx)
+#16: xscmpudp 8000000000000000 <=> fff0000000000000 ? 4 (CRx)
+#17: xscmpudp 8000000000000000 <=> c0d0650f5a07b353 ? 4 (CRx)
+#18: xscmpudp 8000000000000000 <=> 8000000000000000 ? 2 (CRx)
+#19: xscmpudp 8000000000000000 <=> 0000000000000000 ? 2 (CRx)
+#20: xscmpudp 8000000000000000 <=> 0123214569900000 ? 8 (CRx)
+#21: xscmpudp 8000000000000000 <=> 7ff0000000000000 ? 8 (CRx)
+#22: xscmpudp 8000000000000000 <=> 7ff7ffffffffffff ? 1 (CRx)
+#23: xscmpudp 8000000000000000 <=> 7ff8000000000000 ? 1 (CRx)
+#24: xscmpudp 0000000000000000 <=> fff0000000000000 ? 4 (CRx)
+#25: xscmpudp 0000000000000000 <=> c0d0650f5a07b353 ? 4 (CRx)
+#26: xscmpudp 0000000000000000 <=> 8000000000000000 ? 2 (CRx)
+#27: xscmpudp 0000000000000000 <=> 0000000000000000 ? 2 (CRx)
+#28: xscmpudp 0000000000000000 <=> 0123214569900000 ? 8 (CRx)
+#29: xscmpudp 0000000000000000 <=> 7ff0000000000000 ? 8 (CRx)
+#30: xscmpudp 0000000000000000 <=> 7ff7ffffffffffff ? 1 (CRx)
+#31: xscmpudp 0000000000000000 <=> 7ff8000000000000 ? 1 (CRx)
+#32: xscmpudp 0123214569900000 <=> fff0000000000000 ? 4 (CRx)
+#33: xscmpudp 0123214569900000 <=> c0d0650f5a07b353 ? 4 (CRx)
+#34: xscmpudp 0123214569900000 <=> 8000000000000000 ? 4 (CRx)
+#35: xscmpudp 0123214569900000 <=> 0000000000000000 ? 4 (CRx)
+#36: xscmpudp 0123214569900000 <=> 404f000000000000 ? 8 (CRx)
+#37: xscmpudp 0123214569900000 <=> 7ff0000000000000 ? 8 (CRx)
+#38: xscmpudp 0123214569900000 <=> 7ff7ffffffffffff ? 1 (CRx)
+#39: xscmpudp 0123214569900000 <=> 7ff8000000000000 ? 1 (CRx)
+#40: xscmpudp 7ff0000000000000 <=> fff0000000000000 ? 4 (CRx)
+#41: xscmpudp 7ff0000000000000 <=> c0d0650f5a07b353 ? 4 (CRx)
+#42: xscmpudp 7ff0000000000000 <=> 8000000000000000 ? 4 (CRx)
+#43: xscmpudp 7ff0000000000000 <=> 0000000000000000 ? 4 (CRx)
+#44: xscmpudp 7ff0000000000000 <=> 0123214569900000 ? 4 (CRx)
+#45: xscmpudp 7ff0000000000000 <=> 7ff0000000000000 ? 2 (CRx)
+#46: xscmpudp 7ff0000000000000 <=> 7ff7ffffffffffff ? 1 (CRx)
+#47: xscmpudp 7ff0000000000000 <=> 7ff8000000000000 ? 1 (CRx)
+#48: xscmpudp fff7ffffffffffff <=> fff0000000000000 ? 1 (CRx)
+#49: xscmpudp fff7ffffffffffff <=> c0d0650f5a07b353 ? 1 (CRx)
+#50: xscmpudp fff7ffffffffffff <=> 8000000000000000 ? 1 (CRx)
+#51: xscmpudp fff7ffffffffffff <=> 0000000000000000 ? 1 (CRx)
+#52: xscmpudp fff7ffffffffffff <=> 0123214569900000 ? 1 (CRx)
+#53: xscmpudp fff7ffffffffffff <=> 7ff0000000000000 ? 1 (CRx)
+#54: xscmpudp fff7ffffffffffff <=> 7ff7ffffffffffff ? 1 (CRx)
+#55: xscmpudp fff7ffffffffffff <=> 7ff8000000000000 ? 1 (CRx)
+#56: xscmpudp fff8000000000000 <=> fff0000000000000 ? 1 (CRx)
+#57: xscmpudp fff8000000000000 <=> c0d0650f5a07b353 ? 1 (CRx)
+#58: xscmpudp fff8000000000000 <=> 8000000000000000 ? 1 (CRx)
+#59: xscmpudp fff8000000000000 <=> 0000000000000000 ? 1 (CRx)
+#60: xscmpudp fff8000000000000 <=> 0123214569900000 ? 1 (CRx)
+#61: xscmpudp fff8000000000000 <=> 7ff0000000000000 ? 1 (CRx)
+#62: xscmpudp fff8000000000000 <=> 7ff7ffffffffffff ? 1 (CRx)
+#63: xscmpudp fff8000000000000 <=> 7ff8000000000000 ? 1 (CRx)
+
+#0: xscmpodp fff0000000000000 <=> fff0000000000000 ? 2 (CRx)
+#1: xscmpodp fff0000000000000 <=> c0d0650f5a07b353 ? 8 (CRx)
+#2: xscmpodp fff0000000000000 <=> 8000000000000000 ? 8 (CRx)
+#3: xscmpodp fff0000000000000 <=> 0000000000000000 ? 8 (CRx)
+#4: xscmpodp fff0000000000000 <=> 0123214569900000 ? 8 (CRx)
+#5: xscmpodp fff0000000000000 <=> 7ff0000000000000 ? 8 (CRx)
+#6: xscmpodp fff0000000000000 <=> 7ff7ffffffffffff ? 1 (CRx)
+#7: xscmpodp fff0000000000000 <=> 7ff8000000000000 ? 1 (CRx)
+#8: xscmpodp c0d0650f5a07b353 <=> fff0000000000000 ? 4 (CRx)
+#9: xscmpodp c0d0650f5a07b353 <=> c0d0650f5a07b353 ? 2 (CRx)
+#10: xscmpodp c0d0650f5a07b353 <=> 8000000000000000 ? 8 (CRx)
+#11: xscmpodp c0d0650f5a07b353 <=> 0000000000000000 ? 8 (CRx)
+#12: xscmpodp c0d0650f5a07b353 <=> 0123214569900000 ? 8 (CRx)
+#13: xscmpodp c0d0650f5a07b353 <=> 7ff0000000000000 ? 8 (CRx)
+#14: xscmpodp c0d0650f5a07b353 <=> 7ff7ffffffffffff ? 1 (CRx)
+#15: xscmpodp c0d0650f5a07b353 <=> 7ff8000000000000 ? 1 (CRx)
+#16: xscmpodp 8000000000000000 <=> fff0000000000000 ? 4 (CRx)
+#17: xscmpodp 8000000000000000 <=> c0d0650f5a07b353 ? 4 (CRx)
+#18: xscmpodp 8000000000000000 <=> 8000000000000000 ? 2 (CRx)
+#19: xscmpodp 8000000000000000 <=> 0000000000000000 ? 2 (CRx)
+#20: xscmpodp 8000000000000000 <=> 0123214569900000 ? 8 (CRx)
+#21: xscmpodp 8000000000000000 <=> 7ff0000000000000 ? 8 (CRx)
+#22: xscmpodp 8000000000000000 <=> 7ff7ffffffffffff ? 1 (CRx)
+#23: xscmpodp 8000000000000000 <=> 7ff8000000000000 ? 1 (CRx)
+#24: xscmpodp 0000000000000000 <=> fff0000000000000 ? 4 (CRx)
+#25: xscmpodp 0000000000000000 <=> c0d0650f5a07b353 ? 4 (CRx)
+#26: xscmpodp 0000000000000000 <=> 8000000000000000 ? 2 (CRx)
+#27: xscmpodp 0000000000000000 <=> 0000000000000000 ? 2 (CRx)
+#28: xscmpodp 0000000000000000 <=> 0123214569900000 ? 8 (CRx)
+#29: xscmpodp 0000000000000000 <=> 7ff0000000000000 ? 8 (CRx)
+#30: xscmpodp 0000000000000000 <=> 7ff7ffffffffffff ? 1 (CRx)
+#31: xscmpodp 0000000000000000 <=> 7ff8000000000000 ? 1 (CRx)
+#32: xscmpodp 0123214569900000 <=> fff0000000000000 ? 4 (CRx)
+#33: xscmpodp 0123214569900000 <=> c0d0650f5a07b353 ? 4 (CRx)
+#34: xscmpodp 0123214569900000 <=> 8000000000000000 ? 4 (CRx)
+#35: xscmpodp 0123214569900000 <=> 0000000000000000 ? 4 (CRx)
+#36: xscmpodp 0123214569900000 <=> 404f000000000000 ? 8 (CRx)
+#37: xscmpodp 0123214569900000 <=> 7ff0000000000000 ? 8 (CRx)
+#38: xscmpodp 0123214569900000 <=> 7ff7ffffffffffff ? 1 (CRx)
+#39: xscmpodp 0123214569900000 <=> 7ff8000000000000 ? 1 (CRx)
+#40: xscmpodp 7ff0000000000000 <=> fff0000000000000 ? 4 (CRx)
+#41: xscmpodp 7ff0000000000000 <=> c0d0650f5a07b353 ? 4 (CRx)
+#42: xscmpodp 7ff0000000000000 <=> 8000000000000000 ? 4 (CRx)
+#43: xscmpodp 7ff0000000000000 <=> 0000000000000000 ? 4 (CRx)
+#44: xscmpodp 7ff0000000000000 <=> 0123214569900000 ? 4 (CRx)
+#45: xscmpodp 7ff0000000000000 <=> 7ff0000000000000 ? 2 (CRx)
+#46: xscmpodp 7ff0000000000000 <=> 7ff7ffffffffffff ? 1 (CRx)
+#47: xscmpodp 7ff0000000000000 <=> 7ff8000000000000 ? 1 (CRx)
+#48: xscmpodp fff7ffffffffffff <=> fff0000000000000 ? 1 (CRx)
+#49: xscmpodp fff7ffffffffffff <=> c0d0650f5a07b353 ? 1 (CRx)
+#50: xscmpodp fff7ffffffffffff <=> 8000000000000000 ? 1 (CRx)
+#51: xscmpodp fff7ffffffffffff <=> 0000000000000000 ? 1 (CRx)
+#52: xscmpodp fff7ffffffffffff <=> 0123214569900000 ? 1 (CRx)
+#53: xscmpodp fff7ffffffffffff <=> 7ff0000000000000 ? 1 (CRx)
+#54: xscmpodp fff7ffffffffffff <=> 7ff7ffffffffffff ? 1 (CRx)
+#55: xscmpodp fff7ffffffffffff <=> 7ff8000000000000 ? 1 (CRx)
+#56: xscmpodp fff8000000000000 <=> fff0000000000000 ? 1 (CRx)
+#57: xscmpodp fff8000000000000 <=> c0d0650f5a07b353 ? 1 (CRx)
+#58: xscmpodp fff8000000000000 <=> 8000000000000000 ? 1 (CRx)
+#59: xscmpodp fff8000000000000 <=> 0000000000000000 ? 1 (CRx)
+#60: xscmpodp fff8000000000000 <=> 0123214569900000 ? 1 (CRx)
+#61: xscmpodp fff8000000000000 <=> 7ff0000000000000 ? 1 (CRx)
+#62: xscmpodp fff8000000000000 <=> 7ff7ffffffffffff ? 1 (CRx)
+#63: xscmpodp fff8000000000000 <=> 7ff8000000000000 ? 1 (CRx)
+
+#0: xsadddp fff0000000000000 fff0000000000000 = fff0000000000000
+#1: xsadddp fff0000000000000 c0d0650f5a07b353 = fff0000000000000
+#2: xsadddp fff0000000000000 8000000000000000 = fff0000000000000
+#3: xsadddp fff0000000000000 0000000000000000 = fff0000000000000
+#4: xsadddp fff0000000000000 0123214569900000 = fff0000000000000
+#5: xsadddp fff0000000000000 7ff0000000000000 = 7ff8000000000000
+#6: xsadddp fff0000000000000 7ff7ffffffffffff = 7fffffffffffffff
+#7: xsadddp fff0000000000000 7ff8000000000000 = 7ff8000000000000
+#8: xsadddp c0d0650f5a07b353 fff0000000000000 = fff0000000000000
+#9: xsadddp c0d0650f5a07b353 c0d0650f5a07b353 = c0e0650f5a07b353
+#10: xsadddp c0d0650f5a07b353 8000000000000000 = c0d0650f5a07b353
+#11: xsadddp c0d0650f5a07b353 0000000000000000 = c0d0650f5a07b353
+#12: xsadddp c0d0650f5a07b353 0123214569900000 = c0d0650f5a07b353
+#13: xsadddp c0d0650f5a07b353 7ff0000000000000 = 7ff0000000000000
+#14: xsadddp c0d0650f5a07b353 7ff7ffffffffffff = 7fffffffffffffff
+#15: xsadddp c0d0650f5a07b353 7ff8000000000000 = 7ff8000000000000
+#16: xsadddp 8000000000000000 fff0000000000000 = fff0000000000000
+#17: xsadddp 8000000000000000 c0d0650f5a07b353 = c0d0650f5a07b353
+#18: xsadddp 8000000000000000 8000000000000000 = 8000000000000000
+#19: xsadddp 8000000000000000 0000000000000000 = 0000000000000000
+#20: xsadddp 8000000000000000 0123214569900000 = 0123214569900000
+#21: xsadddp 8000000000000000 7ff0000000000000 = 7ff0000000000000
+#22: xsadddp 8000000000000000 7ff7ffffffffffff = 7fffffffffffffff
+#23: xsadddp 8000000000000000 7ff8000000000000 = 7ff8000000000000
+#24: xsadddp 0000000000000000 fff0000000000000 = fff0000000000000
+#25: xsadddp 0000000000000000 c0d0650f5a07b353 = c0d0650f5a07b353
+#26: xsadddp 0000000000000000 8000000000000000 = 0000000000000000
+#27: xsadddp 0000000000000000 0000000000000000 = 0000000000000000
+#28: xsadddp 0000000000000000 0123214569900000 = 0123214569900000
+#29: xsadddp 0000000000000000 7ff0000000000000 = 7ff0000000000000
+#30: xsadddp 0000000000000000 7ff7ffffffffffff = 7fffffffffffffff
+#31: xsadddp 0000000000000000 7ff8000000000000 = 7ff8000000000000
+#32: xsadddp 0123214569900000 fff0000000000000 = fff0000000000000
+#33: xsadddp 0123214569900000 c0d0650f5a07b353 = c0d0650f5a07b353
+#34: xsadddp 0123214569900000 8000000000000000 = 0123214569900000
+#35: xsadddp 0123214569900000 0000000000000000 = 0123214569900000
+#36: xsadddp 0123214569900000 404f000000000000 = 404f000000000000
+#37: xsadddp 0123214569900000 7ff0000000000000 = 7ff0000000000000
+#38: xsadddp 0123214569900000 7ff7ffffffffffff = 7fffffffffffffff
+#39: xsadddp 0123214569900000 7ff8000000000000 = 7ff8000000000000
+#40: xsadddp 7ff0000000000000 fff0000000000000 = 7ff8000000000000
+#41: xsadddp 7ff0000000000000 c0d0650f5a07b353 = 7ff0000000000000
+#42: xsadddp 7ff0000000000000 8000000000000000 = 7ff0000000000000
+#43: xsadddp 7ff0000000000000 0000000000000000 = 7ff0000000000000
+#44: xsadddp 7ff0000000000000 0123214569900000 = 7ff0000000000000
+#45: xsadddp 7ff0000000000000 7ff0000000000000 = 7ff0000000000000
+#46: xsadddp 7ff0000000000000 7ff7ffffffffffff = 7fffffffffffffff
+#47: xsadddp 7ff0000000000000 7ff8000000000000 = 7ff8000000000000
+#48: xsadddp fff7ffffffffffff fff0000000000000 = ffffffffffffffff
+#49: xsadddp fff7ffffffffffff c0d0650f5a07b353 = ffffffffffffffff
+#50: xsadddp fff7ffffffffffff 8000000000000000 = ffffffffffffffff
+#51: xsadddp fff7ffffffffffff 0000000000000000 = ffffffffffffffff
+#52: xsadddp fff7ffffffffffff 0123214569900000 = ffffffffffffffff
+#53: xsadddp fff7ffffffffffff 7ff0000000000000 = ffffffffffffffff
+#54: xsadddp fff7ffffffffffff 7ff7ffffffffffff = ffffffffffffffff
+#55: xsadddp fff7ffffffffffff 7ff8000000000000 = ffffffffffffffff
+#56: xsadddp fff8000000000000 fff0000000000000 = fff8000000000000
+#57: xsadddp fff8000000000000 c0d0650f5a07b353 = fff8000000000000
+#58: xsadddp fff8000000000000 8000000000000000 = fff8000000000000
+#59: xsadddp fff8000000000000 0000000000000000 = fff8000000000000
+#60: xsadddp fff8000000000000 0123214569900000 = fff8000000000000
+#61: xsadddp fff8000000000000 7ff0000000000000 = fff8000000000000
+#62: xsadddp fff8000000000000 7ff7ffffffffffff = fff8000000000000
+#63: xsadddp fff8000000000000 7ff8000000000000 = fff8000000000000
+
+#0: xsdivdp fff0000000000000 fff0000000000000 = 7ff8000000000000
+#1: xsdivdp fff0000000000000 c0d0650f5a07b353 = 7ff0000000000000
+#2: xsdivdp fff0000000000000 8000000000000000 = 7ff0000000000000
+#3: xsdivdp fff0000000000000 0000000000000000 = fff0000000000000
+#4: xsdivdp fff0000000000000 0123214569900000 = fff0000000000000
+#5: xsdivdp fff0000000000000 7ff0000000000000 = 7ff8000000000000
+#6: xsdivdp fff0000000000000 7ff7ffffffffffff = 7fffffffffffffff
+#7: xsdivdp fff0000000000000 7ff8000000000000 = 7ff8000000000000
+#8: xsdivdp c0d0650f5a07b353 fff0000000000000 = 0000000000000000
+#9: xsdivdp c0d0650f5a07b353 c0d0650f5a07b353 = 3ff0000000000000
+#10: xsdivdp c0d0650f5a07b353 8000000000000000 = 7ff0000000000000
+#11: xsdivdp c0d0650f5a07b353 0000000000000000 = fff0000000000000
+#12: xsdivdp c0d0650f5a07b353 0123214569900000 = ff9b6cb57ca13c00
+#13: xsdivdp c0d0650f5a07b353 7ff0000000000000 = 8000000000000000
+#14: xsdivdp c0d0650f5a07b353 7ff7ffffffffffff = 7fffffffffffffff
+#15: xsdivdp c0d0650f5a07b353 7ff8000000000000 = 7ff8000000000000
+#16: xsdivdp 8000000000000000 fff0000000000000 = 0000000000000000
+#17: xsdivdp 8000000000000000 c0d0650f5a07b353 = 0000000000000000
+#18: xsdivdp 8000000000000000 8000000000000000 = 7ff8000000000000
+#19: xsdivdp 8000000000000000 0000000000000000 = 7ff8000000000000
+#20: xsdivdp 8000000000000000 0123214569900000 = 8000000000000000
+#21: xsdivdp 8000000000000000 7ff0000000000000 = 8000000000000000
+#22: xsdivdp 8000000000000000 7ff7ffffffffffff = 7fffffffffffffff
+#23: xsdivdp 8000000000000000 7ff8000000000000 = 7ff8000000000000
+#24: xsdivdp 0000000000000000 fff0000000000000 = 8000000000000000
+#25: xsdivdp 0000000000000000 c0d0650f5a07b353 = 8000000000000000
+#26: xsdivdp 0000000000000000 8000000000000000 = 7ff8000000000000
+#27: xsdivdp 0000000000000000 0000000000000000 = 7ff8000000000000
+#28: xsdivdp 0000000000000000 0123214569900000 = 0000000000000000
+#29: xsdivdp 0000000000000000 7ff0000000000000 = 0000000000000000
+#30: xsdivdp 0000000000000000 7ff7ffffffffffff = 7fffffffffffffff
+#31: xsdivdp 0000000000000000 7ff8000000000000 = 7ff8000000000000
+#32: xsdivdp 0123214569900000 fff0000000000000 = 8000000000000000
+#33: xsdivdp 0123214569900000 c0d0650f5a07b353 = 8042ab59d8b6ec87
+#34: xsdivdp 0123214569900000 8000000000000000 = fff0000000000000
+#35: xsdivdp 0123214569900000 0000000000000000 = 7ff0000000000000
+#36: xsdivdp 0123214569900000 404f000000000000 = 00c3bf3f64b5ad6b
+#37: xsdivdp 0123214569900000 7ff0000000000000 = 0000000000000000
+#38: xsdivdp 0123214569900000 7ff7ffffffffffff = 7fffffffffffffff
+#39: xsdivdp 0123214569900000 7ff8000000000000 = 7ff8000000000000
+#40: xsdivdp 7ff0000000000000 fff0000000000000 = 7ff8000000000000
+#41: xsdivdp 7ff0000000000000 c0d0650f5a07b353 = fff0000000000000
+#42: xsdivdp 7ff0000000000000 8000000000000000 = fff0000000000000
+#43: xsdivdp 7ff0000000000000 0000000000000000 = 7ff0000000000000
+#44: xsdivdp 7ff0000000000000 0123214569900000 = 7ff0000000000000
+#45: xsdivdp 7ff0000000000000 7ff0000000000000 = 7ff8000000000000
+#46: xsdivdp 7ff0000000000000 7ff7ffffffffffff = 7fffffffffffffff
+#47: xsdivdp 7ff0000000000000 7ff8000000000000 = 7ff8000000000000
+#48: xsdivdp fff7ffffffffffff fff0000000000000 = ffffffffffffffff
+#49: xsdivdp fff7ffffffffffff c0d0650f5a07b353 = ffffffffffffffff
+#50: xsdivdp fff7ffffffffffff 8000000000000000 = ffffffffffffffff
+#51: xsdivdp fff7ffffffffffff 0000000000000000 = ffffffffffffffff
+#52: xsdivdp fff7ffffffffffff 0123214569900000 = ffffffffffffffff
+#53: xsdivdp fff7ffffffffffff 7ff0000000000000 = ffffffffffffffff
+#54: xsdivdp fff7ffffffffffff 7ff7ffffffffffff = ffffffffffffffff
+#55: xsdivdp fff7ffffffffffff 7ff8000000000000 = ffffffffffffffff
+#56: xsdivdp fff8000000000000 fff0000000000000 = fff8000000000000
+#57: xsdivdp fff8000000000000 c0d0650f5a07b353 = fff8000000000000
+#58: xsdivdp fff8000000000000 8000000000000000 = fff8000000000000
+#59: xsdivdp fff8000000000000 0000000000000000 = fff8000000000000
+#60: xsdivdp fff8000000000000 0123214569900000 = fff8000000000000
+#61: xsdivdp fff8000000000000 7ff0000000000000 = fff8000000000000
+#62: xsdivdp fff8000000000000 7ff7ffffffffffff = fff8000000000000
+#63: xsdivdp fff8000000000000 7ff8000000000000 = fff8000000000000
+
+#0: xsmaddadp fff0000000000000 fff0000000000000 c0d0650f5a07b353 = 7ff8000000000000
+#1: xsmaddadp c0d0650f5a07b353 fff0000000000000 0123214569900000 = fff0000000000000
+#2: xsmaddadp 8000000000000000 fff0000000000000 c0d0650f5a07b353 = 7ff0000000000000
+#3: xsmaddadp 0000000000000000 fff0000000000000 0123214569900000 = fff0000000000000
+#4: xsmaddadp 0123214569900000 fff0000000000000 c0d0650f5a07b353 = 7ff0000000000000
+#5: xsmaddadp 7ff0000000000000 fff0000000000000 0123214569900000 = 7ff8000000000000
+#6: xsmaddadp 7ff7ffffffffffff fff0000000000000 c0d0650f5a07b353 = 7fffffffffffffff
+#7: xsmaddadp 7ff8000000000000 fff0000000000000 0123214569900000 = 7ff8000000000000
+#8: xsmaddadp fff0000000000000 c0d0650f5a07b353 c0d0650f5a07b353 = fff0000000000000
+#9: xsmaddadp c0d0650f5a07b353 c0d0650f5a07b353 0123214569900000 = c0d0650f5a07b353
+#10: xsmaddadp 8000000000000000 c0d0650f5a07b353 c0d0650f5a07b353 = 41b0cc9d05eec2a7
+#11: xsmaddadp 0000000000000000 c0d0650f5a07b353 0123214569900000 = 82039a19ca8fcb5f
+#12: xsmaddadp 0123214569900000 c0d0650f5a07b353 c0d0650f5a07b353 = 41b0cc9d05eec2a7
+#13: xsmaddadp 7ff0000000000000 c0d0650f5a07b353 0123214569900000 = 7ff0000000000000
+#14: xsmaddadp 7ff7ffffffffffff c0d0650f5a07b353 c0d0650f5a07b353 = 7fffffffffffffff
+#15: xsmaddadp 7ff8000000000000 c0d0650f5a07b353 0123214569900000 = 7ff8000000000000
+#16: xsmaddadp fff0000000000000 8000000000000000 c0d0650f5a07b353 = fff0000000000000
+#17: xsmaddadp c0d0650f5a07b353 8000000000000000 0123214569900000 = c0d0650f5a07b353
+#18: xsmaddadp 8000000000000000 8000000000000000 c0d0650f5a07b353 = 0000000000000000
+#19: xsmaddadp 0000000000000000 8000000000000000 0123214569900000 = 0000000000000000
+#20: xsmaddadp 0123214569900000 8000000000000000 c0d0650f5a07b353 = 0123214569900000
+#21: xsmaddadp 7ff0000000000000 8000000000000000 0123214569900000 = 7ff0000000000000
+#22: xsmaddadp 7ff7ffffffffffff 8000000000000000 c0d0650f5a07b353 = 7fffffffffffffff
+#23: xsmaddadp 7ff8000000000000 8000000000000000 0123214569900000 = 7ff8000000000000
+#24: xsmaddadp fff0000000000000 0000000000000000 c0d0650f5a07b353 = fff0000000000000
+#25: xsmaddadp c0d0650f5a07b353 0000000000000000 0123214569900000 = c0d0650f5a07b353
+#26: xsmaddadp 8000000000000000 0000000000000000 c0d0650f5a07b353 = 8000000000000000
+#27: xsmaddadp 0000000000000000 0000000000000000 0123214569900000 = 0000000000000000
+#28: xsmaddadp 0123214569900000 0000000000000000 c0d0650f5a07b353 = 0123214569900000
+#29: xsmaddadp 7ff0000000000000 0000000000000000 0123214569900000 = 7ff0000000000000
+#30: xsmaddadp 7ff7ffffffffffff 0000000000000000 c0d0650f5a07b353 = 7fffffffffffffff
+#31: xsmaddadp 7ff8000000000000 0000000000000000 0123214569900000 = 7ff8000000000000
+#32: xsmaddadp fff0000000000000 0123214569900000 c0d0650f5a07b353 = fff0000000000000
+#33: xsmaddadp c0d0650f5a07b353 0123214569900000 0123214569900000 = c0d0650f5a07b353
+#34: xsmaddadp 8000000000000000 0123214569900000 c0d0650f5a07b353 = 82039a19ca8fcb5f
+#35: xsmaddadp 0000000000000000 0123214569900000 0123214569900000 = 0000000000000000
+#36: xsmaddadp 404f000000000000 0123214569900000 c0d0650f5a07b353 = 404f000000000000
+#37: xsmaddadp 7ff0000000000000 0123214569900000 0123214569900000 = 7ff0000000000000
+#38: xsmaddadp 7ff7ffffffffffff 0123214569900000 c0d0650f5a07b353 = 7fffffffffffffff
+#39: xsmaddadp 7ff8000000000000 0123214569900000 0123214569900000 = 7ff8000000000000
+#40: xsmaddadp fff0000000000000 7ff0000000000000 c0d0650f5a07b353 = fff0000000000000
+#41: xsmaddadp c0d0650f5a07b353 7ff0000000000000 0123214569900000 = 7ff0000000000000
+#42: xsmaddadp 8000000000000000 7ff0000000000000 c0d0650f5a07b353 = fff0000000000000
+#43: xsmaddadp 0000000000000000 7ff0000000000000 0123214569900000 = 7ff0000000000000
+#44: xsmaddadp 0123214569900000 7ff0000000000000 c0d0650f5a07b353 = fff0000000000000
+#45: xsmaddadp 7ff0000000000000 7ff0000000000000 0123214569900000 = 7ff0000000000000
+#46: xsmaddadp 7ff7ffffffffffff 7ff0000000000000 c0d0650f5a07b353 = 7fffffffffffffff
+#47: xsmaddadp 7ff8000000000000 7ff0000000000000 0123214569900000 = 7ff8000000000000
+#48: xsmaddadp fff0000000000000 fff7ffffffffffff c0d0650f5a07b353 = ffffffffffffffff
+#49: xsmaddadp c0d0650f5a07b353 fff7ffffffffffff 0123214569900000 = ffffffffffffffff
+#50: xsmaddadp 8000000000000000 fff7ffffffffffff c0d0650f5a07b353 = ffffffffffffffff
+#51: xsmaddadp 0000000000000000 fff7ffffffffffff 0123214569900000 = ffffffffffffffff
+#52: xsmaddadp 0123214569900000 fff7ffffffffffff c0d0650f5a07b353 = ffffffffffffffff
+#53: xsmaddadp 7ff0000000000000 fff7ffffffffffff 0123214569900000 = ffffffffffffffff
+#54: xsmaddadp 7ff7ffffffffffff fff7ffffffffffff c0d0650f5a07b353 = ffffffffffffffff
+#55: xsmaddadp 7ff8000000000000 fff7ffffffffffff 0123214569900000 = ffffffffffffffff
+#56: xsmaddadp fff0000000000000 fff8000000000000 c0d0650f5a07b353 = fff8000000000000
+#57: xsmaddadp c0d0650f5a07b353 fff8000000000000 0123214569900000 = fff8000000000000
+#58: xsmaddadp 8000000000000000 fff8000000000000 c0d0650f5a07b353 = fff8000000000000
+#59: xsmaddadp 0000000000000000 fff8000000000000 0123214569900000 = fff8000000000000
+#60: xsmaddadp 0123214569900000 fff8000000000000 c0d0650f5a07b353 = fff8000000000000
+#61: xsmaddadp 7ff0000000000000 fff8000000000000 0123214569900000 = fff8000000000000
+#62: xsmaddadp 7ff7ffffffffffff fff8000000000000 c0d0650f5a07b353 = fff8000000000000
+#63: xsmaddadp 7ff8000000000000 fff8000000000000 0123214569900000 = fff8000000000000
+
+#0: xsmaddmdp c0d0650f5a07b353 fff0000000000000 fff0000000000000 = 7ff8000000000000
+#1: xsmaddmdp 0123214569900000 fff0000000000000 c0d0650f5a07b353 = fff0000000000000
+#2: xsmaddmdp c0d0650f5a07b353 fff0000000000000 8000000000000000 = 7ff0000000000000
+#3: xsmaddmdp 0123214569900000 fff0000000000000 0000000000000000 = fff0000000000000
+#4: xsmaddmdp c0d0650f5a07b353 fff0000000000000 0123214569900000 = 7ff0000000000000
+#5: xsmaddmdp 0123214569900000 fff0000000000000 7ff0000000000000 = 7ff8000000000000
+#6: xsmaddmdp c0d0650f5a07b353 fff0000000000000 7ff7ffffffffffff = 7fffffffffffffff
+#7: xsmaddmdp 0123214569900000 fff0000000000000 7ff8000000000000 = 7ff8000000000000
+#8: xsmaddmdp c0d0650f5a07b353 c0d0650f5a07b353 fff0000000000000 = fff0000000000000
+#9: xsmaddmdp 0123214569900000 c0d0650f5a07b353 c0d0650f5a07b353 = c0d0650f5a07b353
+#10: xsmaddmdp c0d0650f5a07b353 c0d0650f5a07b353 8000000000000000 = 41b0cc9d05eec2a7
+#11: xsmaddmdp 0123214569900000 c0d0650f5a07b353 0000000000000000 = 82039a19ca8fcb5f
+#12: xsmaddmdp c0d0650f5a07b353 c0d0650f5a07b353 0123214569900000 = 41b0cc9d05eec2a7
+#13: xsmaddmdp 0123214569900000 c0d0650f5a07b353 7ff0000000000000 = 7ff0000000000000
+#14: xsmaddmdp c0d0650f5a07b353 c0d0650f5a07b353 7ff7ffffffffffff = 7fffffffffffffff
+#15: xsmaddmdp 0123214569900000 c0d0650f5a07b353 7ff8000000000000 = 7ff8000000000000
+#16: xsmaddmdp c0d0650f5a07b353 8000000000000000 fff0000000000000 = fff0000000000000
+#17: xsmaddmdp 0123214569900000 8000000000000000 c0d0650f5a07b353 = c0d0650f5a07b353
+#18: xsmaddmdp c0d0650f5a07b353 8000000000000000 8000000000000000 = 0000000000000000
+#19: xsmaddmdp 0123214569900000 8000000000000000 0000000000000000 = 0000000000000000
+#20: xsmaddmdp c0d0650f5a07b353 8000000000000000 0123214569900000 = 0123214569900000
+#21: xsmaddmdp 0123214569900000 8000000000000000 7ff0000000000000 = 7ff0000000000000
+#22: xsmaddmdp c0d0650f5a07b353 8000000000000000 7ff7ffffffffffff = 7fffffffffffffff
+#23: xsmaddmdp 0123214569900000 8000000000000000 7ff8000000000000 = 7ff8000000000000
+#24: xsmaddmdp c0d0650f5a07b353 0000000000000000 fff0000000000000 = fff0000000000000
+#25: xsmaddmdp 0123214569900000 0000000000000000 c0d0650f5a07b353 = c0d0650f5a07b353
+#26: xsmaddmdp c0d0650f5a07b353 0000000000000000 8000000000000000 = 8000000000000000
+#27: xsmaddmdp 0123214569900000 0000000000000000 0000000000000000 = 0000000000000000
+#28: xsmaddmdp c0d0650f5a07b353 0000000000000000 0123214569900000 = 0123214569900000
+#29: xsmaddmdp 0123214569900000 0000000000000000 7ff0000000000000 = 7ff0000000000000
+#30: xsmaddmdp c0d0650f5a07b353 0000000000000000 7ff7ffffffffffff = 7fffffffffffffff
+#31: xsmaddmdp 0123214569900000 0000000000000000 7ff8000000000000 = 7ff8000000000000
+#32: xsmaddmdp c0d0650f5a07b353 0123214569900000 fff0000000000000 = fff0000000000000
+#33: xsmaddmdp 0123214569900000 0123214569900000 c0d0650f5a07b353 = c0d0650f5a07b353
+#34: xsmaddmdp c0d0650f5a07b353 0123214569900000 8000000000000000 = 82039a19ca8fcb5f
+#35: xsmaddmdp 0123214569900000 0123214569900000 0000000000000000 = 0000000000000000
+#36: xsmaddmdp c0d0650f5a07b353 0123214569900000 404f000000000000 = 404f000000000000
+#37: xsmaddmdp 0123214569900000 0123214569900000 7ff0000000000000 = 7ff0000000000000
+#38: xsmaddmdp c0d0650f5a07b353 0123214569900000 7ff7ffffffffffff = 7fffffffffffffff
+#39: xsmaddmdp 0123214569900000 0123214569900000 7ff8000000000000 = 7ff8000000000000
+#40: xsmaddmdp c0d0650f5a07b353 7ff0000000000000 fff0000000000000 = fff0000000000000
+#41: xsmaddmdp 0123214569900000 7ff0000000000000 c0d0650f5a07b353 = 7ff0000000000000
+#42: xsmaddmdp c0d0650f5a07b353 7ff0000000000000 8000000000000000 = fff0000000000000
+#43: xsmaddmdp 0123214569900000 7ff0000000000000 0000000000000000 = 7ff0000000000000
+#44: xsmaddmdp c0d0650f5a07b353 7ff0000000000000 0123214569900000 = fff0000000000000
+#45: xsmaddmdp 0123214569900000 7ff0000000000000 7ff0000000000000 = 7ff0000000000000
+#46: xsmaddmdp c0d0650f5a07b353 7ff0000000000000 7ff7ffffffffffff = 7fffffffffffffff
+#47: xsmaddmdp 0123214569900000 7ff0000000000000 7ff8000000000000 = 7ff8000000000000
+#48: xsmaddmdp c0d0650f5a07b353 fff7ffffffffffff fff0000000000000 = ffffffffffffffff
+#49: xsmaddmdp 0123214569900000 fff7ffffffffffff c0d0650f5a07b353 = ffffffffffffffff
+#50: xsmaddmdp c0d0650f5a07b353 fff7ffffffffffff 8000000000000000 = ffffffffffffffff
+#51: xsmaddmdp 0123214569900000 fff7ffffffffffff 0000000000000000 = ffffffffffffffff
+#52: xsmaddmdp c0d0650f5a07b353 fff7ffffffffffff 0123214569900000 = ffffffffffffffff
+#53: xsmaddmdp 0123214569900000 fff7ffffffffffff 7ff0000000000000 = ffffffffffffffff
+#54: xsmaddmdp c0d0650f5a07b353 fff7ffffffffffff 7ff7ffffffffffff = ffffffffffffffff
+#55: xsmaddmdp 0123214569900000 fff7ffffffffffff 7ff8000000000000 = ffffffffffffffff
+#56: xsmaddmdp c0d0650f5a07b353 fff8000000000000 fff0000000000000 = fff8000000000000
+#57: xsmaddmdp 0123214569900000 fff8000000000000 c0d0650f5a07b353 = fff8000000000000
+#58: xsmaddmdp c0d0650f5a07b353 fff8000000000000 8000000000000000 = fff8000000000000
+#59: xsmaddmdp 0123214569900000 fff8000000000000 0000000000000000 = fff8000000000000
+#60: xsmaddmdp c0d0650f5a07b353 fff8000000000000 0123214569900000 = fff8000000000000
+#61: xsmaddmdp 0123214569900000 fff8000000000000 7ff0000000000000 = fff8000000000000
+#62: xsmaddmdp c0d0650f5a07b353 fff8000000000000 7ff7ffffffffffff = fff8000000000000
+#63: xsmaddmdp 0123214569900000 fff8000000000000 7ff8000000000000 = fff8000000000000
+
+#0: xsmsubadp fff0000000000000 fff0000000000000 c0d0650f5a07b353 = 7ff0000000000000
+#1: xsmsubadp c0d0650f5a07b353 fff0000000000000 0123214569900000 = fff0000000000000
+#2: xsmsubadp 8000000000000000 fff0000000000000 c0d0650f5a07b353 = 7ff0000000000000
+#3: xsmsubadp 0000000000000000 fff0000000000000 0123214569900000 = fff0000000000000
+#4: xsmsubadp 0123214569900000 fff0000000000000 c0d0650f5a07b353 = 7ff0000000000000
+#5: xsmsubadp 7ff0000000000000 fff0000000000000 0123214569900000 = fff0000000000000
+#6: xsmsubadp 7ff7ffffffffffff fff0000000000000 c0d0650f5a07b353 = 7fffffffffffffff
+#7: xsmsubadp 7ff8000000000000 fff0000000000000 0123214569900000 = 7ff8000000000000
+#8: xsmsubadp fff0000000000000 c0d0650f5a07b353 c0d0650f5a07b353 = 7ff0000000000000
+#9: xsmsubadp c0d0650f5a07b353 c0d0650f5a07b353 0123214569900000 = 40d0650f5a07b353
+#10: xsmsubadp 8000000000000000 c0d0650f5a07b353 c0d0650f5a07b353 = 41b0cc9d05eec2a7
+#11: xsmsubadp 0000000000000000 c0d0650f5a07b353 0123214569900000 = 82039a19ca8fcb5f
+#12: xsmsubadp 0123214569900000 c0d0650f5a07b353 c0d0650f5a07b353 = 41b0cc9d05eec2a7
+#13: xsmsubadp 7ff0000000000000 c0d0650f5a07b353 0123214569900000 = fff0000000000000
+#14: xsmsubadp 7ff7ffffffffffff c0d0650f5a07b353 c0d0650f5a07b353 = 7fffffffffffffff
+#15: xsmsubadp 7ff8000000000000 c0d0650f5a07b353 0123214569900000 = 7ff8000000000000
+#16: xsmsubadp fff0000000000000 8000000000000000 c0d0650f5a07b353 = 7ff0000000000000
+#17: xsmsubadp c0d0650f5a07b353 8000000000000000 0123214569900000 = 40d0650f5a07b353
+#18: xsmsubadp 8000000000000000 8000000000000000 c0d0650f5a07b353 = 0000000000000000
+#19: xsmsubadp 0000000000000000 8000000000000000 0123214569900000 = 8000000000000000
+#20: xsmsubadp 0123214569900000 8000000000000000 c0d0650f5a07b353 = 8123214569900000
+#21: xsmsubadp 7ff0000000000000 8000000000000000 0123214569900000 = fff0000000000000
+#22: xsmsubadp 7ff7ffffffffffff 8000000000000000 c0d0650f5a07b353 = 7fffffffffffffff
+#23: xsmsubadp 7ff8000000000000 8000000000000000 0123214569900000 = 7ff8000000000000
+#24: xsmsubadp fff0000000000000 0000000000000000 c0d0650f5a07b353 = 7ff0000000000000
+#25: xsmsubadp c0d0650f5a07b353 0000000000000000 0123214569900000 = 40d0650f5a07b353
+#26: xsmsubadp 8000000000000000 0000000000000000 c0d0650f5a07b353 = 0000000000000000
+#27: xsmsubadp 0000000000000000 0000000000000000 0123214569900000 = 0000000000000000
+#28: xsmsubadp 0123214569900000 0000000000000000 c0d0650f5a07b353 = 8123214569900000
+#29: xsmsubadp 7ff0000000000000 0000000000000000 0123214569900000 = fff0000000000000
+#30: xsmsubadp 7ff7ffffffffffff 0000000000000000 c0d0650f5a07b353 = 7fffffffffffffff
+#31: xsmsubadp 7ff8000000000000 0000000000000000 0123214569900000 = 7ff8000000000000
+#32: xsmsubadp fff0000000000000 0123214569900000 c0d0650f5a07b353 = 7ff0000000000000
+#33: xsmsubadp c0d0650f5a07b353 0123214569900000 0123214569900000 = 40d0650f5a07b353
+#34: xsmsubadp 8000000000000000 0123214569900000 c0d0650f5a07b353 = 82039a19ca8fcb5f
+#35: xsmsubadp 0000000000000000 0123214569900000 0123214569900000 = 0000000000000000
+#36: xsmsubadp 404f000000000000 0123214569900000 c0d0650f5a07b353 = c04f000000000000
+#37: xsmsubadp 7ff0000000000000 0123214569900000 0123214569900000 = fff0000000000000
+#38: xsmsubadp 7ff7ffffffffffff 0123214569900000 c0d0650f5a07b353 = 7fffffffffffffff
+#39: xsmsubadp 7ff8000000000000 0123214569900000 0123214569900000 = 7ff8000000000000
+#40: xsmsubadp fff0000000000000 7ff0000000000000 c0d0650f5a07b353 = 7ff8000000000000
+#41: xsmsubadp c0d0650f5a07b353 7ff0000000000000 0123214569900000 = 7ff0000000000000
+#42: xsmsubadp 8000000000000000 7ff0000000000000 c0d0650f5a07b353 = fff0000000000000
+#43: xsmsubadp 0000000000000000 7ff0000000000000 0123214569900000 = 7ff0000000000000
+#44: xsmsubadp 0123214569900000 7ff0000000000000 c0d0650f5a07b353 = fff0000000000000
+#45: xsmsubadp 7ff0000000000000 7ff0000000000000 0123214569900000 = 7ff8000000000000
+#46: xsmsubadp 7ff7ffffffffffff 7ff0000000000000 c0d0650f5a07b353 = 7fffffffffffffff
+#47: xsmsubadp 7ff8000000000000 7ff0000000000000 0123214569900000 = 7ff8000000000000
+#48: xsmsubadp fff0000000000000 fff7ffffffffffff c0d0650f5a07b353 = ffffffffffffffff
+#49: xsmsubadp c0d0650f5a07b353 fff7ffffffffffff 0123214569900000 = ffffffffffffffff
+#50: xsmsubadp 8000000000000000 fff7ffffffffffff c0d0650f5a07b353 = ffffffffffffffff
+#51: xsmsubadp 0000000000000000 fff7ffffffffffff 0123214569900000 = ffffffffffffffff
+#52: xsmsubadp 0123214569900000 fff7ffffffffffff c0d0650f5a07b353 = ffffffffffffffff
+#53: xsmsubadp 7ff0000000000000 fff7ffffffffffff 0123214569900000 = ffffffffffffffff
+#54: xsmsubadp 7ff7ffffffffffff fff7ffffffffffff c0d0650f5a07b353 = ffffffffffffffff
+#55: xsmsubadp 7ff8000000000000 fff7ffffffffffff 0123214569900000 = ffffffffffffffff
+#56: xsmsubadp fff0000000000000 fff8000000000000 c0d0650f5a07b353 = fff8000000000000
+#57: xsmsubadp c0d0650f5a07b353 fff8000000000000 0123214569900000 = fff8000000000000
+#58: xsmsubadp 8000000000000000 fff8000000000000 c0d0650f5a07b353 = fff8000000000000
+#59: xsmsubadp 0000000000000000 fff8000000000000 0123214569900000 = fff8000000000000
+#60: xsmsubadp 0123214569900000 fff8000000000000 c0d0650f5a07b353 = fff8000000000000
+#61: xsmsubadp 7ff0000000000000 fff8000000000000 0123214569900000 = fff8000000000000
+#62: xsmsubadp 7ff7ffffffffffff fff8000000000000 c0d0650f5a07b353 = fff8000000000000
+#63: xsmsubadp 7ff8000000000000 fff8000000000000 0123214569900000 = fff8000000000000
+
+#0: xsmsubmdp c0d0650f5a07b353 fff0000000000000 fff0000000000000 = 7ff0000000000000
+#1: xsmsubmdp 0123214569900000 fff0000000000000 c0d0650f5a07b353 = fff0000000000000
+#2: xsmsubmdp c0d0650f5a07b353 fff0000000000000 8000000000000000 = 7ff0000000000000
+#3: xsmsubmdp 0123214569900000 fff0000000000000 0000000000000000 = fff0000000000000
+#4: xsmsubmdp c0d0650f5a07b353 fff0000000000000 0123214569900000 = 7ff0000000000000
+#5: xsmsubmdp 0123214569900000 fff0000000000000 7ff0000000000000 = fff0000000000000
+#6: xsmsubmdp c0d0650f5a07b353 fff0000000000000 7ff7ffffffffffff = 7fffffffffffffff
+#7: xsmsubmdp 0123214569900000 fff0000000000000 7ff8000000000000 = 7ff8000000000000
+#8: xsmsubmdp c0d0650f5a07b353 c0d0650f5a07b353 fff0000000000000 = 7ff0000000000000
+#9: xsmsubmdp 0123214569900000 c0d0650f5a07b353 c0d0650f5a07b353 = 40d0650f5a07b353
+#10: xsmsubmdp c0d0650f5a07b353 c0d0650f5a07b353 8000000000000000 = 41b0cc9d05eec2a7
+#11: xsmsubmdp 0123214569900000 c0d0650f5a07b353 0000000000000000 = 82039a19ca8fcb5f
+#12: xsmsubmdp c0d0650f5a07b353 c0d0650f5a07b353 0123214569900000 = 41b0cc9d05eec2a7
+#13: xsmsubmdp 0123214569900000 c0d0650f5a07b353 7ff0000000000000 = fff0000000000000
+#14: xsmsubmdp c0d0650f5a07b353 c0d0650f5a07b353 7ff7ffffffffffff = 7fffffffffffffff
+#15: xsmsubmdp 0123214569900000 c0d0650f5a07b353 7ff8000000000000 = 7ff8000000000000
+#16: xsmsubmdp c0d0650f5a07b353 8000000000000000 fff0000000000000 = 7ff0000000000000
+#17: xsmsubmdp 0123214569900000 8000000000000000 c0d0650f5a07b353 = 40d0650f5a07b353
+#18: xsmsubmdp c0d0650f5a07b353 8000000000000000 8000000000000000 = 0000000000000000
+#19: xsmsubmdp 0123214569900000 8000000000000000 0000000000000000 = 8000000000000000
+#20: xsmsubmdp c0d0650f5a07b353 8000000000000000 0123214569900000 = 8123214569900000
+#21: xsmsubmdp 0123214569900000 8000000000000000 7ff0000000000000 = fff0000000000000
+#22: xsmsubmdp c0d0650f5a07b353 8000000000000000 7ff7ffffffffffff = 7fffffffffffffff
+#23: xsmsubmdp 0123214569900000 8000000000000000 7ff8000000000000 = 7ff8000000000000
+#24: xsmsubmdp c0d0650f5a07b353 0000000000000000 fff0000000000000 = 7ff0000000000000
+#25: xsmsubmdp 0123214569900000 0000000000000000 c0d0650f5a07b353 = 40d0650f5a07b353
+#26: xsmsubmdp c0d0650f5a07b353 0000000000000000 8000000000000000 = 0000000000000000
+#27: xsmsubmdp 0123214569900000 0000000000000000 0000000000000000 = 0000000000000000
+#28: xsmsubmdp c0d0650f5a07b353 0000000000000000 0123214569900000 = 8123214569900000
+#29: xsmsubmdp 0123214569900000 0000000000000000 7ff0000000000000 = fff0000000000000
+#30: xsmsubmdp c0d0650f5a07b353 0000000000000000 7ff7ffffffffffff = 7fffffffffffffff
+#31: xsmsubmdp 0123214569900000 0000000000000000 7ff8000000000000 = 7ff8000000000000
+#32: xsmsubmdp c0d0650f5a07b353 0123214569900000 fff0000000000000 = 7ff0000000000000
+#33: xsmsubmdp 0123214569900000 0123214569900000 c0d0650f5a07b353 = 40d0650f5a07b353
+#34: xsmsubmdp c0d0650f5a07b353 0123214569900000 8000000000000000 = 82039a19ca8fcb5f
+#35: xsmsubmdp 0123214569900000 0123214569900000 0000000000000000 = 0000000000000000
+#36: xsmsubmdp c0d0650f5a07b353 0123214569900000 404f000000000000 = c04f000000000000
+#37: xsmsubmdp 0123214569900000 0123214569900000 7ff0000000000000 = fff0000000000000
+#38: xsmsubmdp c0d0650f5a07b353 0123214569900000 7ff7ffffffffffff = 7fffffffffffffff
+#39: xsmsubmdp 0123214569900000 0123214569900000 7ff8000000000000 = 7ff8000000000000
+#40: xsmsubmdp c0d0650f5a07b353 7ff0000000000000 fff0000000000000 = 7ff8000000000000
+#41: xsmsubmdp 0123214569900000 7ff0000000000000 c0d0650f5a07b353 = 7ff0000000000000
+#42: xsmsubmdp c0d0650f5a07b353 7ff0000000000000 8000000000000000 = fff0000000000000
+#43: xsmsubmdp 0123214569900000 7ff0000000000000 0000000000000000 = 7ff0000000000000
+#44: xsmsubmdp c0d0650f5a07b353 7ff0000000000000 0123214569900000 = fff0000000000000
+#45: xsmsubmdp 0123214569900000 7ff0000000000000 7ff0000000000000 = 7ff8000000000000
+#46: xsmsubmdp c0d0650f5a07b353 7ff0000000000000 7ff7ffffffffffff = 7fffffffffffffff
+#47: xsmsubmdp 0123214569900000 7ff0000000000000 7ff8000000000000 = 7ff8000000000000
+#48: xsmsubmdp c0d0650f5a07b353 fff7ffffffffffff fff0000000000000 = ffffffffffffffff
+#49: xsmsubmdp 0123214569900000 fff7ffffffffffff c0d0650f5a07b353 = ffffffffffffffff
+#50: xsmsubmdp c0d0650f5a07b353 fff7ffffffffffff 8000000000000000 = ffffffffffffffff
+#51: xsmsubmdp 0123214569900000 fff7ffffffffffff 0000000000000000 = ffffffffffffffff
+#52: xsmsubmdp c0d0650f5a07b353 fff7ffffffffffff 0123214569900000 = ffffffffffffffff
+#53: xsmsubmdp 0123214569900000 fff7ffffffffffff 7ff0000000000000 = ffffffffffffffff
+#54: xsmsubmdp c0d0650f5a07b353 fff7ffffffffffff 7ff7ffffffffffff = ffffffffffffffff
+#55: xsmsubmdp 0123214569900000 fff7ffffffffffff 7ff8000000000000 = ffffffffffffffff
+#56: xsmsubmdp c0d0650f5a07b353 fff8000000000000 fff0000000000000 = fff8000000000000
+#57: xsmsubmdp 0123214569900000 fff8000000000000 c0d0650f5a07b353 = fff8000000000000
+#58: xsmsubmdp c0d0650f5a07b353 fff8000000000000 8000000000000000 = fff8000000000000
+#59: xsmsubmdp 0123214569900000 fff8000000000000 0000000000000000 = fff8000000000000
+#60: xsmsubmdp c0d0650f5a07b353 fff8000000000000 0123214569900000 = fff8000000000000
+#61: xsmsubmdp 0123214569900000 fff8000000000000 7ff0000000000000 = fff8000000000000
+#62: xsmsubmdp c0d0650f5a07b353 fff8000000000000 7ff7ffffffffffff = fff8000000000000
+#63: xsmsubmdp 0123214569900000 fff8000000000000 7ff8000000000000 = fff8000000000000
+
+#0: xsnmaddadp fff0000000000000 fff0000000000000 c0d0650f5a07b353 = 7ff8000000000000
+#1: xsnmaddadp c0d0650f5a07b353 fff0000000000000 0123214569900000 = 7ff0000000000000
+#2: xsnmaddadp 8000000000000000 fff0000000000000 c0d0650f5a07b353 = fff0000000000000
+#3: xsnmaddadp 0000000000000000 fff0000000000000 0123214569900000 = 7ff0000000000000
+#4: xsnmaddadp 0123214569900000 fff0000000000000 c0d0650f5a07b353 = fff0000000000000
+#5: xsnmaddadp 7ff0000000000000 fff0000000000000 0123214569900000 = 7ff8000000000000
+#6: xsnmaddadp 7ff7ffffffffffff fff0000000000000 c0d0650f5a07b353 = 7fffffffffffffff
+#7: xsnmaddadp 7ff8000000000000 fff0000000000000 0123214569900000 = 7ff8000000000000
+#8: xsnmaddadp fff0000000000000 c0d0650f5a07b353 c0d0650f5a07b353 = 7ff0000000000000
+#9: xsnmaddadp c0d0650f5a07b353 c0d0650f5a07b353 0123214569900000 = 40d0650f5a07b353
+#10: xsnmaddadp 8000000000000000 c0d0650f5a07b353 c0d0650f5a07b353 = c1b0cc9d05eec2a7
+#11: xsnmaddadp 0000000000000000 c0d0650f5a07b353 0123214569900000 = 02039a19ca8fcb5f
+#12: xsnmaddadp 0123214569900000 c0d0650f5a07b353 c0d0650f5a07b353 = c1b0cc9d05eec2a7
+#13: xsnmaddadp 7ff0000000000000 c0d0650f5a07b353 0123214569900000 = fff0000000000000
+#14: xsnmaddadp 7ff7ffffffffffff c0d0650f5a07b353 c0d0650f5a07b353 = 7fffffffffffffff
+#15: xsnmaddadp 7ff8000000000000 c0d0650f5a07b353 0123214569900000 = 7ff8000000000000
+#16: xsnmaddadp fff0000000000000 8000000000000000 c0d0650f5a07b353 = 7ff0000000000000
+#17: xsnmaddadp c0d0650f5a07b353 8000000000000000 0123214569900000 = 40d0650f5a07b353
+#18: xsnmaddadp 8000000000000000 8000000000000000 c0d0650f5a07b353 = 8000000000000000
+#19: xsnmaddadp 0000000000000000 8000000000000000 0123214569900000 = 8000000000000000
+#20: xsnmaddadp 0123214569900000 8000000000000000 c0d0650f5a07b353 = 8123214569900000
+#21: xsnmaddadp 7ff0000000000000 8000000000000000 0123214569900000 = fff0000000000000
+#22: xsnmaddadp 7ff7ffffffffffff 8000000000000000 c0d0650f5a07b353 = 7fffffffffffffff
+#23: xsnmaddadp 7ff8000000000000 8000000000000000 0123214569900000 = 7ff8000000000000
+#24: xsnmaddadp fff0000000000000 0000000000000000 c0d0650f5a07b353 = 7ff0000000000000
+#25: xsnmaddadp c0d0650f5a07b353 0000000000000000 0123214569900000 = 40d0650f5a07b353
+#26: xsnmaddadp 8000000000000000 0000000000000000 c0d0650f5a07b353 = 0000000000000000
+#27: xsnmaddadp 0000000000000000 0000000000000000 0123214569900000 = 8000000000000000
+#28: xsnmaddadp 0123214569900000 0000000000000000 c0d0650f5a07b353 = 8123214569900000
+#29: xsnmaddadp 7ff0000000000000 0000000000000000 0123214569900000 = fff0000000000000
+#30: xsnmaddadp 7ff7ffffffffffff 0000000000000000 c0d0650f5a07b353 = 7fffffffffffffff
+#31: xsnmaddadp 7ff8000000000000 0000000000000000 0123214569900000 = 7ff8000000000000
+#32: xsnmaddadp fff0000000000000 0123214569900000 c0d0650f5a07b353 = 7ff0000000000000
+#33: xsnmaddadp c0d0650f5a07b353 0123214569900000 0123214569900000 = 40d0650f5a07b353
+#34: xsnmaddadp 8000000000000000 0123214569900000 c0d0650f5a07b353 = 02039a19ca8fcb5f
+#35: xsnmaddadp 0000000000000000 0123214569900000 0123214569900000 = 8000000000000000
+#36: xsnmaddadp 404f000000000000 0123214569900000 c0d0650f5a07b353 = c04f000000000000
+#37: xsnmaddadp 7ff0000000000000 0123214569900000 0123214569900000 = fff0000000000000
+#38: xsnmaddadp 7ff7ffffffffffff 0123214569900000 c0d0650f5a07b353 = 7fffffffffffffff
+#39: xsnmaddadp 7ff8000000000000 0123214569900000 0123214569900000 = 7ff8000000000000
+#40: xsnmaddadp fff0000000000000 7ff0000000000000 c0d0650f5a07b353 = 7ff0000000000000
+#41: xsnmaddadp c0d0650f5a07b353 7ff0000000000000 0123214569900000 = fff0000000000000
+#42: xsnmaddadp 8000000000000000 7ff0000000000000 c0d0650f5a07b353 = 7ff0000000000000
+#43: xsnmaddadp 0000000000000000 7ff0000000000000 0123214569900000 = fff0000000000000
+#44: xsnmaddadp 0123214569900000 7ff0000000000000 c0d0650f5a07b353 = 7ff0000000000000
+#45: xsnmaddadp 7ff0000000000000 7ff0000000000000 0123214569900000 = fff0000000000000
+#46: xsnmaddadp 7ff7ffffffffffff 7ff0000000000000 c0d0650f5a07b353 = 7fffffffffffffff
+#47: xsnmaddadp 7ff8000000000000 7ff0000000000000 0123214569900000 = 7ff8000000000000
+#48: xsnmaddadp fff0000000000000 fff7ffffffffffff c0d0650f5a07b353 = ffffffffffffffff
+#49: xsnmaddadp c0d0650f5a07b353 fff7ffffffffffff 0123214569900000 = ffffffffffffffff
+#50: xsnmaddadp 8000000000000000 fff7ffffffffffff c0d0650f5a07b353 = ffffffffffffffff
+#51: xsnmaddadp 0000000000000000 fff7ffffffffffff 0123214569900000 = ffffffffffffffff
+#52: xsnmaddadp 0123214569900000 fff7ffffffffffff c0d0650f5a07b353 = ffffffffffffffff
+#53: xsnmaddadp 7ff0000000000000 fff7ffffffffffff 0123214569900000 = ffffffffffffffff
+#54: xsnmaddadp 7ff7ffffffffffff fff7ffffffffffff c0d0650f5a07b353 = ffffffffffffffff
+#55: xsnmaddadp 7ff8000000000000 fff7ffffffffffff 0123214569900000 = ffffffffffffffff
+#56: xsnmaddadp fff0000000000000 fff8000000000000 c0d0650f5a07b353 = fff8000000000000
+#57: xsnmaddadp c0d0650f5a07b353 fff8000000000000 0123214569900000 = fff8000000000000
+#58: xsnmaddadp 8000000000000000 fff8000000000000 c0d0650f5a07b353 = fff8000000000000
+#59: xsnmaddadp 0000000000000000 fff8000000000000 0123214569900000 = fff8000000000000
+#60: xsnmaddadp 0123214569900000 fff8000000000000 c0d0650f5a07b353 = fff8000000000000
+#61: xsnmaddadp 7ff0000000000000 fff8000000000000 0123214569900000 = fff8000000000000
+#62: xsnmaddadp 7ff7ffffffffffff fff8000000000000 c0d0650f5a07b353 = fff8000000000000
+#63: xsnmaddadp 7ff8000000000000 fff8000000000000 0123214569900000 = fff8000000000000
+
+#0: xsnmaddmdp c0d0650f5a07b353 fff0000000000000 fff0000000000000 = 7ff8000000000000
+#1: xsnmaddmdp 0123214569900000 fff0000000000000 c0d0650f5a07b353 = 7ff0000000000000
+#2: xsnmaddmdp c0d0650f5a07b353 fff0000000000000 8000000000000000 = fff0000000000000
+#3: xsnmaddmdp 0123214569900000 fff0000000000000 0000000000000000 = 7ff0000000000000
+#4: xsnmaddmdp c0d0650f5a07b353 fff0000000000000 0123214569900000 = fff0000000000000
+#5: xsnmaddmdp 0123214569900000 fff0000000000000 7ff0000000000000 = 7ff8000000000000
+#6: xsnmaddmdp c0d0650f5a07b353 fff0000000000000 7ff7ffffffffffff = 7fffffffffffffff
+#7: xsnmaddmdp 0123214569900000 fff0000000000000 7ff8000000000000 = 7ff8000000000000
+#8: xsnmaddmdp c0d0650f5a07b353 c0d0650f5a07b353 fff0000000000000 = 7ff0000000000000
+#9: xsnmaddmdp 0123214569900000 c0d0650f5a07b353 c0d0650f5a07b353 = 40d0650f5a07b353
+#10: xsnmaddmdp c0d0650f5a07b353 c0d0650f5a07b353 8000000000000000 = c1b0cc9d05eec2a7
+#11: xsnmaddmdp 0123214569900000 c0d0650f5a07b353 0000000000000000 = 02039a19ca8fcb5f
+#12: xsnmaddmdp c0d0650f5a07b353 c0d0650f5a07b353 0123214569900000 = c1b0cc9d05eec2a7
+#13: xsnmaddmdp 0123214569900000 c0d0650f5a07b353 7ff0000000000000 = fff0000000000000
+#14: xsnmaddmdp c0d0650f5a07b353 c0d0650f5a07b353 7ff7ffffffffffff = 7fffffffffffffff
+#15: xsnmaddmdp 0123214569900000 c0d0650f5a07b353 7ff8000000000000 = 7ff8000000000000
+#16: xsnmaddmdp c0d0650f5a07b353 8000000000000000 fff0000000000000 = 7ff0000000000000
+#17: xsnmaddmdp 0123214569900000 8000000000000000 c0d0650f5a07b353 = 40d0650f5a07b353
+#18: xsnmaddmdp c0d0650f5a07b353 8000000000000000 8000000000000000 = 8000000000000000
+#19: xsnmaddmdp 0123214569900000 8000000000000000 0000000000000000 = 8000000000000000
+#20: xsnmaddmdp c0d0650f5a07b353 8000000000000000 0123214569900000 = 8123214569900000
+#21: xsnmaddmdp 0123214569900000 8000000000000000 7ff0000000000000 = fff0000000000000
+#22: xsnmaddmdp c0d0650f5a07b353 8000000000000000 7ff7ffffffffffff = 7fffffffffffffff
+#23: xsnmaddmdp 0123214569900000 8000000000000000 7ff8000000000000 = 7ff8000000000000
+#24: xsnmaddmdp c0d0650f5a07b353 0000000000000000 fff0000000000000 = 7ff0000000000000
+#25: xsnmaddmdp 0123214569900000 0000000000000000 c0d0650f5a07b353 = 40d0650f5a07b353
+#26: xsnmaddmdp c0d0650f5a07b353 0000000000000000 8000000000000000 = 0000000000000000
+#27: xsnmaddmdp 0123214569900000 0000000000000000 0000000000000000 = 8000000000000000
+#28: xsnmaddmdp c0d0650f5a07b353 0000000000000000 0123214569900000 = 8123214569900000
+#29: xsnmaddmdp 0123214569900000 0000000000000000 7ff0000000000000 = fff0000000000000
+#30: xsnmaddmdp c0d0650f5a07b353 0000000000000000 7ff7ffffffffffff = 7fffffffffffffff
+#31: xsnmaddmdp 0123214569900000 0000000000000000 7ff8000000000000 = 7ff8000000000000
+#32: xsnmaddmdp c0d0650f5a07b353 0123214569900000 fff0000000000000 = 7ff0000000000000
+#33: xsnmaddmdp 0123214569900000 0123214569900000 c0d0650f5a07b353 = 40d0650f5a07b353
+#34: xsnmaddmdp c0d0650f5a07b353 0123214569900000 8000000000000000 = 02039a19ca8fcb5f
+#35: xsnmaddmdp 0123214569900000 0123214569900000 0000000000000000 = 8000000000000000
+#36: xsnmaddmdp c0d0650f5a07b353 0123214569900000 404f000000000000 = c04f000000000000
+#37: xsnmaddmdp 0123214569900000 0123214569900000 7ff0000000000000 = fff0000000000000
+#38: xsnmaddmdp c0d0650f5a07b353 0123214569900000 7ff7ffffffffffff = 7fffffffffffffff
+#39: xsnmaddmdp 0123214569900000 0123214569900000 7ff8000000000000 = 7ff8000000000000
+#40: xsnmaddmdp c0d0650f5a07b353 7ff0000000000000 fff0000000000000 = 7ff0000000000000
+#41: xsnmaddmdp 0123214569900000 7ff0000000000000 c0d0650f5a07b353 = fff0000000000000
+#42: xsnmaddmdp c0d0650f5a07b353 7ff0000000000000 8000000000000000 = 7ff0000000000000
+#43: xsnmaddmdp 0123214569900000 7ff0000000000000 0000000000000000 = fff0000000000000
+#44: xsnmaddmdp c0d0650f5a07b353 7ff0000000000000 0123214569900000 = 7ff0000000000000
+#45: xsnmaddmdp 0123214569900000 7ff0000000000000 7ff0000000000000 = fff0000000000000
+#46: xsnmaddmdp c0d0650f5a07b353 7ff0000000000000 7ff7ffffffffffff = 7fffffffffffffff
+#47: xsnmaddmdp 0123214569900000 7ff0000000000000 7ff8000000000000 = 7ff8000000000000
+#48: xsnmaddmdp c0d0650f5a07b353 fff7ffffffffffff fff0000000000000 = ffffffffffffffff
+#49: xsnmaddmdp 0123214569900000 fff7ffffffffffff c0d0650f5a07b353 = ffffffffffffffff
+#50: xsnmaddmdp c0d0650f5a07b353 fff7ffffffffffff 8000000000000000 = ffffffffffffffff
+#51: xsnmaddmdp 0123214569900000 fff7ffffffffffff 0000000000000000 = ffffffffffffffff
+#52: xsnmaddmdp c0d0650f5a07b353 fff7ffffffffffff 0123214569900000 = ffffffffffffffff
+#53: xsnmaddmdp 0123214569900000 fff7ffffffffffff 7ff0000000000000 = ffffffffffffffff
+#54: xsnmaddmdp c0d0650f5a07b353 fff7ffffffffffff 7ff7ffffffffffff = ffffffffffffffff
+#55: xsnmaddmdp 0123214569900000 fff7ffffffffffff 7ff8000000000000 = ffffffffffffffff
+#56: xsnmaddmdp c0d0650f5a07b353 fff8000000000000 fff0000000000000 = fff8000000000000
+#57: xsnmaddmdp 0123214569900000 fff8000000000000 c0d0650f5a07b353 = fff8000000000000
+#58: xsnmaddmdp c0d0650f5a07b353 fff8000000000000 8000000000000000 = fff8000000000000
+#59: xsnmaddmdp 0123214569900000 fff8000000000000 0000000000000000 = fff8000000000000
+#60: xsnmaddmdp c0d0650f5a07b353 fff8000000000000 0123214569900000 = fff8000000000000
+#61: xsnmaddmdp 0123214569900000 fff8000000000000 7ff0000000000000 = fff8000000000000
+#62: xsnmaddmdp c0d0650f5a07b353 fff8000000000000 7ff7ffffffffffff = fff8000000000000
+#63: xsnmaddmdp 0123214569900000 fff8000000000000 7ff8000000000000 = fff8000000000000
+
+#0: xsmuldp fff0000000000000 fff0000000000000 = 7ff0000000000000
+#1: xsmuldp fff0000000000000 c0d0650f5a07b353 = 7ff0000000000000
+#2: xsmuldp fff0000000000000 8000000000000000 = 7ff8000000000000
+#3: xsmuldp fff0000000000000 0000000000000000 = 7ff8000000000000
+#4: xsmuldp fff0000000000000 0123214569900000 = fff0000000000000
+#5: xsmuldp fff0000000000000 7ff0000000000000 = fff0000000000000
+#6: xsmuldp fff0000000000000 7ff7ffffffffffff = 7fffffffffffffff
+#7: xsmuldp fff0000000000000 7ff8000000000000 = 7ff8000000000000
+#8: xsmuldp c0d0650f5a07b353 fff0000000000000 = 7ff0000000000000
+#9: xsmuldp c0d0650f5a07b353 c0d0650f5a07b353 = 41b0cc9d05eec2a7
+#10: xsmuldp c0d0650f5a07b353 8000000000000000 = 0000000000000000
+#11: xsmuldp c0d0650f5a07b353 0000000000000000 = 8000000000000000
+#12: xsmuldp c0d0650f5a07b353 0123214569900000 = 82039a19ca8fcb5f
+#13: xsmuldp c0d0650f5a07b353 7ff0000000000000 = fff0000000000000
+#14: xsmuldp c0d0650f5a07b353 7ff7ffffffffffff = 7fffffffffffffff
+#15: xsmuldp c0d0650f5a07b353 7ff8000000000000 = 7ff8000000000000
+#16: xsmuldp 8000000000000000 fff0000000000000 = 7ff8000000000000
+#17: xsmuldp 8000000000000000 c0d0650f5a07b353 = 0000000000000000
+#18: xsmuldp 8000000000000000 8000000000000000 = 0000000000000000
+#19: xsmuldp 8000000000000000 0000000000000000 = 8000000000000000
+#20: xsmuldp 8000000000000000 0123214569900000 = 8000000000000000
+#21: xsmuldp 8000000000000000 7ff0000000000000 = 7ff8000000000000
+#22: xsmuldp 8000000000000000 7ff7ffffffffffff = 7fffffffffffffff
+#23: xsmuldp 8000000000000000 7ff8000000000000 = 7ff8000000000000
+#24: xsmuldp 0000000000000000 fff0000000000000 = 7ff8000000000000
+#25: xsmuldp 0000000000000000 c0d0650f5a07b353 = 8000000000000000
+#26: xsmuldp 0000000000000000 8000000000000000 = 8000000000000000
+#27: xsmuldp 0000000000000000 0000000000000000 = 0000000000000000
+#28: xsmuldp 0000000000000000 0123214569900000 = 0000000000000000
+#29: xsmuldp 0000000000000000 7ff0000000000000 = 7ff8000000000000
+#30: xsmuldp 0000000000000000 7ff7ffffffffffff = 7fffffffffffffff
+#31: xsmuldp 0000000000000000 7ff8000000000000 = 7ff8000000000000
+#32: xsmuldp 0123214569900000 fff0000000000000 = fff0000000000000
+#33: xsmuldp 0123214569900000 c0d0650f5a07b353 = 82039a19ca8fcb5f
+#34: xsmuldp 0123214569900000 8000000000000000 = 8000000000000000
+#35: xsmuldp 0123214569900000 0000000000000000 = 0000000000000000
+#36: xsmuldp 0123214569900000 404f000000000000 = 0182883b3e438000
+#37: xsmuldp 0123214569900000 7ff0000000000000 = 7ff0000000000000
+#38: xsmuldp 0123214569900000 7ff7ffffffffffff = 7fffffffffffffff
+#39: xsmuldp 0123214569900000 7ff8000000000000 = 7ff8000000000000
+#40: xsmuldp 7ff0000000000000 fff0000000000000 = fff0000000000000
+#41: xsmuldp 7ff0000000000000 c0d0650f5a07b353 = fff0000000000000
+#42: xsmuldp 7ff0000000000000 8000000000000000 = 7ff8000000000000
+#43: xsmuldp 7ff0000000000000 0000000000000000 = 7ff8000000000000
+#44: xsmuldp 7ff0000000000000 0123214569900000 = 7ff0000000000000
+#45: xsmuldp 7ff0000000000000 7ff0000000000000 = 7ff0000000000000
+#46: xsmuldp 7ff0000000000000 7ff7ffffffffffff = 7fffffffffffffff
+#47: xsmuldp 7ff0000000000000 7ff8000000000000 = 7ff8000000000000
+#48: xsmuldp fff7ffffffffffff fff0000000000000 = ffffffffffffffff
+#49: xsmuldp fff7ffffffffffff c0d0650f5a07b353 = ffffffffffffffff
+#50: xsmuldp fff7ffffffffffff 8000000000000000 = ffffffffffffffff
+#51: xsmuldp fff7ffffffffffff 0000000000000000 = ffffffffffffffff
+#52: xsmuldp fff7ffffffffffff 0123214569900000 = ffffffffffffffff
+#53: xsmuldp fff7ffffffffffff 7ff0000000000000 = ffffffffffffffff
+#54: xsmuldp fff7ffffffffffff 7ff7ffffffffffff = ffffffffffffffff
+#55: xsmuldp fff7ffffffffffff 7ff8000000000000 = ffffffffffffffff
+#56: xsmuldp fff8000000000000 fff0000000000000 = fff8000000000000
+#57: xsmuldp fff8000000000000 c0d0650f5a07b353 = fff8000000000000
+#58: xsmuldp fff8000000000000 8000000000000000 = fff8000000000000
+#59: xsmuldp fff8000000000000 0000000000000000 = fff8000000000000
+#60: xsmuldp fff8000000000000 0123214569900000 = fff8000000000000
+#61: xsmuldp fff8000000000000 7ff0000000000000 = fff8000000000000
+#62: xsmuldp fff8000000000000 7ff7ffffffffffff = fff8000000000000
+#63: xsmuldp fff8000000000000 7ff8000000000000 = fff8000000000000
+
+#0: xssubdp fff0000000000000 fff0000000000000 = 7ff8000000000000
+#1: xssubdp fff0000000000000 c0d0650f5a07b353 = fff0000000000000
+#2: xssubdp fff0000000000000 8000000000000000 = fff0000000000000
+#3: xssubdp fff0000000000000 0000000000000000 = fff0000000000000
+#4: xssubdp fff0000000000000 0123214569900000 = fff0000000000000
+#5: xssubdp fff0000000000000 7ff0000000000000 = fff0000000000000
+#6: xssubdp fff0000000000000 7ff7ffffffffffff = 7fffffffffffffff
+#7: xssubdp fff0000000000000 7ff8000000000000 = 7ff8000000000000
+#8: xssubdp c0d0650f5a07b353 fff0000000000000 = 7ff0000000000000
+#9: xssubdp c0d0650f5a07b353 c0d0650f5a07b353 = 0000000000000000
+#10: xssubdp c0d0650f5a07b353 8000000000000000 = c0d0650f5a07b353
+#11: xssubdp c0d0650f5a07b353 0000000000000000 = c0d0650f5a07b353
+#12: xssubdp c0d0650f5a07b353 0123214569900000 = c0d0650f5a07b353
+#13: xssubdp c0d0650f5a07b353 7ff0000000000000 = fff0000000000000
+#14: xssubdp c0d0650f5a07b353 7ff7ffffffffffff = 7fffffffffffffff
+#15: xssubdp c0d0650f5a07b353 7ff8000000000000 = 7ff8000000000000
+#16: xssubdp 8000000000000000 fff0000000000000 = 7ff0000000000000
+#17: xssubdp 8000000000000000 c0d0650f5a07b353 = 40d0650f5a07b353
+#18: xssubdp 8000000000000000 8000000000000000 = 0000000000000000
+#19: xssubdp 8000000000000000 0000000000000000 = 8000000000000000
+#20: xssubdp 8000000000000000 0123214569900000 = 8123214569900000
+#21: xssubdp 8000000000000000 7ff0000000000000 = fff0000000000000
+#22: xssubdp 8000000000000000 7ff7ffffffffffff = 7fffffffffffffff
+#23: xssubdp 8000000000000000 7ff8000000000000 = 7ff8000000000000
+#24: xssubdp 0000000000000000 fff0000000000000 = 7ff0000000000000
+#25: xssubdp 0000000000000000 c0d0650f5a07b353 = 40d0650f5a07b353
+#26: xssubdp 0000000000000000 8000000000000000 = 0000000000000000
+#27: xssubdp 0000000000000000 0000000000000000 = 0000000000000000
+#28: xssubdp 0000000000000000 0123214569900000 = 8123214569900000
+#29: xssubdp 0000000000000000 7ff0000000000000 = fff0000000000000
+#30: xssubdp 0000000000000000 7ff7ffffffffffff = 7fffffffffffffff
+#31: xssubdp 0000000000000000 7ff8000000000000 = 7ff8000000000000
+#32: xssubdp 0123214569900000 fff0000000000000 = 7ff0000000000000
+#33: xssubdp 0123214569900000 c0d0650f5a07b353 = 40d0650f5a07b353
+#34: xssubdp 0123214569900000 8000000000000000 = 0123214569900000
+#35: xssubdp 0123214569900000 0000000000000000 = 0123214569900000
+#36: xssubdp 0123214569900000 404f000000000000 = c04f000000000000
+#37: xssubdp 0123214569900000 7ff0000000000000 = fff0000000000000
+#38: xssubdp 0123214569900000 7ff7ffffffffffff = 7fffffffffffffff
+#39: xssubdp 0123214569900000 7ff8000000000000 = 7ff8000000000000
+#40: xssubdp 7ff0000000000000 fff0000000000000 = 7ff0000000000000
+#41: xssubdp 7ff0000000000000 c0d0650f5a07b353 = 7ff0000000000000
+#42: xssubdp 7ff0000000000000 8000000000000000 = 7ff0000000000000
+#43: xssubdp 7ff0000000000000 0000000000000000 = 7ff0000000000000
+#44: xssubdp 7ff0000000000000 0123214569900000 = 7ff0000000000000
+#45: xssubdp 7ff0000000000000 7ff0000000000000 = 7ff8000000000000
+#46: xssubdp 7ff0000000000000 7ff7ffffffffffff = 7fffffffffffffff
+#47: xssubdp 7ff0000000000000 7ff8000000000000 = 7ff8000000000000
+#48: xssubdp fff7ffffffffffff fff0000000000000 = ffffffffffffffff
+#49: xssubdp fff7ffffffffffff c0d0650f5a07b353 = ffffffffffffffff
+#50: xssubdp fff7ffffffffffff 8000000000000000 = ffffffffffffffff
+#51: xssubdp fff7ffffffffffff 0000000000000000 = ffffffffffffffff
+#52: xssubdp fff7ffffffffffff 0123214569900000 = ffffffffffffffff
+#53: xssubdp fff7ffffffffffff 7ff0000000000000 = ffffffffffffffff
+#54: xssubdp fff7ffffffffffff 7ff7ffffffffffff = ffffffffffffffff
+#55: xssubdp fff7ffffffffffff 7ff8000000000000 = ffffffffffffffff
+#56: xssubdp fff8000000000000 fff0000000000000 = fff8000000000000
+#57: xssubdp fff8000000000000 c0d0650f5a07b353 = fff8000000000000
+#58: xssubdp fff8000000000000 8000000000000000 = fff8000000000000
+#59: xssubdp fff8000000000000 0000000000000000 = fff8000000000000
+#60: xssubdp fff8000000000000 0123214569900000 = fff8000000000000
+#61: xssubdp fff8000000000000 7ff0000000000000 = fff8000000000000
+#62: xssubdp fff8000000000000 7ff7ffffffffffff = fff8000000000000
+#63: xssubdp fff8000000000000 7ff8000000000000 = fff8000000000000
+
+
+Test VSX scalar integer conversion instructions
+#0: xscvdpsxds 3fd8000000000000 => 0000000000000000
+#1: xscvdpsxds 404f000000000000 => 000000000000003e
+#2: xscvdpsxds 0018000000b77501 => 0000000000000000
+#3: xscvdpsxds 7fe800000000051b => 7fffffffffffffff
+#4: xscvdpsxds 0123214569900000 => 0000000000000000
+#5: xscvdpsxds 0000000000000000 => 0000000000000000
+#6: xscvdpsxds 8000000000000000 => 0000000000000000
+#7: xscvdpsxds 7ff0000000000000 => 7fffffffffffffff
+#8: xscvdpsxds fff0000000000000 => 8000000000000000
+#9: xscvdpsxds 7ff7ffffffffffff => 8000000000000000
+#10: xscvdpsxds fff7ffffffffffff => 8000000000000000
+#11: xscvdpsxds 7ff8000000000000 => 8000000000000000
+#12: xscvdpsxds fff8000000000000 => 8000000000000000
+#13: xscvdpsxds 8008340000078000 => 0000000000000000
+#14: xscvdpsxds c0d0650f5a07b353 => ffffffffffffbe6c
+
+#0: xscvsxddp 3fd8000000000000 => 43cfec0000000000
+#1: xscvsxddp 404f000000000000 => 43d013c000000000
+#2: xscvsxddp 0018000000b77501 => 4338000000b77501
+#3: xscvsxddp 7fe800000000051b => 43dffa0000000001
+#4: xscvsxddp 0123214569900000 => 4372321456990000
+#5: xscvsxddp 0000000000000000 => 0000000000000000
+#6: xscvsxddp 8000000000000000 => c3e0000000000000
+#7: xscvsxddp 7ff0000000000000 => 43dffc0000000000
+#8: xscvsxddp fff0000000000000 => c330000000000000
+#9: xscvsxddp 7ff7ffffffffffff => 43dffe0000000000
+#10: xscvsxddp fff7ffffffffffff => c320000000000002
+#11: xscvsxddp 7ff8000000000000 => 43dffe0000000000
+#12: xscvsxddp fff8000000000000 => c320000000000000
+#13: xscvsxddp 8008340000078000 => c3dffdf2fffffe20
+#14: xscvsxddp c0d0650f5a07b353 => c3cf97cd7852fc26
+
+#0: xscvuxddp 3fd8000000000000 => 43cfec0000000000
+#1: xscvuxddp 404f000000000000 => 43d013c000000000
+#2: xscvuxddp 0018000000b77501 => 4338000000b77501
+#3: xscvuxddp 7fe800000000051b => 43dffa0000000001
+#4: xscvuxddp 0123214569900000 => 4372321456990000
+#5: xscvuxddp 0000000000000000 => 0000000000000000
+#6: xscvuxddp 8000000000000000 => 43e0000000000000
+#7: xscvuxddp 7ff0000000000000 => 43dffc0000000000
+#8: xscvuxddp fff0000000000000 => 43effe0000000000
+#9: xscvuxddp 7ff7ffffffffffff => 43dffe0000000000
+#10: xscvuxddp fff7ffffffffffff => 43efff0000000000
+#11: xscvuxddp 7ff8000000000000 => 43dffe0000000000
+#12: xscvuxddp fff8000000000000 => 43efff0000000000
+#13: xscvuxddp 8008340000078000 => 43e00106800000f0
+#14: xscvuxddp c0d0650f5a07b353 => 43e81a0ca1eb40f6
+
+
+Testcase PASSED
--- valgrind-3.6.0/none/tests/ppc32/test_isa_2_06_part1.stderr.exp	(revision 0)
+++ valgrind-3.6.0/none/tests/ppc32/test_isa_2_06_part1.stderr.exp	(revision 11700)
@@ -0,0 +1,2 @@
+
+
--- valgrind-3.6.0/none/tests/ppc32/test_isa_2_06_part1.vgtest	(revision 0)
+++ valgrind-3.6.0/none/tests/ppc32/test_isa_2_06_part1.vgtest	(revision 11700)
@@ -0,0 +1,2 @@
+prereq: ../../../tests/check_isa-2_06_cap
+prog: test_isa_2_06_part1
--- valgrind-3.6.0/none/tests/ppc32/test_isa_2_06_part1.c	(revision 0)
+++ valgrind-3.6.0/none/tests/ppc32/test_isa_2_06_part1.c	(revision 11700)
@@ -0,0 +1,2189 @@
+/*  Copyright (C) 2011 IBM
+
+ Author: Maynard Johnson <maynardj@us.ibm.com>
+
+ This program is free software; you can redistribute it and/or
+ modify it under the terms of the GNU General Public License as
+ published by the Free Software Foundation; either version 2 of the
+ License, or (at your option) any later version.
+
+ This program is distributed in the hope that it will be useful, but
+ WITHOUT ANY WARRANTY; without even the implied warranty of
+ MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ General Public License for more details.
+
+ You should have received a copy of the GNU General Public License
+ along with this program; if not, write to the Free Software
+ Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+ 02111-1307, USA.
+
+ The GNU General Public License is contained in the file COPYING.
+ */
+
+#ifdef HAS_VSX
+
+#include <stdio.h>
+#include <stdint.h>
+#include <stdlib.h>
+#include <string.h>
+#include <malloc.h>
+#include <altivec.h>
+
+#ifndef __powerpc64__
+typedef uint32_t HWord_t;
+#else
+typedef uint64_t HWord_t;
+#endif /* __powerpc64__ */
+
+static int errors;
+register HWord_t r14 __asm__ ("r14");
+register HWord_t r15 __asm__ ("r15");
+register HWord_t r16 __asm__ ("r16");
+register HWord_t r17 __asm__ ("r17");
+register double f14 __asm__ ("fr14");
+register double f15 __asm__ ("fr15");
+register double f16 __asm__ ("fr16");
+register double f17 __asm__ ("fr17");
+
+static volatile unsigned int cond_reg;
+
+#define ALLCR "cr0","cr1","cr2","cr3","cr4","cr5","cr6","cr7"
+
+#define SET_CR(_arg) \
+      __asm__ __volatile__ ("mtcr  %0" : : "b"(_arg) : ALLCR );
+
+#define SET_XER(_arg) \
+      __asm__ __volatile__ ("mtxer %0" : : "b"(_arg) : "xer" );
+
+#define GET_CR(_lval) \
+      __asm__ __volatile__ ("mfcr %0"  : "=b"(_lval) )
+
+#define GET_XER(_lval) \
+      __asm__ __volatile__ ("mfxer %0" : "=b"(_lval) )
+
+#define GET_CR_XER(_lval_cr,_lval_xer) \
+   do { GET_CR(_lval_cr); GET_XER(_lval_xer); } while (0)
+
+#define SET_CR_ZERO \
+      SET_CR(0)
+
+#define SET_XER_ZERO \
+      SET_XER(0)
+
+#define SET_CR_XER_ZERO \
+   do { SET_CR_ZERO; SET_XER_ZERO; } while (0)
+
+#define SET_FPSCR_ZERO \
+   do { double _d = 0.0; \
+        __asm__ __volatile__ ("mtfsf 0xFF, %0" : : "f"(_d) ); \
+   } while (0)
+
+
+typedef void (*test_func_t)(void);
+typedef struct ldst_test ldst_test_t;
+typedef struct vsx_logic_test logic_test_t;
+typedef struct xs_conv_test xs_conv_test_t;
+typedef struct p7_fp_test fp_test_t;
+typedef struct vx_fp_test vx_fp_test_t;
+typedef struct vsx_move_test move_test_t;
+typedef struct vsx_permute_test permute_test_t;
+typedef struct test_table test_table_t;
+
+static double *fargs = NULL;
+static int nb_fargs;
+
+/* These functions below that construct a table of floating point
+ * values were lifted from none/tests/ppc32/jm-insns.c.
+ */
+
+#if defined (DEBUG_ARGS_BUILD)
+#define AB_DPRINTF(fmt, args...) do { fprintf(stderr, fmt , ##args); } while (0)
+#else
+#define AB_DPRINTF(fmt, args...) do { } while (0)
+#endif
+
+static inline void register_farg (void *farg,
+                                  int s, uint16_t _exp, uint64_t mant)
+{
+   uint64_t tmp;
+
+   tmp = ((uint64_t)s << 63) | ((uint64_t)_exp << 52) | mant;
+   *(uint64_t *)farg = tmp;
+   AB_DPRINTF("%d %03x %013llx => %016llx %0e\n",
+              s, _exp, mant, *(uint64_t *)farg, *(double *)farg);
+}
+
+static void build_fargs_table(void)
+/*
+ * Double precision:
+ * Sign goes from zero to one               (1 bit)
+ * Exponent goes from 0 to ((1 << 12) - 1)  (11 bits)
+ * Mantissa goes from 1 to ((1 << 52) - 1)  (52 bits)
+ * + special values:
+ * +0.0      : 0 0x000 0x0000000000000 => 0x0000000000000000
+ * -0.0      : 1 0x000 0x0000000000000 => 0x8000000000000000
+ * +infinity : 0 0x7FF 0x0000000000000 => 0x7FF0000000000000
+ * -infinity : 1 0x7FF 0x0000000000000 => 0xFFF0000000000000
+ * +QNaN     : 0 0x7FF 0x7FFFFFFFFFFFF => 0x7FF7FFFFFFFFFFFF
+ * -QNaN     : 1 0x7FF 0x7FFFFFFFFFFFF => 0xFFF7FFFFFFFFFFFF
+ * +SNaN     : 0 0x7FF 0x8000000000000 => 0x7FF8000000000000
+ * -SNaN     : 1 0x7FF 0x8000000000000 => 0xFFF8000000000000
+ * (8 values)
+ *
+ * Single precision
+ * Sign:     1 bit
+ * Exponent: 8 bits
+ * Mantissa: 23 bits
+ * +0.0      : 0 0x00 0x000000 => 0x00000000
+ * -0.0      : 1 0x00 0x000000 => 0x80000000
+ * +infinity : 0 0xFF 0x000000 => 0x7F800000
+ * -infinity : 1 0xFF 0x000000 => 0xFF800000
+ * +QNaN     : 0 0xFF 0x3FFFFF => 0x7FBFFFFF
+ * -QNaN     : 1 0xFF 0x3FFFFF => 0xFFBFFFFF
+ * +SNaN     : 0 0xFF 0x400000 => 0x7FC00000
+ * -SNaN     : 1 0xFF 0x400000 => 0xFFC00000
+*/
+{
+   uint64_t mant;
+   uint16_t _exp, e1;
+   int s;
+   int i=0;
+
+   if (nb_fargs)
+      return;
+
+   fargs = malloc( 16 * sizeof(double) );
+   for (s = 0; s < 2; s++) {
+      for (e1 = 0x001;; e1 = ((e1 + 1) << 13) + 7) {
+         if (e1 >= 0x400)
+            e1 = 0x3fe;
+         _exp = e1;
+         for (mant = 0x0000000000001ULL; mant < (1ULL << 52);
+         /* Add 'random' bits */
+         mant = ((mant + 0x4A6) << 29) + 0x359) {
+            register_farg( &fargs[i++], s, _exp, mant );
+         }
+         if (e1 == 0x3fe)
+            break;
+      }
+   }
+   // add a few smaller values to fargs . . .
+   s = 0;
+   _exp = 0x002;
+   mant = 0x0000000000b01ULL;
+   register_farg(&fargs[i++], s, _exp, mant);
+
+   _exp = 0x000;
+   mant = 0x00000203f0b3dULL;
+   register_farg(&fargs[i++], s, _exp, mant);
+
+   mant = 0x00000005a203dULL;
+   register_farg(&fargs[i++], s, _exp, mant);
+
+   s = 1;
+   _exp = 0x002;
+   mant = 0x0000000000b01ULL;
+   register_farg(&fargs[i++], s, _exp, mant);
+
+   _exp = 0x000;
+   mant = 0x00000203f0b3dULL;
+   register_farg(&fargs[i++], s, _exp, mant);
+
+   nb_fargs = i;
+}
+
+
+typedef struct ftdiv_test {
+   int fra_idx;
+   int frb_idx;
+   int cr_flags;
+} ftdiv_test_args_t;
+
+typedef struct fp_test_args {
+   int fra_idx;
+   int frb_idx;
+   int cr_flags;
+   unsigned long long dp_bin_result;
+} fp_test_args_t;
+
+unsigned long long xscvuxddp_results[] = {
+                                          0x43cfec0000000000ULL,
+                                          0x43d013c000000000ULL,
+                                          0x4338000000b77501ULL,
+                                          0x43dffa0000000001ULL,
+                                          0x4372321456990000ULL,
+                                          0x0000000000000000ULL,
+                                          0x43e0000000000000ULL,
+                                          0x43dffc0000000000ULL,
+                                          0x43effe0000000000ULL,
+                                          0x43dffe0000000000ULL,
+                                          0x43efff0000000000ULL,
+                                          0x43dffe0000000000ULL,
+                                          0x43efff0000000000ULL,
+                                          0x43e00106800000f0ULL,
+                                          0x43e81a0ca1eb40f6ULL
+};
+
+unsigned long long xscvsxddp_results[] = {
+                                           0x43cfec0000000000ULL,
+                                           0x43d013c000000000ULL,
+                                           0x4338000000b77501ULL,
+                                           0x43dffa0000000001ULL,
+                                           0x4372321456990000ULL,
+                                           0x0000000000000000ULL,
+                                           0xc3e0000000000000ULL,
+                                           0x43dffc0000000000ULL,
+                                           0xc330000000000000ULL,
+                                           0x43dffe0000000000ULL,
+                                           0xc320000000000002ULL,
+                                           0x43dffe0000000000ULL,
+                                           0xc320000000000000ULL,
+                                           0xc3dffdf2fffffe20ULL,
+                                           0xc3cf97cd7852fc26ULL,
+};
+
+unsigned long long xscvdpsxds_results[] = {
+                                           0x0000000000000000ULL,
+                                           0x000000000000003eULL,
+                                           0x0000000000000000ULL,
+                                           0x7fffffffffffffffULL,
+                                           0x0000000000000000ULL,
+                                           0x0000000000000000ULL,
+                                           0x0000000000000000ULL,
+                                           0x7fffffffffffffffULL,
+                                           0x8000000000000000ULL,
+                                           0x8000000000000000ULL,
+                                           0x8000000000000000ULL,
+                                           0x8000000000000000ULL,
+                                           0x8000000000000000ULL,
+                                           0x0000000000000000ULL,
+                                           0xffffffffffffbe6cULL
+};
+
+ftdiv_test_args_t ftdiv_tests[] = {
+                              {0, 1, 0x8},
+                              {9, 1, 0xa},
+                              {1, 12, 0xa},
+                              {0, 2, 0xa},
+                              {1, 3, 0xa},
+                              {3, 0, 0xa},
+                              {0, 3, 0xa},
+                              {4, 0, 0xa},
+                              {7, 1, 0xe},
+                              {8, 1, 0xe},
+                              {1, 7, 0xe},
+                              {0, 13, 0xe},
+                              {5, 5, 0xe},
+                              {5, 6, 0xe},
+};
+
+fp_test_args_t xscmpX_tests[] = {
+                                   {8, 8, 0x2, 0ULL},
+                                   {8, 14, 0x8, 0ULL},
+                                   {8, 6, 0x8, 0ULL},
+                                   {8, 5, 0x8, 0ULL},
+                                   {8, 4, 0x8, 0ULL},
+                                   {8, 7, 0x8, 0ULL},
+                                   {8, 9, 0x1, 0ULL},
+                                   {8, 11, 0x1, 0ULL},
+                                   {14, 8, 0x4, 0ULL},
+                                   {14, 14, 0x2, 0ULL},
+                                   {14, 6, 0x8, 0ULL},
+                                   {14, 5, 0x8, 0ULL},
+                                   {14, 4, 0x8, 0ULL},
+                                   {14, 7, 0x8, 0ULL},
+                                   {14, 9, 0x1, 0ULL},
+                                   {14, 11, 0x1, 0ULL},
+                                   {6, 8, 0x4, 0ULL},
+                                   {6, 14, 0x4, 0ULL},
+                                   {6, 6, 0x2, 0ULL},
+                                   {6, 5, 0x2, 0ULL},
+                                   {6, 4, 0x8, 0ULL},
+                                   {6, 7, 0x8, 0ULL},
+                                   {6, 9, 0x1, 0ULL},
+                                   {6, 11, 0x1, 0ULL},
+                                   {5, 8, 0x4, 0ULL},
+                                   {5, 14, 0x4, 0ULL},
+                                   {5, 6, 0x2, 0ULL},
+                                   {5, 5, 0x2, 0ULL},
+                                   {5, 4, 0x8, 0ULL},
+                                   {5, 7, 0x8, 0ULL},
+                                   {5, 9, 0x1, 0ULL},
+                                   {5, 11, 0x1, 0ULL},
+                                   {4, 8, 0x4, 0ULL},
+                                   {4, 14, 0x4, 0ULL},
+                                   {4, 6, 0x4, 0ULL},
+                                   {4, 5, 0x4, 0ULL},
+                                   {4, 1, 0x8, 0ULL},
+                                   {4, 7, 0x8, 0ULL},
+                                   {4, 9, 0x1, 0ULL},
+                                   {4, 11, 0x1, 0ULL},
+                                   {7, 8, 0x4, 0ULL},
+                                   {7, 14, 0x4, 0ULL},
+                                   {7, 6, 0x4, 0ULL},
+                                   {7, 5, 0x4, 0ULL},
+                                   {7, 4, 0x4, 0ULL},
+                                   {7, 7, 0x2, 0ULL},
+                                   {7, 9, 0x1, 0ULL},
+                                   {7, 11, 0x1, 0ULL},
+                                   {10, 8, 0x1, 0ULL},
+                                   {10, 14, 0x1, 0ULL},
+                                   {10, 6, 0x1, 0ULL},
+                                   {10, 5, 0x1, 0ULL},
+                                   {10, 4, 0x1, 0ULL},
+                                   {10, 7, 0x1, 0ULL},
+                                   {10, 9, 0x1, 0ULL},
+                                   {10, 11, 0x1, 0ULL},
+                                   {12, 8, 0x1, 0ULL},
+                                   {12, 14, 0x1, 0ULL},
+                                   {12, 6, 0x1, 0ULL},
+                                   {12, 5, 0x1, 0ULL},
+                                   {12, 4, 0x1, 0ULL},
+                                   {12, 7, 0x1, 0ULL},
+                                   {12, 9, 0x1, 0ULL},
+                                   {12, 11, 0x1, 0ULL},
+};
+
+fp_test_args_t xsadddp_tests[] = {
+                                   {8, 8, 0x0,   0xfff0000000000000ULL},
+                                   {8, 14, 0x0,  0xfff0000000000000ULL},
+                                   {8, 6, 0x0,   0xfff0000000000000ULL},
+                                   {8, 5, 0x0,   0xfff0000000000000ULL},
+                                   {8, 4, 0x0,   0xfff0000000000000ULL},
+                                   {8, 7, 0x0,   0x7ff8000000000000ULL},
+                                   {8, 9, 0x0,   0x7fffffffffffffffULL},
+                                   {8, 11, 0x0,  0x7ff8000000000000ULL},
+                                   {14, 8, 0x0,  0xfff0000000000000ULL},
+                                   {14, 14, 0x0, 0xc0e0650f5a07b353ULL},
+                                   {14, 6, 0x0,  0xc0d0650f5a07b353ULL},
+                                   {14, 5, 0x0,  0xc0d0650f5a07b353ULL},
+                                   {14, 4, 0x0,  0xc0d0650f5a07b353ULL},
+                                   {14, 7, 0x0,  0x7ff0000000000000ULL},
+                                   {14, 9, 0x0,  0x7fffffffffffffffULL},
+                                   {14, 11, 0x0, 0x7ff8000000000000ULL},
+                                   {6, 8, 0x0,   0xfff0000000000000ULL},
+                                   {6, 14, 0x0,  0xc0d0650f5a07b353ULL},
+                                   {6, 6, 0x0,   0x8000000000000000ULL},
+                                   {6, 5, 0x0,   0x0000000000000000ULL},
+                                   {6, 4, 0x0,   0x0123214569900000ULL},
+                                   {6, 7, 0x0,   0x7ff0000000000000ULL},
+                                   {6, 9, 0x0,   0x7fffffffffffffffULL},
+                                   {6, 11, 0x0,  0x7ff8000000000000ULL},
+                                   {5, 8, 0x0,   0xfff0000000000000ULL},
+                                   {5, 14, 0x0,  0xc0d0650f5a07b353ULL},
+                                   {5, 6, 0x0,   0x0000000000000000ULL},
+                                   {5, 5, 0x0,   0x0000000000000000ULL},
+                                   {5, 4, 0x0,   0x0123214569900000ULL},
+                                   {5, 7, 0x0,   0x7ff0000000000000ULL},
+                                   {5, 9, 0x0,   0x7fffffffffffffffULL},
+                                   {5, 11, 0x0,  0x7ff8000000000000ULL},
+                                   {4, 8, 0x0,   0xfff0000000000000ULL},
+                                   {4, 14, 0x0,  0xc0d0650f5a07b353ULL},
+                                   {4, 6, 0x0,   0x0123214569900000ULL},
+                                   {4, 5, 0x0,   0x0123214569900000ULL},
+                                   {4, 1, 0x0,   0x404f000000000000ULL},
+                                   {4, 7, 0x0,   0x7ff0000000000000ULL},
+                                   {4, 9, 0x0,   0x7fffffffffffffffULL},
+                                   {4, 11, 0x0,  0x7ff8000000000000ULL},
+                                   {7, 8, 0x0,   0x7ff8000000000000ULL},
+                                   {7, 14, 0x0,  0x7ff0000000000000ULL},
+                                   {7, 6, 0x0,   0x7ff0000000000000ULL},
+                                   {7, 5, 0x0,   0x7ff0000000000000ULL},
+                                   {7, 4, 0x0,   0x7ff0000000000000ULL},
+                                   {7, 7, 0x0,   0x7ff0000000000000ULL},
+                                   {7, 9, 0x0,   0x7fffffffffffffffULL},
+                                   {7, 11, 0x0,  0x7ff8000000000000ULL},
+                                   {10, 8, 0x0,  0xffffffffffffffffULL},
+                                   {10, 14, 0x0, 0xffffffffffffffffULL},
+                                   {10, 6, 0x0,  0xffffffffffffffffULL},
+                                   {10, 5, 0x0,  0xffffffffffffffffULL},
+                                   {10, 4, 0x0,  0xffffffffffffffffULL},
+                                   {10, 7, 0x0,  0xffffffffffffffffULL},
+                                   {10, 9, 0x0,  0xffffffffffffffffULL},
+                                   {10, 11, 0x0, 0xffffffffffffffffULL},
+                                   {12, 8, 0x0,  0xfff8000000000000ULL},
+                                   {12, 14, 0x0, 0xfff8000000000000ULL},
+                                   {12, 6, 0x0,  0xfff8000000000000ULL},
+                                   {12, 5, 0x0,  0xfff8000000000000ULL},
+                                   {12, 4, 0x0,  0xfff8000000000000ULL},
+                                   {12, 7, 0x0,  0xfff8000000000000ULL},
+                                   {12, 9, 0x0,  0xfff8000000000000ULL},
+                                   {12, 11, 0x0, 0xfff8000000000000ULL},
+};
+
+fp_test_args_t xsdivdp_tests[] = {
+                                   {8, 8, 0x0,   0x7ff8000000000000ULL},
+                                   {8, 14, 0x0,  0x7ff0000000000000ULL},
+                                   {8, 6, 0x0,   0x7ff0000000000000ULL},
+                                   {8, 5, 0x0,   0xfff0000000000000ULL},
+                                   {8, 4, 0x0,   0xfff0000000000000ULL},
+                                   {8, 7, 0x0,   0x7ff8000000000000ULL},
+                                   {8, 9, 0x0,   0x7fffffffffffffffULL},
+                                   {8, 11, 0x0,  0x7ff8000000000000ULL},
+                                   {14, 8, 0x0,  0x0000000000000000ULL},
+                                   {14, 14, 0x0, 0x3ff0000000000000ULL},
+                                   {14, 6, 0x0,  0x7ff0000000000000ULL},
+                                   {14, 5, 0x0,  0xfff0000000000000ULL},
+                                   {14, 4, 0x0,  0xff9b6cb57ca13c00ULL},
+                                   {14, 7, 0x0,  0x8000000000000000ULL},
+                                   {14, 9, 0x0,  0x7fffffffffffffffULL},
+                                   {14, 11, 0x0, 0x7ff8000000000000ULL},
+                                   {6, 8, 0x0,   0x0000000000000000ULL},
+                                   {6, 14, 0x0,  0x0000000000000000ULL},
+                                   {6, 6, 0x0,   0x7ff8000000000000ULL},
+                                   {6, 5, 0x0,   0x7ff8000000000000ULL},
+                                   {6, 4, 0x0,   0x8000000000000000ULL},
+                                   {6, 7, 0x0,   0x8000000000000000ULL},
+                                   {6, 9, 0x0,   0x7fffffffffffffffULL},
+                                   {6, 11, 0x0,  0x7ff8000000000000ULL},
+                                   {5, 8, 0x0,   0x8000000000000000ULL},
+                                   {5, 14, 0x0,  0x8000000000000000ULL},
+                                   {5, 6, 0x0,   0x7ff8000000000000ULL},
+                                   {5, 5, 0x0,   0x7ff8000000000000ULL},
+                                   {5, 4, 0x0,   0x0000000000000000ULL},
+                                   {5, 7, 0x0,   0x0000000000000000ULL},
+                                   {5, 9, 0x0,   0x7fffffffffffffffULL},
+                                   {5, 11, 0x0,  0x7ff8000000000000ULL},
+                                   {4, 8, 0x0,   0x8000000000000000ULL},
+                                   {4, 14, 0x0,  0x8042ab59d8b6ec87ULL},
+                                   {4, 6, 0x0,   0xfff0000000000000ULL},
+                                   {4, 5, 0x0,   0x7ff0000000000000ULL},
+                                   {4, 1, 0x0,   0x00c3bf3f64b5ad6bULL},
+                                   {4, 7, 0x0,   0x0000000000000000ULL},
+                                   {4, 9, 0x0,   0x7fffffffffffffffULL},
+                                   {4, 11, 0x0,  0x7ff8000000000000ULL},
+                                   {7, 8, 0x0,   0x7ff8000000000000ULL},
+                                   {7, 14, 0x0,  0xfff0000000000000ULL},
+                                   {7, 6, 0x0,   0xfff0000000000000ULL},
+                                   {7, 5, 0x0,   0x7ff0000000000000ULL},
+                                   {7, 4, 0x0,   0x7ff0000000000000ULL},
+                                   {7, 7, 0x0,   0x7ff8000000000000ULL},
+                                   {7, 9, 0x0,   0x7fffffffffffffffULL},
+                                   {7, 11, 0x0,  0x7ff8000000000000ULL},
+                                   {10, 8, 0x0,  0xffffffffffffffffULL},
+                                   {10, 14, 0x0, 0xffffffffffffffffULL},
+                                   {10, 6, 0x0,  0xffffffffffffffffULL},
+                                   {10, 5, 0x0,  0xffffffffffffffffULL},
+                                   {10, 4, 0x0,  0xffffffffffffffffULL},
+                                   {10, 7, 0x0,  0xffffffffffffffffULL},
+                                   {10, 9, 0x0,  0xffffffffffffffffULL},
+                                   {10, 11, 0x0, 0xffffffffffffffffULL},
+                                   {12, 8, 0x0,  0xfff8000000000000ULL},
+                                   {12, 14, 0x0, 0xfff8000000000000ULL},
+                                   {12, 6, 0x0,  0xfff8000000000000ULL},
+                                   {12, 5, 0x0,  0xfff8000000000000ULL},
+                                   {12, 4, 0x0,  0xfff8000000000000ULL},
+                                   {12, 7, 0x0,  0xfff8000000000000ULL},
+                                   {12, 9, 0x0,  0xfff8000000000000ULL},
+                                   {12, 11, 0x0, 0xfff8000000000000ULL},
+};
+
+fp_test_args_t xsmaddXdp_tests[] = {
+                                   {8, 8, 0x0,   0x7ff8000000000000ULL},
+                                   {8, 14, 0x0,  0xfff0000000000000ULL},
+                                   {8, 6, 0x0,   0x7ff0000000000000ULL},
+                                   {8, 5, 0x0,   0xfff0000000000000ULL},
+                                   {8, 4, 0x0,   0x7ff0000000000000ULL},
+                                   {8, 7, 0x0,   0x7ff8000000000000ULL},
+                                   {8, 9, 0x0,   0x7fffffffffffffffULL},
+                                   {8, 11, 0x0,  0x7ff8000000000000ULL},
+                                   {14, 8, 0x0,  0xfff0000000000000ULL},
+                                   {14, 14, 0x0, 0xc0d0650f5a07b353ULL},
+                                   {14, 6, 0x0,  0x41b0cc9d05eec2a7ULL},
+                                   {14, 5, 0x0,  0x82039a19ca8fcb5fULL},
+                                   {14, 4, 0x0,  0x41b0cc9d05eec2a7ULL},
+                                   {14, 7, 0x0,  0x7ff0000000000000ULL},
+                                   {14, 9, 0x0,  0x7fffffffffffffffULL},
+                                   {14, 11, 0x0, 0x7ff8000000000000ULL},
+                                   {6, 8, 0x0,   0xfff0000000000000ULL},
+                                   {6, 14, 0x0,  0xc0d0650f5a07b353ULL},
+                                   {6, 6, 0x0,   0x0000000000000000ULL},
+                                   {6, 5, 0x0,   0x0000000000000000ULL},
+                                   {6, 4, 0x0,   0x0123214569900000ULL},
+                                   {6, 7, 0x0,   0x7ff0000000000000ULL},
+                                   {6, 9, 0x0,   0x7fffffffffffffffULL},
+                                   {6, 11, 0x0,  0x7ff8000000000000ULL},
+                                   {5, 8, 0x0,   0xfff0000000000000ULL},
+                                   {5, 14, 0x0,  0xc0d0650f5a07b353ULL},
+                                   {5, 6, 0x0,   0x8000000000000000ULL},
+                                   {5, 5, 0x0,   0x0000000000000000ULL},
+                                   {5, 4, 0x0,   0x0123214569900000ULL},
+                                   {5, 7, 0x0,   0x7ff0000000000000ULL},
+                                   {5, 9, 0x0,   0x7fffffffffffffffULL},
+                                   {5, 11, 0x0,  0x7ff8000000000000ULL},
+                                   {4, 8, 0x0,   0xfff0000000000000ULL},
+                                   {4, 14, 0x0,  0xc0d0650f5a07b353ULL},
+                                   {4, 6, 0x0,   0x82039a19ca8fcb5fULL},
+                                   {4, 5, 0x0,   0x0000000000000000ULL},
+                                   {4, 1, 0x0,   0x404f000000000000ULL},
+                                   {4, 7, 0x0,   0x7ff0000000000000ULL},
+                                   {4, 9, 0x0,   0x7fffffffffffffffULL},
+                                   {4, 11, 0x0,  0x7ff8000000000000ULL},
+                                   {7, 8, 0x0,   0xfff0000000000000ULL},
+                                   {7, 14, 0x0,  0x7ff0000000000000ULL},
+                                   {7, 6, 0x0,   0xfff0000000000000ULL},
+                                   {7, 5, 0x0,   0x7ff0000000000000ULL},
+                                   {7, 4, 0x0,   0xfff0000000000000ULL},
+                                   {7, 7, 0x0,   0x7ff0000000000000ULL},
+                                   {7, 9, 0x0,   0x7fffffffffffffffULL},
+                                   {7, 11, 0x0,  0x7ff8000000000000ULL},
+                                   {10, 8, 0x0,  0xffffffffffffffffULL},
+                                   {10, 14, 0x0, 0xffffffffffffffffULL},
+                                   {10, 6, 0x0,  0xffffffffffffffffULL},
+                                   {10, 5, 0x0,  0xffffffffffffffffULL},
+                                   {10, 4, 0x0,  0xffffffffffffffffULL},
+                                   {10, 7, 0x0,  0xffffffffffffffffULL},
+                                   {10, 9, 0x0,  0xffffffffffffffffULL},
+                                   {10, 11, 0x0, 0xffffffffffffffffULL},
+                                   {12, 8, 0x0,  0xfff8000000000000ULL},
+                                   {12, 14, 0x0, 0xfff8000000000000ULL},
+                                   {12, 6, 0x0,  0xfff8000000000000ULL},
+                                   {12, 5, 0x0,  0xfff8000000000000ULL},
+                                   {12, 4, 0x0,  0xfff8000000000000ULL},
+                                   {12, 7, 0x0,  0xfff8000000000000ULL},
+                                   {12, 9, 0x0,  0xfff8000000000000ULL},
+                                   {12, 11, 0x0, 0xfff8000000000000ULL},
+};
+
+fp_test_args_t xsmsubXdp_tests[] = {
+                                   {8, 8, 0x0,   0x7ff0000000000000ULL},
+                                   {8, 14, 0x0,  0xfff0000000000000ULL},
+                                   {8, 6, 0x0,   0x7ff0000000000000ULL},
+                                   {8, 5, 0x0,   0xfff0000000000000ULL},
+                                   {8, 4, 0x0,   0x7ff0000000000000ULL},
+                                   {8, 7, 0x0,   0xfff0000000000000ULL},
+                                   {8, 9, 0x0,   0x7fffffffffffffffULL},
+                                   {8, 11, 0x0,  0x7ff8000000000000ULL},
+                                   {14, 8, 0x0,  0x7ff0000000000000ULL},
+                                   {14, 14, 0x0, 0x40d0650f5a07b353ULL},
+                                   {14, 6, 0x0,  0x41b0cc9d05eec2a7ULL},
+                                   {14, 5, 0x0,  0x82039a19ca8fcb5fULL},
+                                   {14, 4, 0x0,  0x41b0cc9d05eec2a7ULL},
+                                   {14, 7, 0x0,  0xfff0000000000000ULL},
+                                   {14, 9, 0x0,  0x7fffffffffffffffULL},
+                                   {14, 11, 0x0, 0x7ff8000000000000ULL},
+                                   {6, 8, 0x0,   0x7ff0000000000000ULL},
+                                   {6, 14, 0x0,  0x40d0650f5a07b353ULL},
+                                   {6, 6, 0x0,   0x0000000000000000ULL},
+                                   {6, 5, 0x0,   0x8000000000000000ULL},
+                                   {6, 4, 0x0,   0x8123214569900000ULL},
+                                   {6, 7, 0x0,   0xfff0000000000000ULL},
+                                   {6, 9, 0x0,   0x7fffffffffffffffULL},
+                                   {6, 11, 0x0,  0x7ff8000000000000ULL},
+                                   {5, 8, 0x0,   0x7ff0000000000000ULL},
+                                   {5, 14, 0x0,  0x40d0650f5a07b353ULL},
+                                   {5, 6, 0x0,   0x0000000000000000ULL},
+                                   {5, 5, 0x0,   0x0000000000000000ULL},
+                                   {5, 4, 0x0,   0x8123214569900000ULL},
+                                   {5, 7, 0x0,   0xfff0000000000000ULL},
+                                   {5, 9, 0x0,   0x7fffffffffffffffULL},
+                                   {5, 11, 0x0,  0x7ff8000000000000ULL},
+                                   {4, 8, 0x0,   0x7ff0000000000000ULL},
+                                   {4, 14, 0x0,  0x40d0650f5a07b353ULL},
+                                   {4, 6, 0x0,   0x82039a19ca8fcb5fULL},
+                                   {4, 5, 0x0,   0x0000000000000000ULL},
+                                   {4, 1, 0x0,   0xc04f000000000000ULL},
+                                   {4, 7, 0x0,   0xfff0000000000000ULL},
+                                   {4, 9, 0x0,   0x7fffffffffffffffULL},
+                                   {4, 11, 0x0,  0x7ff8000000000000ULL},
+                                   {7, 8, 0x0,   0x7ff8000000000000ULL},
+                                   {7, 14, 0x0,  0x7ff0000000000000ULL},
+                                   {7, 6, 0x0,   0xfff0000000000000ULL},
+                                   {7, 5, 0x0,   0x7ff0000000000000ULL},
+                                   {7, 4, 0x0,   0xfff0000000000000ULL},
+                                   {7, 7, 0x0,   0x7ff8000000000000ULL},
+                                   {7, 9, 0x0,   0x7fffffffffffffffULL},
+                                   {7, 11, 0x0,  0x7ff8000000000000ULL},
+                                   {10, 8, 0x0,  0xffffffffffffffffULL},
+                                   {10, 14, 0x0, 0xffffffffffffffffULL},
+                                   {10, 6, 0x0,  0xffffffffffffffffULL},
+                                   {10, 5, 0x0,  0xffffffffffffffffULL},
+                                   {10, 4, 0x0,  0xffffffffffffffffULL},
+                                   {10, 7, 0x0,  0xffffffffffffffffULL},
+                                   {10, 9, 0x0,  0xffffffffffffffffULL},
+                                   {10, 11, 0x0, 0xffffffffffffffffULL},
+                                   {12, 8, 0x0,  0xfff8000000000000ULL},
+                                   {12, 14, 0x0, 0xfff8000000000000ULL},
+                                   {12, 6, 0x0,  0xfff8000000000000ULL},
+                                   {12, 5, 0x0,  0xfff8000000000000ULL},
+                                   {12, 4, 0x0,  0xfff8000000000000ULL},
+                                   {12, 7, 0x0,  0xfff8000000000000ULL},
+                                   {12, 9, 0x0,  0xfff8000000000000ULL},
+                                   {12, 11, 0x0, 0xfff8000000000000ULL},
+};
+
+fp_test_args_t xsnmaddXdp_tests[] = {
+                                     {8, 8, 0x0,   0x7ff8000000000000ULL},
+                                     {8, 14, 0x0,  0x7ff0000000000000ULL},
+                                     {8, 6, 0x0,   0xfff0000000000000ULL},
+                                     {8, 5, 0x0,   0x7ff0000000000000ULL},
+                                     {8, 4, 0x0,   0xfff0000000000000ULL},
+                                     {8, 7, 0x0,   0x7ff8000000000000ULL},
+                                     {8, 9, 0x0,   0x7fffffffffffffffULL},
+                                     {8, 11, 0x0,  0x7ff8000000000000ULL},
+                                     {14, 8, 0x0,  0x7ff0000000000000ULL},
+                                     {14, 14, 0x0, 0x40d0650f5a07b353ULL},
+                                     {14, 6, 0x0,  0xc1b0cc9d05eec2a7ULL},
+                                     {14, 5, 0x0,  0x02039a19ca8fcb5fULL},
+                                     {14, 4, 0x0,  0xc1b0cc9d05eec2a7ULL},
+                                     {14, 7, 0x0,  0xfff0000000000000ULL},
+                                     {14, 9, 0x0,  0x7fffffffffffffffULL},
+                                     {14, 11, 0x0, 0x7ff8000000000000ULL},
+                                     {6, 8, 0x0,   0x7ff0000000000000ULL},
+                                     {6, 14, 0x0,  0x40d0650f5a07b353ULL},
+                                     {6, 6, 0x0,   0x8000000000000000ULL},
+                                     {6, 5, 0x0,   0x8000000000000000ULL},
+                                     {6, 4, 0x0,   0x8123214569900000ULL},
+                                     {6, 7, 0x0,   0xfff0000000000000ULL},
+                                     {6, 9, 0x0,   0x7fffffffffffffffULL},
+                                     {6, 11, 0x0,  0x7ff8000000000000ULL},
+                                     {5, 8, 0x0,   0x7ff0000000000000ULL},
+                                     {5, 14, 0x0,  0x40d0650f5a07b353ULL},
+                                     {5, 6, 0x0,   0x0000000000000000ULL},
+                                     {5, 5, 0x0,   0x8000000000000000ULL},
+                                     {5, 4, 0x0,   0x8123214569900000ULL},
+                                     {5, 7, 0x0,   0xfff0000000000000ULL},
+                                     {5, 9, 0x0,   0x7fffffffffffffffULL},
+                                     {5, 11, 0x0,  0x7ff8000000000000ULL},
+                                     {4, 8, 0x0,   0x7ff0000000000000ULL},
+                                     {4, 14, 0x0,  0x40d0650f5a07b353ULL},
+                                     {4, 6, 0x0,   0x02039a19ca8fcb5fULL},
+                                     {4, 5, 0x0,   0x8000000000000000ULL},
+                                     {4, 1, 0x0,   0xc04f000000000000ULL},
+                                     {4, 7, 0x0,   0xfff0000000000000ULL},
+                                     {4, 9, 0x0,   0x7fffffffffffffffULL},
+                                     {4, 11, 0x0,  0x7ff8000000000000ULL},
+                                     {7, 8, 0x0,   0x7ff0000000000000ULL},
+                                     {7, 14, 0x0,  0xfff0000000000000ULL},
+                                     {7, 6, 0x0,   0x7ff0000000000000ULL},
+                                     {7, 5, 0x0,   0xfff0000000000000ULL},
+                                     {7, 4, 0x0,   0x7ff0000000000000ULL},
+                                     {7, 7, 0x0,   0xfff0000000000000ULL},
+                                     {7, 9, 0x0,   0x7fffffffffffffffULL},
+                                     {7, 11, 0x0,  0x7ff8000000000000ULL},
+                                     {10, 8, 0x0,  0xffffffffffffffffULL},
+                                     {10, 14, 0x0, 0xffffffffffffffffULL},
+                                     {10, 6, 0x0,  0xffffffffffffffffULL},
+                                     {10, 5, 0x0,  0xffffffffffffffffULL},
+                                     {10, 4, 0x0,  0xffffffffffffffffULL},
+                                     {10, 7, 0x0,  0xffffffffffffffffULL},
+                                     {10, 9, 0x0,  0xffffffffffffffffULL},
+                                     {10, 11, 0x0, 0xffffffffffffffffULL},
+                                     {12, 8, 0x0,  0xfff8000000000000ULL},
+                                     {12, 14, 0x0, 0xfff8000000000000ULL},
+                                     {12, 6, 0x0,  0xfff8000000000000ULL},
+                                     {12, 5, 0x0,  0xfff8000000000000ULL},
+                                     {12, 4, 0x0,  0xfff8000000000000ULL},
+                                     {12, 7, 0x0,  0xfff8000000000000ULL},
+                                     {12, 9, 0x0,  0xfff8000000000000ULL},
+                                     {12, 11, 0x0, 0xfff8000000000000ULL},
+};
+
+fp_test_args_t xsmuldp_tests[] = {
+                                  {8, 8, 0x0,   0x7ff0000000000000ULL},
+                                  {8, 14, 0x0,  0x7ff0000000000000ULL},
+                                  {8, 6, 0x0,   0x7ff8000000000000ULL},
+                                  {8, 5, 0x0,   0x7ff8000000000000ULL},
+                                  {8, 4, 0x0,   0xfff0000000000000ULL},
+                                  {8, 7, 0x0,   0xfff0000000000000ULL},
+                                  {8, 9, 0x0,   0x7fffffffffffffffULL},
+                                  {8, 11, 0x0,  0x7ff8000000000000ULL},
+                                  {14, 8, 0x0,  0x7ff0000000000000ULL},
+                                  {14, 14, 0x0, 0x41b0cc9d05eec2a7ULL},
+                                  {14, 6, 0x0,  0x0000000000000000ULL},
+                                  {14, 5, 0x0,  0x8000000000000000ULL},
+                                  {14, 4, 0x0,  0x82039a19ca8fcb5fULL},
+                                  {14, 7, 0x0,  0xfff0000000000000ULL},
+                                  {14, 9, 0x0,  0x7fffffffffffffffULL},
+                                  {14, 11, 0x0, 0x7ff8000000000000ULL},
+                                  {6, 8, 0x0,   0x7ff8000000000000ULL},
+                                  {6, 14, 0x0,  0x0000000000000000ULL},
+                                  {6, 6, 0x0,   0x0000000000000000ULL},
+                                  {6, 5, 0x0,   0x8000000000000000ULL},
+                                  {6, 4, 0x0,   0x8000000000000000ULL},
+                                  {6, 7, 0x0,   0x7ff8000000000000ULL},
+                                  {6, 9, 0x0,   0x7fffffffffffffffULL},
+                                  {6, 11, 0x0,  0x7ff8000000000000ULL},
+                                  {5, 8, 0x0,   0x7ff8000000000000ULL},
+                                  {5, 14, 0x0,  0x8000000000000000ULL},
+                                  {5, 6, 0x0,   0x8000000000000000ULL},
+                                  {5, 5, 0x0,   0x0000000000000000ULL},
+                                  {5, 4, 0x0,   0x0000000000000000ULL},
+                                  {5, 7, 0x0,   0x7ff8000000000000ULL},
+                                  {5, 9, 0x0,   0x7fffffffffffffffULL},
+                                  {5, 11, 0x0,  0x7ff8000000000000ULL},
+                                  {4, 8, 0x0,   0xfff0000000000000ULL},
+                                  {4, 14, 0x0,  0x82039a19ca8fcb5fULL},
+                                  {4, 6, 0x0,   0x8000000000000000ULL},
+                                  {4, 5, 0x0,   0x0000000000000000ULL},
+                                  {4, 1, 0x0,   0x0182883b3e438000ULL},
+                                  {4, 7, 0x0,   0x7ff0000000000000ULL},
+                                  {4, 9, 0x0,   0x7fffffffffffffffULL},
+                                  {4, 11, 0x0,  0x7ff8000000000000ULL},
+                                  {7, 8, 0x0,   0xfff0000000000000ULL},
+                                  {7, 14, 0x0,  0xfff0000000000000ULL},
+                                  {7, 6, 0x0,   0x7ff8000000000000ULL},
+                                  {7, 5, 0x0,   0x7ff8000000000000ULL},
+                                  {7, 4, 0x0,   0x7ff0000000000000ULL},
+                                  {7, 7, 0x0,   0x7ff0000000000000ULL},
+                                  {7, 9, 0x0,   0x7fffffffffffffffULL},
+                                  {7, 11, 0x0,  0x7ff8000000000000ULL},
+                                  {10, 8, 0x0,  0xffffffffffffffffULL},
+                                  {10, 14, 0x0, 0xffffffffffffffffULL},
+                                  {10, 6, 0x0,  0xffffffffffffffffULL},
+                                  {10, 5, 0x0,  0xffffffffffffffffULL},
+                                  {10, 4, 0x0,  0xffffffffffffffffULL},
+                                  {10, 7, 0x0,  0xffffffffffffffffULL},
+                                  {10, 9, 0x0,  0xffffffffffffffffULL},
+                                  {10, 11, 0x0, 0xffffffffffffffffULL},
+                                  {12, 8, 0x0,  0xfff8000000000000ULL},
+                                  {12, 14, 0x0, 0xfff8000000000000ULL},
+                                  {12, 6, 0x0,  0xfff8000000000000ULL},
+                                  {12, 5, 0x0,  0xfff8000000000000ULL},
+                                  {12, 4, 0x0,  0xfff8000000000000ULL},
+                                  {12, 7, 0x0,  0xfff8000000000000ULL},
+                                  {12, 9, 0x0,  0xfff8000000000000ULL},
+                                  {12, 11, 0x0, 0xfff8000000000000ULL},
+};
+
+fp_test_args_t xssubdp_tests[] = {
+                                  {8, 8, 0x0,   0x7ff8000000000000ULL},
+                                  {8, 14, 0x0,  0xfff0000000000000ULL},
+                                  {8, 6, 0x0,   0xfff0000000000000ULL},
+                                  {8, 5, 0x0,   0xfff0000000000000ULL},
+                                  {8, 4, 0x0,   0xfff0000000000000ULL},
+                                  {8, 7, 0x0,   0xfff0000000000000ULL},
+                                  {8, 9, 0x0,   0x7fffffffffffffffULL},
+                                  {8, 11, 0x0,  0x7ff8000000000000ULL},
+                                  {14, 8, 0x0,  0x7ff0000000000000ULL},
+                                  {14, 14, 0x0, 0x0000000000000000ULL},
+                                  {14, 6, 0x0,  0xc0d0650f5a07b353ULL},
+                                  {14, 5, 0x0,  0xc0d0650f5a07b353ULL},
+                                  {14, 4, 0x0,  0xc0d0650f5a07b353ULL},
+                                  {14, 7, 0x0,  0xfff0000000000000ULL},
+                                  {14, 9, 0x0,  0x7fffffffffffffffULL},
+                                  {14, 11, 0x0, 0x7ff8000000000000ULL},
+                                  {6, 8, 0x0,   0x7ff0000000000000ULL},
+                                  {6, 14, 0x0,  0x40d0650f5a07b353ULL},
+                                  {6, 6, 0x0,   0x0000000000000000ULL},
+                                  {6, 5, 0x0,   0x8000000000000000ULL},
+                                  {6, 4, 0x0,   0x8123214569900000ULL},
+                                  {6, 7, 0x0,   0xfff0000000000000ULL},
+                                  {6, 9, 0x0,   0x7fffffffffffffffULL},
+                                  {6, 11, 0x0,  0x7ff8000000000000ULL},
+                                  {5, 8, 0x0,   0x7ff0000000000000ULL},
+                                  {5, 14, 0x0,  0x40d0650f5a07b353ULL},
+                                  {5, 6, 0x0,   0x0000000000000000ULL},
+                                  {5, 5, 0x0,   0x0000000000000000ULL},
+                                  {5, 4, 0x0,   0x8123214569900000ULL},
+                                  {5, 7, 0x0,   0xfff0000000000000ULL},
+                                  {5, 9, 0x0,   0x7fffffffffffffffULL},
+                                  {5, 11, 0x0,  0x7ff8000000000000ULL},
+                                  {4, 8, 0x0,   0x7ff0000000000000ULL},
+                                  {4, 14, 0x0,  0x40d0650f5a07b353ULL},
+                                  {4, 6, 0x0,   0x0123214569900000ULL},
+                                  {4, 5, 0x0,   0x0123214569900000ULL},
+                                  {4, 1, 0x0,   0xc04f000000000000ULL},
+                                  {4, 7, 0x0,   0xfff0000000000000ULL},
+                                  {4, 9, 0x0,   0x7fffffffffffffffULL},
+                                  {4, 11, 0x0,  0x7ff8000000000000ULL},
+                                  {7, 8, 0x0,   0x7ff0000000000000ULL},
+                                  {7, 14, 0x0,  0x7ff0000000000000ULL},
+                                  {7, 6, 0x0,   0x7ff0000000000000ULL},
+                                  {7, 5, 0x0,   0x7ff0000000000000ULL},
+                                  {7, 4, 0x0,   0x7ff0000000000000ULL},
+                                  {7, 7, 0x0,   0x7ff8000000000000ULL},
+                                  {7, 9, 0x0,   0x7fffffffffffffffULL},
+                                  {7, 11, 0x0,  0x7ff8000000000000ULL},
+                                  {10, 8, 0x0,  0xffffffffffffffffULL},
+                                  {10, 14, 0x0, 0xffffffffffffffffULL},
+                                  {10, 6, 0x0,  0xffffffffffffffffULL},
+                                  {10, 5, 0x0,  0xffffffffffffffffULL},
+                                  {10, 4, 0x0,  0xffffffffffffffffULL},
+                                  {10, 7, 0x0,  0xffffffffffffffffULL},
+                                  {10, 9, 0x0,  0xffffffffffffffffULL},
+                                  {10, 11, 0x0, 0xffffffffffffffffULL},
+                                  {12, 8, 0x0,  0xfff8000000000000ULL},
+                                  {12, 14, 0x0, 0xfff8000000000000ULL},
+                                  {12, 6, 0x0,  0xfff8000000000000ULL},
+                                  {12, 5, 0x0,  0xfff8000000000000ULL},
+                                  {12, 4, 0x0,  0xfff8000000000000ULL},
+                                  {12, 7, 0x0,  0xfff8000000000000ULL},
+                                  {12, 9, 0x0,  0xfff8000000000000ULL},
+                                  {12, 11, 0x0, 0xfff8000000000000ULL},
+};
+
+
+
+static int nb_special_fargs;
+static double * spec_fargs;
+
+static void build_special_fargs_table(void)
+{
+   /* The special floating point values created below are for
+    * use in the ftdiv tests for setting the fe_flag and fg_flag,
+    * but they can also be used for other tests (e.g., xscmpudp).
+    *
+    * Note that fl_flag is 'always '1' on ppc64 Linux.
+    *
+  Entry  Sign Exp   fraction                  Special value
+   0      0   3fd   0x8000000000000ULL         Positive finite number
+   1      0   404   0xf000000000000ULL         ...
+   2      0   001   0x8000000b77501ULL         ...
+   3      0   7fe   0x800000000051bULL         ...
+   4      0   012   0x3214569900000ULL         ...
+   5      0   000   0x0000000000000ULL         +0.0 (+zero)
+   6      1   000   0x0000000000000ULL         -0.0 (-zero)
+   7      0   7ff   0x0000000000000ULL         +infinity
+   8      1   7ff   0x0000000000000ULL         -infinity
+   9      0   7ff   0x7FFFFFFFFFFFFULL         +QNaN
+   10     1   7ff   0x7FFFFFFFFFFFFULL         -QNaN
+   11     0   7ff   0x8000000000000ULL         +SNaN
+   12     1   7ff   0x8000000000000ULL         -SNaN
+   13     1   000   0x8340000078000ULL         Denormalized val (zero exp and non-zero fraction)
+   14     1   40d   0x0650f5a07b353ULL         Negative finite number
+    */
+
+   uint64_t mant;
+   uint16_t _exp;
+   int s;
+   int i = 0;
+
+   if (spec_fargs)
+      return;
+
+   spec_fargs = malloc( 16 * sizeof(double) );
+
+   // #0
+   s = 0;
+   _exp = 0x3fd;
+   mant = 0x8000000000000ULL;
+   register_farg(&spec_fargs[i++], s, _exp, mant);
+
+   // #1
+   s = 0;
+   _exp = 0x404;
+   mant = 0xf000000000000ULL;
+   register_farg(&spec_fargs[i++], s, _exp, mant);
+
+   /* None of the ftdiv tests succeed.
+    * FRA = value #0; FRB = value #1
+    * ea_ = -2; e_b = 5
+    * fl_flag || fg_flag || fe_flag = 100
+    */
+
+   /*************************************************
+    *     fe_flag tests
+    *
+    *************************************************/
+
+   /* fe_flag <- 1 if FRA is a NaN
+    * FRA = value #9; FRB = value #1
+    * e_a = 1024; e_b = 5
+    * fl_flag || fg_flag || fe_flag = 101
+    */
+
+   /* fe_flag <- 1 if FRB is a NaN
+    * FRA = value #1; FRB = value #12
+    * e_a = 5; e_b = 1024
+    * fl_flag || fg_flag || fe_flag = 101
+    */
+
+   /* fe_flag <- 1 if e_b <= -1022
+    * FRA = value #0; FRB = value #2
+    * e_a = -2; e_b = -1022
+    * fl_flag || fg_flag || fe_flag = 101
+    *
+    */
+   // #2
+   s = 0;
+   _exp = 0x001;
+   mant = 0x8000000b77501ULL;
+   register_farg(&spec_fargs[i++], s, _exp, mant);
+
+   /* fe_flag <- 1 if e_b >= 1021
+    * FRA = value #1; FRB = value #3
+    * e_a = 5; e_b = 1023
+    * fl_flag || fg_flag || fe_flag = 101
+    */
+   // #3
+   s = 0;
+   _exp = 0x7fe;
+   mant = 0x800000000051bULL;
+   register_farg(&spec_fargs[i++], s, _exp, mant);
+
+   /* fe_flag <- 1 if FRA != 0 && e_a - e_b >= 1023
+    * Let FRA = value #3 and FRB be value #0.
+    * e_a = 1023; e_b = -2
+    * fl_flag || fg_flag || fe_flag = 101
+    */
+
+   /* fe_flag <- 1 if FRA != 0 && e_a - e_b <= -1023
+    * Let FRA = value #0 above and FRB be value #3 above
+    * e_a = -2; e_b = 1023
+    * fl_flag || fg_flag || fe_flag = 101
+    */
+
+   /* fe_flag <- 1 if FRA != 0 && e_a <= -970
+    * Let FRA = value #4 and FRB be value #0
+    * e_a = -1005; e_b = -2
+    * fl_flag || fg_flag || fe_flag = 101
+   */
+   // #4
+   s = 0;
+   _exp = 0x012;
+   mant = 0x3214569900000ULL;
+   register_farg(&spec_fargs[i++], s, _exp, mant);
+
+   /*************************************************
+    *     fg_flag tests
+    *
+    *************************************************/
+   /* fg_flag <- 1 if FRA is an Infinity
+    * NOTE: FRA = Inf also sets fe_flag
+    * Do two tests, using values #7 and #8 (+/- Inf) for FRA.
+    * Test 1:
+    *   Let FRA be value #7 and FRB be value #1
+    *   e_a = 1024; e_b = 5
+    *   fl_flag || fg_flag || fe_flag = 111
+    *
+    * Test 2:
+    *   Let FRA be value #8 and FRB be value #1
+    *   e_a = 1024; e_b = 5
+    *   fl_flag || fg_flag || fe_flag = 111
+    *
+    */
+
+   /* fg_flag <- 1 if FRB is an Infinity
+    * NOTE: FRB = Inf also sets fe_flag
+    * Let FRA be value #1 and FRB be value #7
+    * e_a = 5; e_b = 1024
+    * fl_flag || fg_flag || fe_flag = 111
+    */
+
+   /* fg_flag <- 1 if FRB is denormalized
+    * NOTE: e_b < -1022 ==> fe_flag <- 1
+    * Let FRA be value #0 and FRB be value #13
+    * e_a = -2; e_b = -1023
+    * fl_flag || fg_flag || fe_flag = 111
+    */
+
+   /* fg_flag <- 1 if FRB is +zero
+    * NOTE: FRA = Inf also sets fe_flag
+    * Let FRA = val #5; FRB = val #5
+    * ea_ = -1023; e_b = -1023
+    * fl_flag || fg_flag || fe_flag = 111
+    */
+
+   /* fg_flag <- 1 if FRB is -zero
+    * NOTE: FRA = Inf also sets fe_flag
+    * Let FRA = val #5; FRB = val #6
+    * ea_ = -1023; e_b = -1023
+    * fl_flag || fg_flag || fe_flag = 111
+    */
+
+   /* Special values */
+   /* +0.0      : 0 0x000 0x0000000000000 */
+   // #5
+   s = 0;
+   _exp = 0x000;
+   mant = 0x0000000000000ULL;
+   register_farg(&spec_fargs[i++], s, _exp, mant);
+
+   /* -0.0      : 1 0x000 0x0000000000000 */
+   // #6
+   s = 1;
+   _exp = 0x000;
+   mant = 0x0000000000000ULL;
+   register_farg(&spec_fargs[i++], s, _exp, mant);
+
+   /* +infinity : 0 0x7FF 0x0000000000000  */
+   // #7
+   s = 0;
+   _exp = 0x7FF;
+   mant = 0x0000000000000ULL;
+   register_farg(&spec_fargs[i++], s, _exp, mant);
+
+   /* -infinity : 1 0x7FF 0x0000000000000 */
+   // #8
+   s = 1;
+   _exp = 0x7FF;
+   mant = 0x0000000000000ULL;
+   register_farg(&spec_fargs[i++], s, _exp, mant);
+
+   /* +QNaN     : 0 0x7FF 0x7FFFFFFFFFFFF */
+   // #9
+   s = 0;
+   _exp = 0x7FF;
+   mant = 0x7FFFFFFFFFFFFULL;
+   register_farg(&spec_fargs[i++], s, _exp, mant);
+
+   /* -QNaN     : 1 0x7FF 0x7FFFFFFFFFFFF */
+   // #10
+   s = 1;
+   _exp = 0x7FF;
+   mant = 0x7FFFFFFFFFFFFULL;
+   register_farg(&spec_fargs[i++], s, _exp, mant);
+
+   /* +SNaN     : 0 0x7FF 0x8000000000000 */
+   // #11
+   s = 0;
+   _exp = 0x7FF;
+   mant = 0x8000000000000ULL;
+   register_farg(&spec_fargs[i++], s, _exp, mant);
+
+   /* -SNaN     : 1 0x7FF 0x8000000000000 */
+   // #12
+   s = 1;
+   _exp = 0x7FF;
+   mant = 0x8000000000000ULL;
+   register_farg(&spec_fargs[i++], s, _exp, mant);
+
+   /* denormalized value */
+   // #13
+   s = 1;
+   _exp = 0x000;
+   mant = 0x8340000078000ULL;
+   register_farg(&spec_fargs[i++], s, _exp, mant);
+
+   /* Negative finite number */
+   // #14
+   s = 1;
+   _exp = 0x40d;
+   mant = 0x0650f5a07b353ULL;
+   register_farg(&spec_fargs[i++], s, _exp, mant);
+
+   nb_special_fargs = i;
+}
+
+
+struct test_table
+{
+   test_func_t test_category;
+   char * name;
+};
+
+struct p7_fp_test
+{
+   test_func_t test_func;
+   const char *name;
+   int single;  // 1=single precision result; 0=double precision result
+};
+
+typedef enum {
+   VX_FP_CMP,
+   VX_FP_SMA,
+   VX_FP_SMS,
+   VX_FP_SNMA,
+   VX_FP_OTHER
+} vx_fp_test_type;
+
+struct vx_fp_test
+{
+   test_func_t test_func;
+   const char *name;
+   fp_test_args_t * targs;
+   int num_tests;
+   vx_fp_test_type test_type;
+};
+
+struct xs_conv_test
+{
+   test_func_t test_func;
+   const char *name;
+   unsigned long long * results;
+   int num_tests;
+};
+
+typedef enum {
+   VSX_LOAD =1,
+   VSX_LOAD_SPLAT,
+   VSX_STORE
+} vsx_ldst_type;
+
+struct ldst_test
+{
+   test_func_t test_func;
+   const char *name;
+   void * base_addr;
+   uint32_t offset;
+   int num_words_to_process;
+   vsx_ldst_type type;
+};
+
+typedef enum {
+   VSX_AND = 1,
+   VSX_XOR,
+   VSX_ANDC,
+   VSX_OR,
+   VSX_NOR
+} vsx_log_op;
+
+struct vsx_logic_test
+{
+   test_func_t test_func;
+   const char *name;
+   vsx_log_op op;
+};
+
+struct vsx_move_test
+{
+   test_func_t test_func;
+   const char *name;
+   int xa_idx, xb_idx;
+   unsigned long long expected_result;
+};
+
+struct vsx_permute_test
+{
+   test_func_t test_func;
+   const char *name;
+   unsigned int xa[4];
+   unsigned int xb[4];
+   unsigned int expected_output[4];
+};
+
+static vector unsigned int vec_out, vec_inA, vec_inB;
+
+static void test_lxsdx(void)
+{
+   __asm__ __volatile__ ("lxsdx          %x0, %1, %2" : "=wa" (vec_out): "b" (r14),"r" (r15));
+}
+
+static void
+test_lxvd2x(void)
+{
+   __asm__ __volatile__ ("lxvd2x          %x0, %1, %2" : "=wa" (vec_out): "b" (r14),"r" (r15));
+}
+
+static void test_lxvdsx(void)
+{
+   __asm__ __volatile__ ("lxvdsx          %x0, %1, %2" : "=wa" (vec_out): "b" (r14),"r" (r15));
+}
+
+static void test_lxvw4x(void)
+{
+   __asm__ __volatile__ ("lxvw4x          %x0, %1, %2" : "=wa" (vec_out): "b" (r14),"r" (r15));
+}
+
+static void test_stxsdx(void)
+{
+   __asm__ __volatile__ ("stxsdx          %x0, %1, %2" : : "wa" (vec_inA), "b" (r14),"r" (r15));
+}
+
+static void test_stxvd2x(void)
+{
+   __asm__ __volatile__ ("stxvd2x          %x0, %1, %2" : : "wa" (vec_inA), "b" (r14),"r" (r15));
+}
+
+static void test_stxvw4x(void)
+{
+   __asm__ __volatile__ ("stxvw4x          %x0, %1, %2" : : "wa" (vec_inA), "b" (r14),"r" (r15));
+}
+
+static void test_xxlxor(void)
+{
+   __asm__ __volatile__ ("xxlxor          %x0, %x1, %x2" : "=wa" (vec_out): "wa" (vec_inA),"wa" (vec_inB));
+}
+
+static void test_xxlor(void)
+{
+   __asm__ __volatile__ ("xxlor          %x0, %x1, %x2" : "=wa" (vec_out): "wa" (vec_inA),"wa" (vec_inB));
+}
+
+static void test_xxlnor(void)
+{
+   __asm__ __volatile__ ("xxlnor          %x0, %x1, %x2" : "=wa" (vec_out): "wa" (vec_inA),"wa" (vec_inB));
+}
+
+static void test_xxland(void)
+{
+   __asm__ __volatile__ ("xxland          %x0, %x1, %x2" : "=wa" (vec_out): "wa" (vec_inA),"wa" (vec_inB));
+}
+
+static void test_xxlandc(void)
+{
+   __asm__ __volatile__ ("xxlandc          %x0, %x1, %x2" : "=wa" (vec_out): "wa" (vec_inA),"wa" (vec_inB));
+}
+
+static void test_xxmrghw(void)
+{
+   __asm__ __volatile__ ("xxmrghw          %x0, %x1, %x2" : "=wa" (vec_out): "wa" (vec_inA),"wa" (vec_inB));
+}
+
+static void test_xxmrglw(void)
+{
+   __asm__ __volatile__ ("xxmrglw          %x0, %x1, %x2" : "=wa" (vec_out): "wa" (vec_inA),"wa" (vec_inB));
+}
+
+static void test_xxpermdi_00(void)
+{
+   __asm__ __volatile__ ("xxpermdi         %x0, %x1, %x2, 0x0" : "=wa" (vec_out): "wa" (vec_inA),"wa" (vec_inB));
+}
+
+static void test_xxpermdi_01(void)
+{
+   __asm__ __volatile__ ("xxpermdi         %x0, %x1, %x2, 0x1" : "=wa" (vec_out): "wa" (vec_inA),"wa" (vec_inB));
+}
+
+static void test_xxpermdi_10(void)
+{
+   __asm__ __volatile__ ("xxpermdi         %x0, %x1, %x2, 0x2" : "=wa" (vec_out): "wa" (vec_inA),"wa" (vec_inB));
+}
+
+static void test_xxpermdi_11(void)
+{
+   __asm__ __volatile__ ("xxpermdi         %x0, %x1, %x2, 0x3" : "=wa" (vec_out): "wa" (vec_inA),"wa" (vec_inB));
+}
+
+static void test_xxsldwi_0(void)
+{
+   __asm__ __volatile__ ("xxsldwi         %x0, %x1, %x2, 0" : "=wa" (vec_out): "wa" (vec_inA),"wa" (vec_inB));
+}
+
+static void test_xxsldwi_1(void)
+{
+   __asm__ __volatile__ ("xxsldwi         %x0, %x1, %x2, 1" : "=wa" (vec_out): "wa" (vec_inA),"wa" (vec_inB));
+}
+
+static void test_xxsldwi_2(void)
+{
+   __asm__ __volatile__ ("xxsldwi         %x0, %x1, %x2, 2" : "=wa" (vec_out): "wa" (vec_inA),"wa" (vec_inB));
+}
+
+static void test_xxsldwi_3(void)
+{
+   __asm__ __volatile__ ("xxsldwi         %x0, %x1, %x2, 3" : "=wa" (vec_out): "wa" (vec_inA),"wa" (vec_inB));
+}
+
+static void test_fcfids (void)
+{
+    __asm__ __volatile__ ("fcfids          %0, %1" : "=f" (f17): "d" (f14));
+}
+
+static void test_fcfidus (void)
+{
+    __asm__ __volatile__ ("fcfidus          %0, %1" : "=f" (f17): "d" (f14));
+}
+
+static void test_fcfidu (void)
+{
+    __asm__ __volatile__ ("fcfidu          %0, %1" : "=f" (f17): "d" (f14));
+}
+
+static void test_xsabsdp (void)
+{
+   __asm__ __volatile__ ("xsabsdp          %x0, %x1" : "=wa" (vec_out): "wa" (vec_inB));
+}
+
+static void test_xscpsgndp (void)
+{
+   __asm__ __volatile__ ("xscpsgndp          %x0, %x1, %x2" : "=wa" (vec_out): "wa" (vec_inA),"wa" (vec_inB));
+}
+
+static void test_xsnabsdp (void)
+{
+   __asm__ __volatile__ ("xsnabsdp          %x0, %x1" : "=wa" (vec_out): "wa" (vec_inB));
+}
+
+static void test_xsnegdp (void)
+{
+   __asm__ __volatile__ ("xsnegdp          %x0, %x1" : "=wa" (vec_out): "wa" (vec_inB));
+}
+
+static int do_cmpudp;
+static void test_xscmp (void)
+{
+   if (do_cmpudp)
+      __asm__ __volatile__ ("xscmpudp          cr1, %x0, %x1" : : "wa" (vec_inA),"wa" (vec_inB));
+   else
+      __asm__ __volatile__ ("xscmpodp          cr1, %x0, %x1" : : "wa" (vec_inA),"wa" (vec_inB));
+}
+
+static void test_xsadddp(void)
+{
+   __asm__ __volatile__ ("xsadddp          %x0, %x1, %x2" : "=wa" (vec_out): "wa" (vec_inA),"wa" (vec_inB));
+}
+
+static void test_xsdivdp(void)
+{
+   __asm__ __volatile__ ("xsdivdp          %x0, %x1, %x2" : "=wa" (vec_out): "wa" (vec_inA),"wa" (vec_inB));
+}
+
+static int do_adp;
+static void test_xsmadd(void)
+{
+   if (do_adp)
+      __asm__ __volatile__ ("xsmaddadp          %x0, %x1, %x2" : "+wa" (vec_out): "wa" (vec_inA),"wa" (vec_inB));
+   else
+      __asm__ __volatile__ ("xsmaddmdp          %x0, %x1, %x2" : "+wa" (vec_out): "wa" (vec_inA),"wa" (vec_inB));
+}
+
+static void test_xsmsub(void)
+{
+   if (do_adp)
+      __asm__ __volatile__ ("xsmsubadp          %x0, %x1, %x2" : "+wa" (vec_out): "wa" (vec_inA),"wa" (vec_inB));
+   else
+      __asm__ __volatile__ ("xsmsubmdp          %x0, %x1, %x2" : "+wa" (vec_out): "wa" (vec_inA),"wa" (vec_inB));
+}
+
+static void test_xsnmadd(void)
+{
+   if (do_adp)
+      __asm__ __volatile__ ("xsnmaddadp          %x0, %x1, %x2" : "+wa" (vec_out): "wa" (vec_inA),"wa" (vec_inB));
+   else
+      __asm__ __volatile__ ("xsnmaddmdp          %x0, %x1, %x2" : "+wa" (vec_out): "wa" (vec_inA),"wa" (vec_inB));
+}
+
+static void test_xsmuldp(void)
+{
+   __asm__ __volatile__ ("xsmuldp          %x0, %x1, %x2" : "=wa" (vec_out): "wa" (vec_inA),"wa" (vec_inB));
+}
+
+static void test_xssubdp(void)
+{
+   __asm__ __volatile__ ("xssubdp          %x0, %x1, %x2" : "=wa" (vec_out): "wa" (vec_inA),"wa" (vec_inB));
+}
+
+static void test_xscvdpsxds (void)
+{
+   __asm__ __volatile__ ("xscvdpsxds          %x0, %x1" : "=wa" (vec_out): "wa" (vec_inB));
+}
+
+static void test_xscvsxddp (void)
+{
+   __asm__ __volatile__ ("xscvsxddp          %x0, %x1" : "=wa" (vec_out): "wa" (vec_inB));
+}
+
+static void test_xscvuxddp (void)
+{
+   __asm__ __volatile__ ("xscvuxddp          %x0, %x1" : "=wa" (vec_out): "wa" (vec_inB));
+}
+
+static unsigned int vstg[] __attribute__ ((aligned (16))) = { 0, 0, 0,0,
+                                                              0, 0, 0, 0 };
+
+#define NUM_VSTG_INTS (sizeof vstg/sizeof vstg[0])
+#define NUM_VSTG_VECS (NUM_VSTG_INTS/4)
+
+static unsigned int viargs[] __attribute__ ((aligned (16))) = { 0x01234567,
+                                                                0x89abcdef,
+                                                                0x00112233,
+                                                                0x44556677,
+                                                                0x8899aabb,
+                                                                0x91929394,
+                                                                0xa1a2a3a4,
+                                                                0xb1b2b3b4,
+                                                                0xc1c2c3c4,
+                                                                0xd1d2d3d4,
+                                                                0x7a6b5d3e
+};
+#define NUM_VIARGS_INTS (sizeof viargs/sizeof viargs[0])
+#define NUM_VIARGS_VECS  (NUM_VIARGS_INTS/4)
+
+static ldst_test_t ldst_tests[] = { { &test_lxsdx, "lxsdx", viargs, 0, 2, VSX_LOAD },
+                                     { &test_lxsdx, "lxsdx", viargs, 4, 2, VSX_LOAD },
+                                     { &test_lxvd2x, "lxvd2x", viargs, 0, 4, VSX_LOAD },
+                                     { &test_lxvd2x, "lxvd2x", viargs, 4, 4, VSX_LOAD },
+                                     { &test_lxvdsx, "lxvdsx", viargs, 0, 4, VSX_LOAD_SPLAT },
+                                     { &test_lxvdsx, "lxvdsx", viargs, 4, 4, VSX_LOAD_SPLAT },
+                                     { &test_lxvw4x, "lxvw4x", viargs, 0, 4, VSX_LOAD },
+                                     { &test_lxvw4x, "lxvw4x", viargs, 4, 4, VSX_LOAD },
+                                     { &test_stxsdx, "stxsdx", vstg, 0, 2, VSX_STORE },
+                                     { &test_stxsdx, "stxsdx", vstg, 4, 2, VSX_STORE },
+                                     { &test_stxvd2x, "stxvd2x", vstg, 0, 4, VSX_STORE },
+                                     { &test_stxvd2x, "stxvd2x", vstg, 4, 4, VSX_STORE },
+                                     { &test_stxvw4x, "stxvw4x", vstg, 0, 4, VSX_STORE },
+                                     { &test_stxvw4x, "stxvw4x", vstg, 4, 4, VSX_STORE },
+                                     { NULL, NULL, NULL, 0, 0, 0 } };
+
+static logic_test_t logic_tests[] = { { &test_xxlxor, "xxlxor", VSX_XOR },
+                                      { &test_xxlor, "xxlor", VSX_OR } ,
+                                      { &test_xxlnor, "xxlnor", VSX_NOR },
+                                      { &test_xxland, "xxland", VSX_AND },
+                                      { &test_xxlandc, "xxlandc", VSX_ANDC },
+                                      { NULL, NULL}};
+
+static move_test_t move_tests[] = { { &test_xsabsdp, "xsabsdp", 0, 4, 0x0899aabb91929394ULL },
+                                    { &test_xscpsgndp, "xscpsgndp", 4, 0, 0x8123456789abcdefULL },
+                                    { &test_xsnabsdp, "xsnabsdp", 7, 3, 0xc45566778899aabbULL, },
+                                    { &test_xsnegdp, "xsnegdp", 0, 7, 0x31b2b3b4c1c2c3c4ULL, },
+                                    { NULL, NULL, 0, 0, 0 }
+
+};
+
+static permute_test_t permute_tests[] =
+{
+  { &test_xxmrghw, "xxmrghw", 
+    { 0x11111111, 0x22222222, 0x33333333, 0x44444444 }, /* XA input */
+    { 0x55555555, 0x66666666, 0x77777777, 0x88888888 }, /* XB input */
+    { 0x11111111, 0x55555555, 0x22222222, 0x66666666 }  /* XT expected output */
+  },
+  { &test_xxmrghw, "xxmrghw", 
+    { 0x00112233, 0x44556677, 0x8899aabb, 0xccddeeff }, /* XA input */
+    { 0x11111111, 0x22222222, 0x33333333, 0x44444444 }, /* XB input */
+    { 0x00112233, 0x11111111, 0x44556677, 0x22222222 }  /* XT expected output */
+  },
+  { &test_xxmrglw, "xxmrglw", 
+    { 0x11111111, 0x22222222, 0x33333333, 0x44444444 }, /* XA input */
+    { 0x55555555, 0x66666666, 0x77777777, 0x88888888 }, /* XB input */
+    { 0x33333333, 0x77777777, 0x44444444, 0x88888888 }  /* XT expected output */
+  },
+  { &test_xxmrglw, "xxmrglw", 
+    { 0x00112233, 0x44556677, 0x8899aabb, 0xccddeeff}, /* XA input */
+    { 0x11111111, 0x22222222, 0x33333333, 0x44444444}, /* XB input */
+    { 0x8899aabb, 0x33333333, 0xccddeeff, 0x44444444}  /* XT expected output */
+  },
+  { &test_xxpermdi_00, "xxpermdi DM=00", 
+    { 0x11111111, 0x22222222, 0x33333333, 0x44444444 }, /* XA input */
+    { 0x55555555, 0x66666666, 0x77777777, 0x88888888 }, /* XB input */
+    { 0x11111111, 0x22222222, 0x55555555, 0x66666666 }  /* XT expected output */
+  },
+  { &test_xxpermdi_01, "xxpermdi DM=01", 
+    { 0x11111111, 0x22222222, 0x33333333, 0x44444444 }, /* XA input */
+    { 0x55555555, 0x66666666, 0x77777777, 0x88888888 }, /* XB input */
+    { 0x11111111, 0x22222222, 0x77777777, 0x88888888 }  /* XT expected output */
+  },
+  { &test_xxpermdi_10, "xxpermdi DM=10", 
+    { 0x11111111, 0x22222222, 0x33333333, 0x44444444 }, /* XA input */
+    { 0x55555555, 0x66666666, 0x77777777, 0x88888888 }, /* XB input */
+    { 0x33333333, 0x44444444, 0x55555555, 0x66666666 }  /* XT expected output */
+  },
+  { &test_xxpermdi_11, "xxpermdi DM=11", 
+    { 0x11111111, 0x22222222, 0x33333333, 0x44444444 }, /* XA input */
+    { 0x55555555, 0x66666666, 0x77777777, 0x88888888 }, /* XB input */
+    { 0x33333333, 0x44444444, 0x77777777, 0x88888888 }  /* XT expected output */
+  },
+  { &test_xxsldwi_0, "xxsldwi SHW=0", 
+    { 0x11111111, 0x22222222, 0x33333333, 0x44444444 }, /* XA input */
+    { 0x55555555, 0x66666666, 0x77777777, 0x88888888 }, /* XB input */
+    { 0x11111111, 0x22222222, 0x33333333, 0x44444444 }  /* XT expected output */
+  },
+  { &test_xxsldwi_1, "xxsldwi SHW=1", 
+    { 0x11111111, 0x22222222, 0x33333333, 0x44444444 }, /* XA input */
+    { 0x55555555, 0x66666666, 0x77777777, 0x88888888 }, /* XB input */
+    { 0x22222222, 0x33333333, 0x44444444, 0x55555555 }  /* XT expected output */
+  },
+  { &test_xxsldwi_2, "xxsldwi SHW=2", 
+    { 0x11111111, 0x22222222, 0x33333333, 0x44444444 }, /* XA input */
+    { 0x55555555, 0x66666666, 0x77777777, 0x88888888 }, /* XB input */
+    { 0x33333333, 0x44444444, 0x55555555, 0x66666666 }  /* XT expected output */
+  },
+  { &test_xxsldwi_3, "xxsldwi SHW=3", 
+    { 0x11111111, 0x22222222, 0x33333333, 0x44444444 }, /* XA input */
+    { 0x55555555, 0x66666666, 0x77777777, 0x88888888 }, /* XB input */
+    { 0x44444444, 0x55555555, 0x66666666, 0x77777777 }  /* XT expected output */
+  },
+  { NULL, NULL }
+};
+
+static fp_test_t fp_tests[] = { { &test_fcfids, "fcfids", 1 },
+                                { &test_fcfidus, "fcfidus", 1 },
+                                { &test_fcfidu, "fcfidu", 1 },
+                                { NULL, NULL, 0 },
+
+};
+
+static vx_fp_test_t vx_fp_tests[] = {
+                                     { &test_xscmp, "xscmp", xscmpX_tests, 64, VX_FP_CMP},
+                                     { &test_xsadddp, "xsadddp", xsadddp_tests, 64, VX_FP_OTHER},
+                                     { &test_xsdivdp, "xsdivdp", xsdivdp_tests, 64, VX_FP_OTHER},
+                                     { &test_xsmadd, "xsmadd", xsmaddXdp_tests, 64, VX_FP_SMA},
+                                     { &test_xsmsub, "xsmsub", xsmsubXdp_tests, 64, VX_FP_SMS},
+                                     { &test_xsnmadd, "xsnmadd", xsnmaddXdp_tests, 64, VX_FP_SNMA},
+                                     { & test_xsmuldp, "xsmuldp", xsmuldp_tests, 64, VX_FP_OTHER},
+                                     { & test_xssubdp, "xssubdp", xssubdp_tests, 64, VX_FP_OTHER},
+                                     { NULL, NULL, NULL, 0, 0 }
+};
+
+static xs_conv_test_t xs_conv_tests[] = {
+                                         { &test_xscvdpsxds, "xscvdpsxds", xscvdpsxds_results, 15},
+                                         { &test_xscvsxddp, "xscvsxddp", xscvsxddp_results, 15},
+                                         { &test_xscvuxddp, "xscvuxddp", xscvuxddp_results, 15},
+                                         { NULL, NULL, NULL, 0}
+};
+
+#ifdef __powerpc64__
+static void test_ldbrx(void)
+{
+   int i, equality;
+   HWord_t reg_out;
+   unsigned char * byteIn, * byteOut;
+   r14 = (HWord_t)viargs;
+   // Just try the instruction an arbitrary number of times at different r15 offsets.
+   for (i = 0; i < 3; i++) {
+      int j, k;
+      reg_out = 0;
+      r15 = i * 4;
+      equality = 1;
+      __asm__ __volatile__ ("ldbrx          %0, %1, %2" : "=r" (reg_out): "b" (r14),"r" (r15));
+      byteIn = ((unsigned char *)(r14 + r15));
+      byteOut = (unsigned char *)&reg_out;
+
+      printf("ldbrx:");
+      for (k = 0; k < 7; k++) {
+         printf( " %02x", (byteIn[k]));
+      }
+      printf(" (reverse) =>");
+      for (j = 0; j < 8; j++) {
+         printf( " %02x", (byteOut[j]));
+      }
+      printf("\n");
+      for (j = 0, k = 7; j < 8; j++, k--) {
+         equality &= (byteIn[k] == byteOut[j]);
+      }
+      if (!equality) {
+         printf("FAILED: load with byte reversal is incorrect\n");
+         errors++;
+      }
+   }
+   printf( "\n" );
+}
+
+static void
+test_popcntd(void)
+{
+   uint64_t res;
+   unsigned long long src = 0x9182736405504536ULL;
+   int i, answer = 0;
+   r14 = src;
+   __asm__ __volatile__ ("popcntd          %0, %1" : "=r" (res): "r" (r14));
+   for (i = 0; i < 64; i++) {
+      answer += (r14 & 1ULL);
+      r14 = r14 >> 1;
+   }
+   printf("popcntd: 0x%llx => %d\n", src, (int)res);
+   if (res!= answer) {
+      printf("Error: unexpected result from popcntd\n");
+      errors++;
+   }
+   printf( "\n" );
+}
+#endif
+
+static void
+test_lfiwzx(void)
+{
+   unsigned int i;
+   unsigned int * src;
+   uint64_t reg_out;
+   r14 = (HWord_t)viargs;
+   // Just try the instruction an arbitrary number of times at different r15 offsets.
+   for (i = 0; i < 3; i++) {
+      reg_out = 0;
+      r15 = i * 4;
+      __asm__ __volatile__ ("lfiwzx          %0, %1, %2" : "=d" (reg_out): "b" (r14),"r" (r15));
+      src = ((unsigned int *)(r14 + r15));
+      printf("lfiwzx: %u => %llu.00\n", *src, (unsigned long long)reg_out);
+
+      if (reg_out > 0xFFFFFFFFULL || *src != (unsigned int)reg_out) {
+         printf("FAILED: integer load to FP register is incorrect\n");
+         errors++;
+      }
+   }
+   printf( "\n" );
+}
+
+static void test_vx_fp_ops(void)
+{
+
+   test_func_t func;
+   int k;
+   char * test_name = (char *)malloc(20);
+   k = 0;
+
+   build_special_fargs_table();
+   while ((func = vx_fp_tests[k].test_func)) {
+      int i, condreg, repeat = 0;
+      unsigned int flags;
+      unsigned long long * frap, * frbp, * dst;
+      vx_fp_test_t test_group = vx_fp_tests[k];
+      vx_fp_test_type test_type = test_group.test_type;
+
+      switch (test_type) {
+         case VX_FP_CMP:
+            strcpy(test_name, "xscmp");
+            if (!repeat) {
+               repeat = 1;
+               strcat(test_name, "udp");
+               do_cmpudp = 1;
+            }
+            break;
+         case VX_FP_SMA:
+         case VX_FP_SMS:
+         case VX_FP_SNMA:
+            if (test_type == VX_FP_SMA)
+               strcpy(test_name, "xsmadd");
+            else if (test_type == VX_FP_SMS)
+               strcpy(test_name, "xsmsub");
+            else
+               strcpy(test_name, "xsnmadd");
+            if (!repeat) {
+               repeat = 1;
+               strcat(test_name, "adp");
+               do_adp = 1;
+            }
+            break;
+         case VX_FP_OTHER:
+            strcpy(test_name, test_group.name);
+            break;
+         default:
+            printf("ERROR:  Invalid VX FP test type %d\n", test_type);
+            exit(1);
+      }
+
+again:
+      for (i = 0; i < test_group.num_tests; i++) {
+         unsigned int * inA, * inB, * pv;
+
+         fp_test_args_t aTest = test_group.targs[i];
+         inA = (unsigned int *)&spec_fargs[aTest.fra_idx];
+         inB = (unsigned int *)&spec_fargs[aTest.frb_idx];
+         frap = (unsigned long long *)&spec_fargs[aTest.fra_idx];
+         frbp = (unsigned long long *)&spec_fargs[aTest.frb_idx];
+         // Only need to copy one doubleword into each vector's element 0
+         memcpy(&vec_inA, inA, 8);
+         memcpy(&vec_inB, inB, 8);
+
+         switch (test_type) {
+            case VX_FP_CMP:
+               SET_FPSCR_ZERO;
+               SET_CR_XER_ZERO;
+               (*func)();
+               GET_CR(flags);
+               condreg = (flags & 0x0f000000) >> 24;
+               printf("#%d: %s %016llx <=> %016llx ? %x (CRx)\n", i, test_name, *frap, *frbp, condreg);
+              // printf("\tFRA: %e;  FRB: %e\n", spec_fargs[aTest.fra_idx], spec_fargs[aTest.frb_idx]);
+               if ( condreg != aTest.cr_flags) {
+                  printf("Error: Expected CR flags 0x%x; actual flags: 0x%x\n", aTest.cr_flags, condreg);
+                  errors++;
+               }
+               break;
+            case VX_FP_SMA:
+            case VX_FP_SMS:
+            case VX_FP_SNMA:
+            case VX_FP_OTHER:
+            {
+               int idx;
+               unsigned long long vsr_XT;
+               pv = (unsigned int *)&vec_out;
+               // clear vec_out
+               for (idx = 0; idx < 4; idx++, pv++)
+                  *pv = 0;
+
+               if (test_type != VX_FP_OTHER) {
+                  /* Then we need a third src argument, which is stored in element 0 of
+                   * VSX[XT] -- i.e., vec_out.  For the xs<ZZZ>mdp cases, VSX[XT] holds
+                   * src3 and VSX[XB] holds src2; for the xs<ZZZ>adp cases, VSX[XT] holds
+                   * src2 and VSX[XB] holds src3.  The fp_test_args_t that holds the test
+                   * data (input args, result) contain only two inputs, so I arbitrarily
+                   * use spec_fargs elements 4 and 14 (alternating) for the third source
+                   * argument.  We can use the same input data for a given pair of
+                   * adp/mdp-type instructions by swapping the src2 and src3 arguments; thus
+                   * the expected result should be the same.
+                   */
+                  int extra_arg_idx;
+                  if (i % 2)
+                     extra_arg_idx = 4;
+                  else
+                     extra_arg_idx = 14;
+
+                     //memcpy(&vec_out, &spec_fargs[14], 8);
+
+                  if (repeat) {
+                     /* We're on the first time through of one of the VX_FP_SMx
+                      * test types, meaning we're testing a xs<ZZZ>adp case, thus we
+                      * have to swap inputs as described above:
+                      *    src2 <= VSX[XT]
+                      *    src3 <= VSX[XB]
+                      */
+                     memcpy(&vec_out, inB, 8);  // src2
+                     memcpy(&vec_inB, &spec_fargs[extra_arg_idx], 8);  //src3
+                     frbp = (unsigned long long *)&spec_fargs[extra_arg_idx];
+                  } else {
+                     // Don't need to init src2, as it's done before the switch()
+                     memcpy(&vec_out, &spec_fargs[extra_arg_idx], 8);  //src3
+                  }
+                  memcpy(&vsr_XT, &vec_out, 8);
+               }
+
+               (*func)();
+               dst = (unsigned long long *) &vec_out;
+               if (test_type == VX_FP_OTHER)
+                  printf("#%d: %s %016llx %016llx = %016llx\n", i, test_name, *frap, *frbp, *dst);
+               else
+                  printf( "#%d: %s %016llx %016llx %016llx = %016llx\n", i,
+                          test_name, vsr_XT, *frap, *frbp, *dst );
+
+               if ( *dst != aTest.dp_bin_result) {
+                  printf("Error: Expected result %016llx; actual result %016llx\n", aTest.dp_bin_result, *dst);
+                  errors++;
+               }
+               /*
+              {
+                  // Debug code.  Keep this block commented out except when debugging.
+                  double result, expected;
+                  memcpy(&result, dst, 8);
+                  memcpy(&expected, &aTest.dp_bin_result, 8);
+                  printf( "\tFRA + FRB: %e + %e: Expected = %e; Actual = %e\n",
+                          spec_fargs[aTest.fra_idx], spec_fargs[aTest.frb_idx],
+                          expected, result );
+               }
+              */
+               break;
+            }
+         }
+
+
+      }
+      printf( "\n" );
+
+      if (repeat) {
+         repeat = 0;
+         switch (test_type) {
+            case VX_FP_CMP:
+               strcpy(test_name, "xscmp");
+               strcat(test_name, "odp");
+               do_cmpudp = 0;
+               break;
+            case VX_FP_SMA:
+            case VX_FP_SMS:
+            case VX_FP_SNMA:
+               if (test_type == VX_FP_SMA)
+                  strcpy(test_name, "xsmadd");
+               else if (test_type == VX_FP_SMS)
+                  strcpy(test_name, "xsmsub");
+               else
+                  strcpy(test_name, "xsnmadd");
+               strcat(test_name, "mdp");
+               do_adp = 0;
+               break;
+            case VX_FP_OTHER:
+               break;
+         }
+         goto again;
+      }
+      k++;
+   }
+   printf( "\n" );
+   free(test_name);
+}
+
+static void test_xs_conv_ops(void)
+{
+
+   test_func_t func;
+   int k = 0;
+
+   build_special_fargs_table();
+   while ((func = xs_conv_tests[k].test_func)) {
+      int i;
+      unsigned long long * frbp, * dst;
+      xs_conv_test_t test_group = xs_conv_tests[k];
+      for (i = 0; i < test_group.num_tests; i++) {
+         unsigned int * inB, * pv;
+         int idx;
+         unsigned long long exp_result = test_group.results[i];
+         inB = (unsigned int *)&spec_fargs[i];
+         frbp = (unsigned long long *)&spec_fargs[i];
+         memcpy(&vec_inB, inB, 8);
+         pv = (unsigned int *)&vec_out;
+         // clear vec_out
+         for (idx = 0; idx < 4; idx++, pv++)
+            *pv = 0;
+         (*func)();
+         dst = (unsigned long long *) &vec_out;
+         printf("#%d: %s %016llx => %016llx\n", i, test_group.name, *frbp, *dst);
+
+         if ( *dst != exp_result) {
+            printf("Error: Expected result %016llx; actual result %016llx\n", exp_result, *dst);
+            errors++;
+         }
+      }
+      k++;
+      printf("\n");
+   }
+   printf( "\n" );
+}
+
+static void do_load_test(ldst_test_t loadTest)
+{
+   test_func_t func;
+   unsigned int *src, *dst;
+   int splat = loadTest.type == VSX_LOAD_SPLAT ? 1: 0;
+   int i, j, m, equality;
+   i = j = 0;
+
+   func = loadTest.test_func;
+   for (i = 0, r14 = (HWord_t) loadTest.base_addr; i < NUM_VIARGS_VECS; i++) {
+      int again;
+      j = 0;
+       r14 += i * 16;
+      do {
+         unsigned int * pv = (unsigned int *)&vec_out;
+         int idx;
+         // clear vec_out
+         for (idx = 0; idx < 4; idx++, pv+=idx)
+            *pv = 0;
+
+         again = 0;
+         r15 = j;
+
+         // execute test insn
+         (*func)();
+
+         src = (unsigned int*) (((unsigned char *)r14) + j);
+         dst = (unsigned int*) &vec_out;
+
+         printf( "%s:", loadTest.name);
+         for (m = 0; m < loadTest.num_words_to_process; m++) {
+            printf( " %08x", src[splat ? m % 2 : m]);
+         }
+         printf( " =>");
+         for (m = 0; m < loadTest.num_words_to_process; m++) {
+            printf( " %08x", dst[m]);
+         }
+         printf("\n");
+         equality = 1;
+         for (m = 0; m < loadTest.num_words_to_process; m++) {
+            equality = equality && (src[splat ? m % 2 : m] == dst[m]);
+         }
+
+         if (!equality) {
+            printf("FAILED: loaded vector is incorrect\n");
+            errors++;
+         }
+
+         if (j == 0 && loadTest.offset) {
+            again = 1;
+            j += loadTest.offset;
+         }
+      }
+      while (again);
+   }
+}
+
+static void
+do_store_test ( ldst_test_t storeTest )
+{
+   test_func_t func;
+   unsigned int *src, *dst;
+   int i, j, m, equality;
+   i = j = 0;
+
+   func = storeTest.test_func;
+   r14 = (HWord_t) storeTest.base_addr;
+   r15 = (HWord_t) storeTest.offset;
+   unsigned int * pv = (unsigned int *) storeTest.base_addr;
+   int idx;
+   // clear out storage destination
+   for (idx = 0; idx < 4; idx++, pv += idx)
+      *pv = 0;
+
+   memcpy(&vec_inA, &viargs[0], sizeof(vector unsigned char));
+
+   // execute test insn
+   (*func)();
+   src = &viargs[0];
+   dst = (unsigned int*) (((unsigned char *) r14) + storeTest.offset);
+
+   printf( "%s:", storeTest.name );
+   for (m = 0; m < storeTest.num_words_to_process; m++) {
+      printf( " %08x", src[m] );
+   }
+   printf( " =>" );
+   for (m = 0; m < storeTest.num_words_to_process; m++) {
+      printf( " %08x", dst[m] );
+   }
+   printf( "\n" );
+   equality = 1;
+   for (m = 0; m < storeTest.num_words_to_process; m++) {
+      equality = equality && (src[m] == dst[m]);
+   }
+
+   if (!equality) {
+      printf( "FAILED: vector store result is incorrect\n" );
+      errors++;
+   }
+
+}
+
+
+static void test_ldst(void)
+{
+   int k = 0;
+
+   while (ldst_tests[k].test_func) {
+      if (ldst_tests[k].type == VSX_STORE)
+         do_store_test(ldst_tests[k]);
+      else
+         do_load_test(ldst_tests[k]);
+      k++;
+      printf("\n");
+   }
+}
+
+static void test_ftdiv(void)
+{
+   int i, num_tests, crx;
+   unsigned int flags;
+   unsigned long long * frap, * frbp;
+   build_special_fargs_table();
+
+   num_tests = sizeof ftdiv_tests/sizeof ftdiv_tests[0];
+
+   for (i = 0; i < num_tests; i++) {
+      ftdiv_test_args_t aTest = ftdiv_tests[i];
+      f14 = spec_fargs[aTest.fra_idx];
+      f15 = spec_fargs[aTest.frb_idx];
+      frap = (unsigned long long *)&spec_fargs[aTest.fra_idx];
+      frbp = (unsigned long long *)&spec_fargs[aTest.frb_idx];
+      SET_FPSCR_ZERO;
+      SET_CR_XER_ZERO;
+      __asm__ __volatile__ ("ftdiv           cr1, %0, %1" : : "d" (f14), "d" (f15));
+      GET_CR(flags);
+      crx = (flags & 0x0f000000) >> 24;
+      printf( "ftdiv: %016llx <=> %016llx ? %x (CRx)\n", *frap, *frbp, crx);
+//      printf("\tFRA: %e;  FRB: %e\n", f14, f15);
+      if ( crx != aTest.cr_flags) {
+         printf("Error: Expected CR flags 0x%x; actual flags: 0x%x\n", aTest.cr_flags, crx);
+         errors++;
+      }
+   }
+   printf( "\n" );
+}
+
+
+static void test_p7_fpops ( void )
+{
+   int k = 0;
+   test_func_t func;
+
+   build_fargs_table();
+   while ((func = fp_tests[k].test_func)) {
+      float res;
+      double resd;
+      unsigned long long u0;
+      int i;
+      int res32 = strcmp(fp_tests[k].name, "fcfidu");
+
+      for (i = 0; i < nb_fargs; i++) {
+         u0 = *(unsigned long long *) (&fargs[i]);
+         f14 = fargs[i];
+         (*func)();
+         if (res32) {
+            res = f17;
+            printf( "%s %016llx => (raw sp) %08x)",
+                    fp_tests[k].name, u0, *((unsigned int *)&res));
+         } else {
+            resd = f17;
+            printf( "%s %016llx => (raw sp) %016llx)",
+                    fp_tests[k].name, u0, *(unsigned long long *)(&resd));
+         }
+         printf( "\n" );
+      }
+
+      k++;
+      printf( "\n" );
+   }
+}
+
+static void test_vsx_logic(void)
+{
+   logic_test_t aTest;
+   test_func_t func;
+   int equality, k;
+   k = 0;
+
+   while ((func = logic_tests[k].test_func)) {
+      unsigned int * pv;
+      int startA, startB;
+      unsigned int * inA, * inB, * dst;
+      int idx, i;
+      startA = 0;
+      aTest = logic_tests[k];
+      for (i = 0; i <= (NUM_VIARGS_INTS - (NUM_VIARGS_VECS * sizeof(int))); i++, startA++) {
+         startB = startA + 4;
+         pv = (unsigned int *)&vec_out;
+         inA = &viargs[startA];
+         inB = &viargs[startB];
+         memcpy(&vec_inA, inA, sizeof(vector unsigned char));
+         memcpy(&vec_inB, inB, sizeof(vector unsigned char));
+         // clear vec_out
+         for (idx = 0; idx < 4; idx++, pv++)
+            *pv = 0;
+
+         // execute test insn
+         (*func)();
+         dst = (unsigned int*) &vec_out;
+
+         printf( "%s:", aTest.name);
+         printf( " %08x %08x %08x %08x %s", inA[0], inA[1], inA[2], inA[3], aTest.name);
+         printf( " %08x %08x %08x %08x", inB[0], inB[1], inB[2], inB[3]);
+         printf(" => %08x %08x %08x %08x\n", dst[0], dst[1], dst[2], dst[3]);
+
+         equality = 1;
+         for (idx = 0; idx < 4; idx++) {
+            switch (aTest.op) {
+               case VSX_AND:
+                  equality &= (dst[idx] == (inA[idx] & inB[idx]));
+                  break;
+               case VSX_ANDC:
+                  equality &= (dst[idx] == (inA[idx] & ~inB[idx]));
+                  break;
+               case VSX_NOR:
+                  equality &= (dst[idx] == ~(inA[idx] | inB[idx]));
+                  break;
+               case VSX_XOR:
+                  equality &= (dst[idx] == (inA[idx] ^ inB[idx]));
+                  break;
+               case VSX_OR:
+                  equality &= (dst[idx] == (inA[idx] | inB[idx]));
+                  break;
+               default:
+                  fprintf(stderr, "Error in test_vsx_logic(): unknown VSX logical op %d\n", aTest.op);
+                  exit(1);
+            }
+         }
+         if (!equality) {
+            printf( "FAILED: vector out is incorrect\n" );
+            errors++;
+         }
+      }
+      k++;
+   }
+   printf( "\n" );
+}
+
+static void test_move_ops (void)
+{
+   move_test_t aTest;
+   test_func_t func;
+   int equality, k;
+   k = 0;
+
+   while ((func = move_tests[k].test_func)) {
+      unsigned int * pv;
+      int startA, startB;
+      unsigned int * inA, * inB, * dst;
+      unsigned long long exp_out;
+      int idx;
+      aTest = move_tests[k];
+      exp_out = aTest.expected_result;
+      startA = aTest.xa_idx;
+      startB = aTest.xb_idx;
+      pv = (unsigned int *)&vec_out;
+      inA = &viargs[startA];
+      inB = &viargs[startB];
+      memcpy(&vec_inA, inA, sizeof(vector unsigned char));
+      memcpy(&vec_inB, inB, sizeof(vector unsigned char));
+      // clear vec_out
+      for (idx = 0; idx < 4; idx++, pv++)
+         *pv = 0;
+
+      // execute test insn
+      (*func)();
+      dst = (unsigned int*) &vec_out;
+
+      printf( "%s:", aTest.name);
+      printf( " %08x %08x %s", inA[0], inA[1], aTest.name);
+      printf( " %08x %08xx", inB[0], inB[1]);
+      printf(" => %08x %08x\n", dst[0], dst[1]);
+
+      equality = 1;
+      pv = (unsigned int *)&exp_out;
+      for (idx = 0; idx < 2; idx++) {
+         equality &= (dst[idx] == pv[idx]);
+      }
+      if (!equality) {
+         printf( "FAILED: vector out is incorrect\n" );
+         errors++;
+      }
+      k++;
+      printf( "\n" );
+   }
+}
+
+static void test_permute_ops (void)
+{
+  permute_test_t *aTest;
+  unsigned int *dst = (unsigned int *) &vec_out;
+
+  for (aTest = &(permute_tests[0]); aTest->test_func != NULL; aTest++)
+    {
+      /* Grab test input and clear output vector.  */
+      memcpy(&vec_inA, aTest->xa, sizeof(vec_inA));
+      memcpy(&vec_inB, aTest->xb, sizeof(vec_inB));
+      memset(dst, 0, sizeof(vec_out));
+
+      /* execute test insn */
+      aTest->test_func();
+
+      printf( "%s:\n", aTest->name);
+      printf( "        XA[%08x,%08x,%08x,%08x]\n",
+              aTest->xa[0], aTest->xa[1], aTest->xa[2], aTest->xa[3]);
+      printf( "        XB[%08x,%08x,%08x,%08x]\n",
+              aTest->xb[0], aTest->xb[1], aTest->xb[2], aTest->xb[3]);
+      printf( "   =>   XT[%08x,%08x,%08x,%08x]\n",
+              dst[0], dst[1], dst[2], dst[3]);
+
+      if (memcmp (dst, &aTest->expected_output, sizeof(vec_out)))
+       {
+         printf( "FAILED: vector out is incorrect\n" );
+         errors++;
+       }
+    }
+  printf( "\n" );
+}
+
+static test_table_t all_tests[] = { { &test_ldst,
+                                       "Test VSX load/store instructions" },
+                                     { &test_vsx_logic,
+                                       "Test VSX logic instructions" },
+#ifdef __powerpc64__
+                                     { &test_ldbrx,
+                                       "Test ldbrx instruction" },
+                                     { &test_popcntd,
+                                       "Test popcntd instruction" },
+#endif
+                                     { &test_lfiwzx,
+                                       "Test lfiwzx instruction" },
+                                     { &test_p7_fpops,
+                                       "Test P7 floating point convert instructions"},
+                                     { &test_ftdiv,
+                                       "Test ftdiv instruction" },
+                                     { &test_move_ops,
+                                       "Test VSX move instructions"},
+                                     { &test_permute_ops,
+                                       "Test VSX permute instructions"},
+                                     { &test_vx_fp_ops,
+                                       "Test VSX floating point instructions"},
+                                     { &test_xs_conv_ops,
+                                       "Test VSX scalar integer conversion instructions" },
+                                     { NULL, NULL }
+};
+#endif // HAS_VSX
+
+int main(int argc, char *argv[])
+{
+#ifdef HAS_VSX
+
+   test_table_t aTest;
+   test_func_t func;
+   int i = 0;
+
+   while ((func = all_tests[i].test_category)) {
+      aTest = all_tests[i];
+      printf( "%s\n", aTest.name );
+      (*func)();
+      i++;
+   }
+   if (errors)
+      printf("Testcase FAILED with %d errors \n", errors);
+   else
+      printf("Testcase PASSED\n");
+
+#endif // HAS _VSX
+
+   return 0;
+}
--- valgrind-3.6.0/none/tests/ppc32/Makefile.am	(revision 11696)
+++ valgrind-3.6.0/none/tests/ppc32/Makefile.am	(revision 11700)
@@ -23,13 +23,15 @@ EXTRA_DIST = \
 	tw.stderr.exp tw.stdout.exp tw.vgtest \
 	xlc_dbl_u32.stderr.exp xlc_dbl_u32.stdout.exp xlc_dbl_u32.vgtest \
 	power5+_round.stderr.exp power5+_round.stdout.exp power5+_round.vgtest \
-	power6_bcmp.stderr.exp power6_bcmp.stdout.exp power6_bcmp.vgtest
+	power6_bcmp.stderr.exp power6_bcmp.stdout.exp power6_bcmp.vgtest \
+	test_isa_2_06_part1.stderr.exp  test_isa_2_06_part1.stdout.exp  test_isa_2_06_part1.vgtest
 
 check_PROGRAMS = \
 	bug129390-ppc32 \
 	bug139050-ppc32 \
 	ldstrev lsw jm-insns mftocrf mcrfs round test_fx test_gx \
-	testVMX twi tw xlc_dbl_u32 power5+_round power6_bcmp
+	testVMX twi tw xlc_dbl_u32 power5+_round power6_bcmp \
+	test_isa_2_06_part1
 
 AM_CFLAGS    += @FLAG_M32@
 AM_CXXFLAGS  += @FLAG_M32@
@@ -41,8 +43,20 @@ else
 ALTIVEC_FLAG =
 endif
 
+if HAS_VSX
+BUILD_FLAG_VSX = -mvsx
+VSX_FLAG = -DHAS_VSX
+else
+BUILD_FLAG_VSX =
+VSX_FLAG =
+endif
+
 jm_insns_CFLAGS = $(AM_CFLAGS) -Winline -Wall -O -g -mregnames -maltivec \
 			@FLAG_M32@ $(ALTIVEC_FLAG)
 
 testVMX_CFLAGS  = $(AM_CFLAGS) -O -g -Wall -maltivec -mabi=altivec -DALTIVEC \
 			-DGCC_COMPILER @FLAG_M32@
+
+test_isa_2_06_part1_CFLAGS = $(AM_CFLAGS) -Winline -Wall -O -g -mregnames $(VSX_FLAG) \
+			@FLAG_M32@ $(ALTIVEC_FLAG) $(BUILD_FLAG_VSX)
+
--- valgrind-3.6.0/none/tests/ppc64/test_isa_2_06_part1.stdout.exp	(revision 0)
+++ valgrind-3.6.0/none/tests/ppc64/test_isa_2_06_part1.stdout.exp	(revision 11700)
@@ -0,0 +1,1031 @@
+Test VSX load/store instructions
+lxsdx: 01234567 89abcdef => 01234567 89abcdef
+lxsdx: 8899aabb 91929394 => 8899aabb 91929394
+
+lxsdx: 01234567 89abcdef => 01234567 89abcdef
+lxsdx: 89abcdef 00112233 => 89abcdef 00112233
+lxsdx: 8899aabb 91929394 => 8899aabb 91929394
+lxsdx: 91929394 a1a2a3a4 => 91929394 a1a2a3a4
+
+lxvd2x: 01234567 89abcdef 00112233 44556677 => 01234567 89abcdef 00112233 44556677
+lxvd2x: 8899aabb 91929394 a1a2a3a4 b1b2b3b4 => 8899aabb 91929394 a1a2a3a4 b1b2b3b4
+
+lxvd2x: 01234567 89abcdef 00112233 44556677 => 01234567 89abcdef 00112233 44556677
+lxvd2x: 89abcdef 00112233 44556677 8899aabb => 89abcdef 00112233 44556677 8899aabb
+lxvd2x: 8899aabb 91929394 a1a2a3a4 b1b2b3b4 => 8899aabb 91929394 a1a2a3a4 b1b2b3b4
+lxvd2x: 91929394 a1a2a3a4 b1b2b3b4 c1c2c3c4 => 91929394 a1a2a3a4 b1b2b3b4 c1c2c3c4
+
+lxvdsx: 01234567 89abcdef 01234567 89abcdef => 01234567 89abcdef 01234567 89abcdef
+lxvdsx: 8899aabb 91929394 8899aabb 91929394 => 8899aabb 91929394 8899aabb 91929394
+
+lxvdsx: 01234567 89abcdef 01234567 89abcdef => 01234567 89abcdef 01234567 89abcdef
+lxvdsx: 89abcdef 00112233 89abcdef 00112233 => 89abcdef 00112233 89abcdef 00112233
+lxvdsx: 8899aabb 91929394 8899aabb 91929394 => 8899aabb 91929394 8899aabb 91929394
+lxvdsx: 91929394 a1a2a3a4 91929394 a1a2a3a4 => 91929394 a1a2a3a4 91929394 a1a2a3a4
+
+lxvw4x: 01234567 89abcdef 00112233 44556677 => 01234567 89abcdef 00112233 44556677
+lxvw4x: 8899aabb 91929394 a1a2a3a4 b1b2b3b4 => 8899aabb 91929394 a1a2a3a4 b1b2b3b4
+
+lxvw4x: 01234567 89abcdef 00112233 44556677 => 01234567 89abcdef 00112233 44556677
+lxvw4x: 89abcdef 00112233 44556677 8899aabb => 89abcdef 00112233 44556677 8899aabb
+lxvw4x: 8899aabb 91929394 a1a2a3a4 b1b2b3b4 => 8899aabb 91929394 a1a2a3a4 b1b2b3b4
+lxvw4x: 91929394 a1a2a3a4 b1b2b3b4 c1c2c3c4 => 91929394 a1a2a3a4 b1b2b3b4 c1c2c3c4
+
+stxsdx: 01234567 89abcdef => 01234567 89abcdef
+
+stxsdx: 01234567 89abcdef => 01234567 89abcdef
+
+stxvd2x: 01234567 89abcdef 00112233 44556677 => 01234567 89abcdef 00112233 44556677
+
+stxvd2x: 01234567 89abcdef 00112233 44556677 => 01234567 89abcdef 00112233 44556677
+
+stxvw4x: 01234567 89abcdef 00112233 44556677 => 01234567 89abcdef 00112233 44556677
+
+stxvw4x: 01234567 89abcdef 00112233 44556677 => 01234567 89abcdef 00112233 44556677
+
+Test VSX logic instructions
+xxlxor: 01234567 89abcdef 00112233 44556677 xxlxor 8899aabb 91929394 a1a2a3a4 b1b2b3b4 => 89baefdc 18395e7b a1b38197 f5e7d5c3
+xxlxor: 89abcdef 00112233 44556677 8899aabb xxlxor 91929394 a1a2a3a4 b1b2b3b4 c1c2c3c4 => 18395e7b a1b38197 f5e7d5c3 495b697f
+xxlxor: 00112233 44556677 8899aabb 91929394 xxlxor a1a2a3a4 b1b2b3b4 c1c2c3c4 d1d2d3d4 => a1b38197 f5e7d5c3 495b697f 40404040
+xxlxor: 44556677 8899aabb 91929394 a1a2a3a4 xxlxor b1b2b3b4 c1c2c3c4 d1d2d3d4 7a6b5d3e => f5e7d5c3 495b697f 40404040 dbc9fe9a
+xxlor: 01234567 89abcdef 00112233 44556677 xxlor 8899aabb 91929394 a1a2a3a4 b1b2b3b4 => 89bbefff 99bbdfff a1b3a3b7 f5f7f7f7
+xxlor: 89abcdef 00112233 44556677 8899aabb xxlor 91929394 a1a2a3a4 b1b2b3b4 c1c2c3c4 => 99bbdfff a1b3a3b7 f5f7f7f7 c9dbebff
+xxlor: 00112233 44556677 8899aabb 91929394 xxlor a1a2a3a4 b1b2b3b4 c1c2c3c4 d1d2d3d4 => a1b3a3b7 f5f7f7f7 c9dbebff d1d2d3d4
+xxlor: 44556677 8899aabb 91929394 a1a2a3a4 xxlor b1b2b3b4 c1c2c3c4 d1d2d3d4 7a6b5d3e => f5f7f7f7 c9dbebff d1d2d3d4 fbebffbe
+xxlnor: 01234567 89abcdef 00112233 44556677 xxlnor 8899aabb 91929394 a1a2a3a4 b1b2b3b4 => 76441000 66442000 5e4c5c48 0a080808
+xxlnor: 89abcdef 00112233 44556677 8899aabb xxlnor 91929394 a1a2a3a4 b1b2b3b4 c1c2c3c4 => 66442000 5e4c5c48 0a080808 36241400
+xxlnor: 00112233 44556677 8899aabb 91929394 xxlnor a1a2a3a4 b1b2b3b4 c1c2c3c4 d1d2d3d4 => 5e4c5c48 0a080808 36241400 2e2d2c2b
+xxlnor: 44556677 8899aabb 91929394 a1a2a3a4 xxlnor b1b2b3b4 c1c2c3c4 d1d2d3d4 7a6b5d3e => 0a080808 36241400 2e2d2c2b 04140041
+xxland: 01234567 89abcdef 00112233 44556677 xxland 8899aabb 91929394 a1a2a3a4 b1b2b3b4 => 00010023 81828184 00002220 00102234
+xxland: 89abcdef 00112233 44556677 8899aabb xxland 91929394 a1a2a3a4 b1b2b3b4 c1c2c3c4 => 81828184 00002220 00102234 80808280
+xxland: 00112233 44556677 8899aabb 91929394 xxland a1a2a3a4 b1b2b3b4 c1c2c3c4 d1d2d3d4 => 00002220 00102234 80808280 91929394
+xxland: 44556677 8899aabb 91929394 a1a2a3a4 xxland b1b2b3b4 c1c2c3c4 d1d2d3d4 7a6b5d3e => 00102234 80808280 91929394 20220124
+xxlandc: 01234567 89abcdef 00112233 44556677 xxlandc 8899aabb 91929394 a1a2a3a4 b1b2b3b4 => 01224544 08294c6b 00110013 44454443
+xxlandc: 89abcdef 00112233 44556677 8899aabb xxlandc 91929394 a1a2a3a4 b1b2b3b4 c1c2c3c4 => 08294c6b 00110013 44454443 0819283b
+xxlandc: 00112233 44556677 8899aabb 91929394 xxlandc a1a2a3a4 b1b2b3b4 c1c2c3c4 d1d2d3d4 => 00110013 44454443 0819283b 00000000
+xxlandc: 44556677 8899aabb 91929394 a1a2a3a4 xxlandc b1b2b3b4 c1c2c3c4 d1d2d3d4 7a6b5d3e => 44454443 0819283b 00000000 8180a280
+
+Test ldbrx instruction
+ldbrx: 01 23 45 67 89 ab cd (reverse) => ef cd ab 89 67 45 23 01
+ldbrx: 89 ab cd ef 00 11 22 (reverse) => 33 22 11 00 ef cd ab 89
+ldbrx: 00 11 22 33 44 55 66 (reverse) => 77 66 55 44 33 22 11 00
+
+Test popcntd instruction
+popcntd: 0x9182736405504536 => 24
+
+Test lfiwzx instruction
+lfiwzx: 19088743 => 19088743.00
+lfiwzx: 2309737967 => 2309737967.00
+lfiwzx: 1122867 => 1122867.00
+
+Test P7 floating point convert instructions
+fcfids 0010000000000001 => (raw sp) 59800000)
+fcfids 00100094e0000359 => (raw sp) 598004a7)
+fcfids 3fe0000000000001 => (raw sp) 5e7f8000)
+fcfids 3fe00094e0000359 => (raw sp) 5e7f8002)
+fcfids 8010000000000001 => (raw sp) deffe000)
+fcfids 80100094e0000359 => (raw sp) deffdfff)
+fcfids bfe0000000000001 => (raw sp) de804000)
+fcfids bfe00094e0000359 => (raw sp) de803fff)
+fcfids 0020000000000b01 => (raw sp) 5a000000)
+fcfids 00000000203f0b3d => (raw sp) 4e00fc2d)
+fcfids 00000000005a203d => (raw sp) 4ab4407a)
+fcfids 8020000000000b01 => (raw sp) deffc000)
+fcfids 80000000203f0b3d => (raw sp) df000000)
+
+fcfidus 0010000000000001 => (raw sp) 59800000)
+fcfidus 00100094e0000359 => (raw sp) 598004a7)
+fcfidus 3fe0000000000001 => (raw sp) 5e7f8000)
+fcfidus 3fe00094e0000359 => (raw sp) 5e7f8002)
+fcfidus 8010000000000001 => (raw sp) 5f001000)
+fcfidus 80100094e0000359 => (raw sp) 5f001001)
+fcfidus bfe0000000000001 => (raw sp) 5f3fe000)
+fcfidus bfe00094e0000359 => (raw sp) 5f3fe001)
+fcfidus 0020000000000b01 => (raw sp) 5a000000)
+fcfidus 00000000203f0b3d => (raw sp) 4e00fc2d)
+fcfidus 00000000005a203d => (raw sp) 4ab4407a)
+fcfidus 8020000000000b01 => (raw sp) 5f002000)
+fcfidus 80000000203f0b3d => (raw sp) 5f000000)
+
+fcfidu 0010000000000001 => (raw sp) 4330000000000001)
+fcfidu 00100094e0000359 => (raw sp) 43300094e0000359)
+fcfidu 3fe0000000000001 => (raw sp) 43cff00000000000)
+fcfidu 3fe00094e0000359 => (raw sp) 43cff0004a700002)
+fcfidu 8010000000000001 => (raw sp) 43e0020000000000)
+fcfidu 80100094e0000359 => (raw sp) 43e00200129c0000)
+fcfidu bfe0000000000001 => (raw sp) 43e7fc0000000000)
+fcfidu bfe00094e0000359 => (raw sp) 43e7fc00129c0000)
+fcfidu 0020000000000b01 => (raw sp) 4340000000000580)
+fcfidu 00000000203f0b3d => (raw sp) 41c01f859e800000)
+fcfidu 00000000005a203d => (raw sp) 4156880f40000000)
+fcfidu 8020000000000b01 => (raw sp) 43e0040000000001)
+fcfidu 80000000203f0b3d => (raw sp) 43e00000000407e1)
+
+Test ftdiv instruction
+ftdiv: 3fd8000000000000 <=> 404f000000000000 ? 8 (CRx)
+ftdiv: 7ff7ffffffffffff <=> 404f000000000000 ? a (CRx)
+ftdiv: 404f000000000000 <=> fff8000000000000 ? a (CRx)
+ftdiv: 3fd8000000000000 <=> 0018000000b77501 ? a (CRx)
+ftdiv: 404f000000000000 <=> 7fe800000000051b ? a (CRx)
+ftdiv: 7fe800000000051b <=> 3fd8000000000000 ? a (CRx)
+ftdiv: 3fd8000000000000 <=> 7fe800000000051b ? a (CRx)
+ftdiv: 0123214569900000 <=> 3fd8000000000000 ? a (CRx)
+ftdiv: 7ff0000000000000 <=> 404f000000000000 ? e (CRx)
+ftdiv: fff0000000000000 <=> 404f000000000000 ? e (CRx)
+ftdiv: 404f000000000000 <=> 7ff0000000000000 ? e (CRx)
+ftdiv: 3fd8000000000000 <=> 8008340000078000 ? e (CRx)
+ftdiv: 0000000000000000 <=> 0000000000000000 ? e (CRx)
+ftdiv: 0000000000000000 <=> 8000000000000000 ? e (CRx)
+
+Test VSX move instructions
+xsabsdp: 01234567 89abcdef xsabsdp 8899aabb 91929394x => 0899aabb 91929394
+
+xscpsgndp: 8899aabb 91929394 xscpsgndp 01234567 89abcdefx => 81234567 89abcdef
+
+xsnabsdp: b1b2b3b4 c1c2c3c4 xsnabsdp 44556677 8899aabbx => c4556677 8899aabb
+
+xsnegdp: 01234567 89abcdef xsnegdp b1b2b3b4 c1c2c3c4x => 31b2b3b4 c1c2c3c4
+
+Test VSX permute instructions
+xxmrghw:
+        XA[11111111,22222222,33333333,44444444]
+        XB[55555555,66666666,77777777,88888888]
+   =>   XT[11111111,55555555,22222222,66666666]
+xxmrghw:
+        XA[00112233,44556677,8899aabb,ccddeeff]
+        XB[11111111,22222222,33333333,44444444]
+   =>   XT[00112233,11111111,44556677,22222222]
+xxmrglw:
+        XA[11111111,22222222,33333333,44444444]
+        XB[55555555,66666666,77777777,88888888]
+   =>   XT[33333333,77777777,44444444,88888888]
+xxmrglw:
+        XA[00112233,44556677,8899aabb,ccddeeff]
+        XB[11111111,22222222,33333333,44444444]
+   =>   XT[8899aabb,33333333,ccddeeff,44444444]
+xxpermdi DM=00:
+        XA[11111111,22222222,33333333,44444444]
+        XB[55555555,66666666,77777777,88888888]
+   =>   XT[11111111,22222222,55555555,66666666]
+xxpermdi DM=01:
+        XA[11111111,22222222,33333333,44444444]
+        XB[55555555,66666666,77777777,88888888]
+   =>   XT[11111111,22222222,77777777,88888888]
+xxpermdi DM=10:
+        XA[11111111,22222222,33333333,44444444]
+        XB[55555555,66666666,77777777,88888888]
+   =>   XT[33333333,44444444,55555555,66666666]
+xxpermdi DM=11:
+        XA[11111111,22222222,33333333,44444444]
+        XB[55555555,66666666,77777777,88888888]
+   =>   XT[33333333,44444444,77777777,88888888]
+xxsldwi SHW=0:
+        XA[11111111,22222222,33333333,44444444]
+        XB[55555555,66666666,77777777,88888888]
+   =>   XT[11111111,22222222,33333333,44444444]
+xxsldwi SHW=1:
+        XA[11111111,22222222,33333333,44444444]
+        XB[55555555,66666666,77777777,88888888]
+   =>   XT[22222222,33333333,44444444,55555555]
+xxsldwi SHW=2:
+        XA[11111111,22222222,33333333,44444444]
+        XB[55555555,66666666,77777777,88888888]
+   =>   XT[33333333,44444444,55555555,66666666]
+xxsldwi SHW=3:
+        XA[11111111,22222222,33333333,44444444]
+        XB[55555555,66666666,77777777,88888888]
+   =>   XT[44444444,55555555,66666666,77777777]
+
+Test VSX floating point instructions
+#0: xscmpudp fff0000000000000 <=> fff0000000000000 ? 2 (CRx)
+#1: xscmpudp fff0000000000000 <=> c0d0650f5a07b353 ? 8 (CRx)
+#2: xscmpudp fff0000000000000 <=> 8000000000000000 ? 8 (CRx)
+#3: xscmpudp fff0000000000000 <=> 0000000000000000 ? 8 (CRx)
+#4: xscmpudp fff0000000000000 <=> 0123214569900000 ? 8 (CRx)
+#5: xscmpudp fff0000000000000 <=> 7ff0000000000000 ? 8 (CRx)
+#6: xscmpudp fff0000000000000 <=> 7ff7ffffffffffff ? 1 (CRx)
+#7: xscmpudp fff0000000000000 <=> 7ff8000000000000 ? 1 (CRx)
+#8: xscmpudp c0d0650f5a07b353 <=> fff0000000000000 ? 4 (CRx)
+#9: xscmpudp c0d0650f5a07b353 <=> c0d0650f5a07b353 ? 2 (CRx)
+#10: xscmpudp c0d0650f5a07b353 <=> 8000000000000000 ? 8 (CRx)
+#11: xscmpudp c0d0650f5a07b353 <=> 0000000000000000 ? 8 (CRx)
+#12: xscmpudp c0d0650f5a07b353 <=> 0123214569900000 ? 8 (CRx)
+#13: xscmpudp c0d0650f5a07b353 <=> 7ff0000000000000 ? 8 (CRx)
+#14: xscmpudp c0d0650f5a07b353 <=> 7ff7ffffffffffff ? 1 (CRx)
+#15: xscmpudp c0d0650f5a07b353 <=> 7ff8000000000000 ? 1 (CRx)
+#16: xscmpudp 8000000000000000 <=> fff0000000000000 ? 4 (CRx)
+#17: xscmpudp 8000000000000000 <=> c0d0650f5a07b353 ? 4 (CRx)
+#18: xscmpudp 8000000000000000 <=> 8000000000000000 ? 2 (CRx)
+#19: xscmpudp 8000000000000000 <=> 0000000000000000 ? 2 (CRx)
+#20: xscmpudp 8000000000000000 <=> 0123214569900000 ? 8 (CRx)
+#21: xscmpudp 8000000000000000 <=> 7ff0000000000000 ? 8 (CRx)
+#22: xscmpudp 8000000000000000 <=> 7ff7ffffffffffff ? 1 (CRx)
+#23: xscmpudp 8000000000000000 <=> 7ff8000000000000 ? 1 (CRx)
+#24: xscmpudp 0000000000000000 <=> fff0000000000000 ? 4 (CRx)
+#25: xscmpudp 0000000000000000 <=> c0d0650f5a07b353 ? 4 (CRx)
+#26: xscmpudp 0000000000000000 <=> 8000000000000000 ? 2 (CRx)
+#27: xscmpudp 0000000000000000 <=> 0000000000000000 ? 2 (CRx)
+#28: xscmpudp 0000000000000000 <=> 0123214569900000 ? 8 (CRx)
+#29: xscmpudp 0000000000000000 <=> 7ff0000000000000 ? 8 (CRx)
+#30: xscmpudp 0000000000000000 <=> 7ff7ffffffffffff ? 1 (CRx)
+#31: xscmpudp 0000000000000000 <=> 7ff8000000000000 ? 1 (CRx)
+#32: xscmpudp 0123214569900000 <=> fff0000000000000 ? 4 (CRx)
+#33: xscmpudp 0123214569900000 <=> c0d0650f5a07b353 ? 4 (CRx)
+#34: xscmpudp 0123214569900000 <=> 8000000000000000 ? 4 (CRx)
+#35: xscmpudp 0123214569900000 <=> 0000000000000000 ? 4 (CRx)
+#36: xscmpudp 0123214569900000 <=> 404f000000000000 ? 8 (CRx)
+#37: xscmpudp 0123214569900000 <=> 7ff0000000000000 ? 8 (CRx)
+#38: xscmpudp 0123214569900000 <=> 7ff7ffffffffffff ? 1 (CRx)
+#39: xscmpudp 0123214569900000 <=> 7ff8000000000000 ? 1 (CRx)
+#40: xscmpudp 7ff0000000000000 <=> fff0000000000000 ? 4 (CRx)
+#41: xscmpudp 7ff0000000000000 <=> c0d0650f5a07b353 ? 4 (CRx)
+#42: xscmpudp 7ff0000000000000 <=> 8000000000000000 ? 4 (CRx)
+#43: xscmpudp 7ff0000000000000 <=> 0000000000000000 ? 4 (CRx)
+#44: xscmpudp 7ff0000000000000 <=> 0123214569900000 ? 4 (CRx)
+#45: xscmpudp 7ff0000000000000 <=> 7ff0000000000000 ? 2 (CRx)
+#46: xscmpudp 7ff0000000000000 <=> 7ff7ffffffffffff ? 1 (CRx)
+#47: xscmpudp 7ff0000000000000 <=> 7ff8000000000000 ? 1 (CRx)
+#48: xscmpudp fff7ffffffffffff <=> fff0000000000000 ? 1 (CRx)
+#49: xscmpudp fff7ffffffffffff <=> c0d0650f5a07b353 ? 1 (CRx)
+#50: xscmpudp fff7ffffffffffff <=> 8000000000000000 ? 1 (CRx)
+#51: xscmpudp fff7ffffffffffff <=> 0000000000000000 ? 1 (CRx)
+#52: xscmpudp fff7ffffffffffff <=> 0123214569900000 ? 1 (CRx)
+#53: xscmpudp fff7ffffffffffff <=> 7ff0000000000000 ? 1 (CRx)
+#54: xscmpudp fff7ffffffffffff <=> 7ff7ffffffffffff ? 1 (CRx)
+#55: xscmpudp fff7ffffffffffff <=> 7ff8000000000000 ? 1 (CRx)
+#56: xscmpudp fff8000000000000 <=> fff0000000000000 ? 1 (CRx)
+#57: xscmpudp fff8000000000000 <=> c0d0650f5a07b353 ? 1 (CRx)
+#58: xscmpudp fff8000000000000 <=> 8000000000000000 ? 1 (CRx)
+#59: xscmpudp fff8000000000000 <=> 0000000000000000 ? 1 (CRx)
+#60: xscmpudp fff8000000000000 <=> 0123214569900000 ? 1 (CRx)
+#61: xscmpudp fff8000000000000 <=> 7ff0000000000000 ? 1 (CRx)
+#62: xscmpudp fff8000000000000 <=> 7ff7ffffffffffff ? 1 (CRx)
+#63: xscmpudp fff8000000000000 <=> 7ff8000000000000 ? 1 (CRx)
+
+#0: xscmpodp fff0000000000000 <=> fff0000000000000 ? 2 (CRx)
+#1: xscmpodp fff0000000000000 <=> c0d0650f5a07b353 ? 8 (CRx)
+#2: xscmpodp fff0000000000000 <=> 8000000000000000 ? 8 (CRx)
+#3: xscmpodp fff0000000000000 <=> 0000000000000000 ? 8 (CRx)
+#4: xscmpodp fff0000000000000 <=> 0123214569900000 ? 8 (CRx)
+#5: xscmpodp fff0000000000000 <=> 7ff0000000000000 ? 8 (CRx)
+#6: xscmpodp fff0000000000000 <=> 7ff7ffffffffffff ? 1 (CRx)
+#7: xscmpodp fff0000000000000 <=> 7ff8000000000000 ? 1 (CRx)
+#8: xscmpodp c0d0650f5a07b353 <=> fff0000000000000 ? 4 (CRx)
+#9: xscmpodp c0d0650f5a07b353 <=> c0d0650f5a07b353 ? 2 (CRx)
+#10: xscmpodp c0d0650f5a07b353 <=> 8000000000000000 ? 8 (CRx)
+#11: xscmpodp c0d0650f5a07b353 <=> 0000000000000000 ? 8 (CRx)
+#12: xscmpodp c0d0650f5a07b353 <=> 0123214569900000 ? 8 (CRx)
+#13: xscmpodp c0d0650f5a07b353 <=> 7ff0000000000000 ? 8 (CRx)
+#14: xscmpodp c0d0650f5a07b353 <=> 7ff7ffffffffffff ? 1 (CRx)
+#15: xscmpodp c0d0650f5a07b353 <=> 7ff8000000000000 ? 1 (CRx)
+#16: xscmpodp 8000000000000000 <=> fff0000000000000 ? 4 (CRx)
+#17: xscmpodp 8000000000000000 <=> c0d0650f5a07b353 ? 4 (CRx)
+#18: xscmpodp 8000000000000000 <=> 8000000000000000 ? 2 (CRx)
+#19: xscmpodp 8000000000000000 <=> 0000000000000000 ? 2 (CRx)
+#20: xscmpodp 8000000000000000 <=> 0123214569900000 ? 8 (CRx)
+#21: xscmpodp 8000000000000000 <=> 7ff0000000000000 ? 8 (CRx)
+#22: xscmpodp 8000000000000000 <=> 7ff7ffffffffffff ? 1 (CRx)
+#23: xscmpodp 8000000000000000 <=> 7ff8000000000000 ? 1 (CRx)
+#24: xscmpodp 0000000000000000 <=> fff0000000000000 ? 4 (CRx)
+#25: xscmpodp 0000000000000000 <=> c0d0650f5a07b353 ? 4 (CRx)
+#26: xscmpodp 0000000000000000 <=> 8000000000000000 ? 2 (CRx)
+#27: xscmpodp 0000000000000000 <=> 0000000000000000 ? 2 (CRx)
+#28: xscmpodp 0000000000000000 <=> 0123214569900000 ? 8 (CRx)
+#29: xscmpodp 0000000000000000 <=> 7ff0000000000000 ? 8 (CRx)
+#30: xscmpodp 0000000000000000 <=> 7ff7ffffffffffff ? 1 (CRx)
+#31: xscmpodp 0000000000000000 <=> 7ff8000000000000 ? 1 (CRx)
+#32: xscmpodp 0123214569900000 <=> fff0000000000000 ? 4 (CRx)
+#33: xscmpodp 0123214569900000 <=> c0d0650f5a07b353 ? 4 (CRx)
+#34: xscmpodp 0123214569900000 <=> 8000000000000000 ? 4 (CRx)
+#35: xscmpodp 0123214569900000 <=> 0000000000000000 ? 4 (CRx)
+#36: xscmpodp 0123214569900000 <=> 404f000000000000 ? 8 (CRx)
+#37: xscmpodp 0123214569900000 <=> 7ff0000000000000 ? 8 (CRx)
+#38: xscmpodp 0123214569900000 <=> 7ff7ffffffffffff ? 1 (CRx)
+#39: xscmpodp 0123214569900000 <=> 7ff8000000000000 ? 1 (CRx)
+#40: xscmpodp 7ff0000000000000 <=> fff0000000000000 ? 4 (CRx)
+#41: xscmpodp 7ff0000000000000 <=> c0d0650f5a07b353 ? 4 (CRx)
+#42: xscmpodp 7ff0000000000000 <=> 8000000000000000 ? 4 (CRx)
+#43: xscmpodp 7ff0000000000000 <=> 0000000000000000 ? 4 (CRx)
+#44: xscmpodp 7ff0000000000000 <=> 0123214569900000 ? 4 (CRx)
+#45: xscmpodp 7ff0000000000000 <=> 7ff0000000000000 ? 2 (CRx)
+#46: xscmpodp 7ff0000000000000 <=> 7ff7ffffffffffff ? 1 (CRx)
+#47: xscmpodp 7ff0000000000000 <=> 7ff8000000000000 ? 1 (CRx)
+#48: xscmpodp fff7ffffffffffff <=> fff0000000000000 ? 1 (CRx)
+#49: xscmpodp fff7ffffffffffff <=> c0d0650f5a07b353 ? 1 (CRx)
+#50: xscmpodp fff7ffffffffffff <=> 8000000000000000 ? 1 (CRx)
+#51: xscmpodp fff7ffffffffffff <=> 0000000000000000 ? 1 (CRx)
+#52: xscmpodp fff7ffffffffffff <=> 0123214569900000 ? 1 (CRx)
+#53: xscmpodp fff7ffffffffffff <=> 7ff0000000000000 ? 1 (CRx)
+#54: xscmpodp fff7ffffffffffff <=> 7ff7ffffffffffff ? 1 (CRx)
+#55: xscmpodp fff7ffffffffffff <=> 7ff8000000000000 ? 1 (CRx)
+#56: xscmpodp fff8000000000000 <=> fff0000000000000 ? 1 (CRx)
+#57: xscmpodp fff8000000000000 <=> c0d0650f5a07b353 ? 1 (CRx)
+#58: xscmpodp fff8000000000000 <=> 8000000000000000 ? 1 (CRx)
+#59: xscmpodp fff8000000000000 <=> 0000000000000000 ? 1 (CRx)
+#60: xscmpodp fff8000000000000 <=> 0123214569900000 ? 1 (CRx)
+#61: xscmpodp fff8000000000000 <=> 7ff0000000000000 ? 1 (CRx)
+#62: xscmpodp fff8000000000000 <=> 7ff7ffffffffffff ? 1 (CRx)
+#63: xscmpodp fff8000000000000 <=> 7ff8000000000000 ? 1 (CRx)
+
+#0: xsadddp fff0000000000000 fff0000000000000 = fff0000000000000
+#1: xsadddp fff0000000000000 c0d0650f5a07b353 = fff0000000000000
+#2: xsadddp fff0000000000000 8000000000000000 = fff0000000000000
+#3: xsadddp fff0000000000000 0000000000000000 = fff0000000000000
+#4: xsadddp fff0000000000000 0123214569900000 = fff0000000000000
+#5: xsadddp fff0000000000000 7ff0000000000000 = 7ff8000000000000
+#6: xsadddp fff0000000000000 7ff7ffffffffffff = 7fffffffffffffff
+#7: xsadddp fff0000000000000 7ff8000000000000 = 7ff8000000000000
+#8: xsadddp c0d0650f5a07b353 fff0000000000000 = fff0000000000000
+#9: xsadddp c0d0650f5a07b353 c0d0650f5a07b353 = c0e0650f5a07b353
+#10: xsadddp c0d0650f5a07b353 8000000000000000 = c0d0650f5a07b353
+#11: xsadddp c0d0650f5a07b353 0000000000000000 = c0d0650f5a07b353
+#12: xsadddp c0d0650f5a07b353 0123214569900000 = c0d0650f5a07b353
+#13: xsadddp c0d0650f5a07b353 7ff0000000000000 = 7ff0000000000000
+#14: xsadddp c0d0650f5a07b353 7ff7ffffffffffff = 7fffffffffffffff
+#15: xsadddp c0d0650f5a07b353 7ff8000000000000 = 7ff8000000000000
+#16: xsadddp 8000000000000000 fff0000000000000 = fff0000000000000
+#17: xsadddp 8000000000000000 c0d0650f5a07b353 = c0d0650f5a07b353
+#18: xsadddp 8000000000000000 8000000000000000 = 8000000000000000
+#19: xsadddp 8000000000000000 0000000000000000 = 0000000000000000
+#20: xsadddp 8000000000000000 0123214569900000 = 0123214569900000
+#21: xsadddp 8000000000000000 7ff0000000000000 = 7ff0000000000000
+#22: xsadddp 8000000000000000 7ff7ffffffffffff = 7fffffffffffffff
+#23: xsadddp 8000000000000000 7ff8000000000000 = 7ff8000000000000
+#24: xsadddp 0000000000000000 fff0000000000000 = fff0000000000000
+#25: xsadddp 0000000000000000 c0d0650f5a07b353 = c0d0650f5a07b353
+#26: xsadddp 0000000000000000 8000000000000000 = 0000000000000000
+#27: xsadddp 0000000000000000 0000000000000000 = 0000000000000000
+#28: xsadddp 0000000000000000 0123214569900000 = 0123214569900000
+#29: xsadddp 0000000000000000 7ff0000000000000 = 7ff0000000000000
+#30: xsadddp 0000000000000000 7ff7ffffffffffff = 7fffffffffffffff
+#31: xsadddp 0000000000000000 7ff8000000000000 = 7ff8000000000000
+#32: xsadddp 0123214569900000 fff0000000000000 = fff0000000000000
+#33: xsadddp 0123214569900000 c0d0650f5a07b353 = c0d0650f5a07b353
+#34: xsadddp 0123214569900000 8000000000000000 = 0123214569900000
+#35: xsadddp 0123214569900000 0000000000000000 = 0123214569900000
+#36: xsadddp 0123214569900000 404f000000000000 = 404f000000000000
+#37: xsadddp 0123214569900000 7ff0000000000000 = 7ff0000000000000
+#38: xsadddp 0123214569900000 7ff7ffffffffffff = 7fffffffffffffff
+#39: xsadddp 0123214569900000 7ff8000000000000 = 7ff8000000000000
+#40: xsadddp 7ff0000000000000 fff0000000000000 = 7ff8000000000000
+#41: xsadddp 7ff0000000000000 c0d0650f5a07b353 = 7ff0000000000000
+#42: xsadddp 7ff0000000000000 8000000000000000 = 7ff0000000000000
+#43: xsadddp 7ff0000000000000 0000000000000000 = 7ff0000000000000
+#44: xsadddp 7ff0000000000000 0123214569900000 = 7ff0000000000000
+#45: xsadddp 7ff0000000000000 7ff0000000000000 = 7ff0000000000000
+#46: xsadddp 7ff0000000000000 7ff7ffffffffffff = 7fffffffffffffff
+#47: xsadddp 7ff0000000000000 7ff8000000000000 = 7ff8000000000000
+#48: xsadddp fff7ffffffffffff fff0000000000000 = ffffffffffffffff
+#49: xsadddp fff7ffffffffffff c0d0650f5a07b353 = ffffffffffffffff
+#50: xsadddp fff7ffffffffffff 8000000000000000 = ffffffffffffffff
+#51: xsadddp fff7ffffffffffff 0000000000000000 = ffffffffffffffff
+#52: xsadddp fff7ffffffffffff 0123214569900000 = ffffffffffffffff
+#53: xsadddp fff7ffffffffffff 7ff0000000000000 = ffffffffffffffff
+#54: xsadddp fff7ffffffffffff 7ff7ffffffffffff = ffffffffffffffff
+#55: xsadddp fff7ffffffffffff 7ff8000000000000 = ffffffffffffffff
+#56: xsadddp fff8000000000000 fff0000000000000 = fff8000000000000
+#57: xsadddp fff8000000000000 c0d0650f5a07b353 = fff8000000000000
+#58: xsadddp fff8000000000000 8000000000000000 = fff8000000000000
+#59: xsadddp fff8000000000000 0000000000000000 = fff8000000000000
+#60: xsadddp fff8000000000000 0123214569900000 = fff8000000000000
+#61: xsadddp fff8000000000000 7ff0000000000000 = fff8000000000000
+#62: xsadddp fff8000000000000 7ff7ffffffffffff = fff8000000000000
+#63: xsadddp fff8000000000000 7ff8000000000000 = fff8000000000000
+
+#0: xsdivdp fff0000000000000 fff0000000000000 = 7ff8000000000000
+#1: xsdivdp fff0000000000000 c0d0650f5a07b353 = 7ff0000000000000
+#2: xsdivdp fff0000000000000 8000000000000000 = 7ff0000000000000
+#3: xsdivdp fff0000000000000 0000000000000000 = fff0000000000000
+#4: xsdivdp fff0000000000000 0123214569900000 = fff0000000000000
+#5: xsdivdp fff0000000000000 7ff0000000000000 = 7ff8000000000000
+#6: xsdivdp fff0000000000000 7ff7ffffffffffff = 7fffffffffffffff
+#7: xsdivdp fff0000000000000 7ff8000000000000 = 7ff8000000000000
+#8: xsdivdp c0d0650f5a07b353 fff0000000000000 = 0000000000000000
+#9: xsdivdp c0d0650f5a07b353 c0d0650f5a07b353 = 3ff0000000000000
+#10: xsdivdp c0d0650f5a07b353 8000000000000000 = 7ff0000000000000
+#11: xsdivdp c0d0650f5a07b353 0000000000000000 = fff0000000000000
+#12: xsdivdp c0d0650f5a07b353 0123214569900000 = ff9b6cb57ca13c00
+#13: xsdivdp c0d0650f5a07b353 7ff0000000000000 = 8000000000000000
+#14: xsdivdp c0d0650f5a07b353 7ff7ffffffffffff = 7fffffffffffffff
+#15: xsdivdp c0d0650f5a07b353 7ff8000000000000 = 7ff8000000000000
+#16: xsdivdp 8000000000000000 fff0000000000000 = 0000000000000000
+#17: xsdivdp 8000000000000000 c0d0650f5a07b353 = 0000000000000000
+#18: xsdivdp 8000000000000000 8000000000000000 = 7ff8000000000000
+#19: xsdivdp 8000000000000000 0000000000000000 = 7ff8000000000000
+#20: xsdivdp 8000000000000000 0123214569900000 = 8000000000000000
+#21: xsdivdp 8000000000000000 7ff0000000000000 = 8000000000000000
+#22: xsdivdp 8000000000000000 7ff7ffffffffffff = 7fffffffffffffff
+#23: xsdivdp 8000000000000000 7ff8000000000000 = 7ff8000000000000
+#24: xsdivdp 0000000000000000 fff0000000000000 = 8000000000000000
+#25: xsdivdp 0000000000000000 c0d0650f5a07b353 = 8000000000000000
+#26: xsdivdp 0000000000000000 8000000000000000 = 7ff8000000000000
+#27: xsdivdp 0000000000000000 0000000000000000 = 7ff8000000000000
+#28: xsdivdp 0000000000000000 0123214569900000 = 0000000000000000
+#29: xsdivdp 0000000000000000 7ff0000000000000 = 0000000000000000
+#30: xsdivdp 0000000000000000 7ff7ffffffffffff = 7fffffffffffffff
+#31: xsdivdp 0000000000000000 7ff8000000000000 = 7ff8000000000000
+#32: xsdivdp 0123214569900000 fff0000000000000 = 8000000000000000
+#33: xsdivdp 0123214569900000 c0d0650f5a07b353 = 8042ab59d8b6ec87
+#34: xsdivdp 0123214569900000 8000000000000000 = fff0000000000000
+#35: xsdivdp 0123214569900000 0000000000000000 = 7ff0000000000000
+#36: xsdivdp 0123214569900000 404f000000000000 = 00c3bf3f64b5ad6b
+#37: xsdivdp 0123214569900000 7ff0000000000000 = 0000000000000000
+#38: xsdivdp 0123214569900000 7ff7ffffffffffff = 7fffffffffffffff
+#39: xsdivdp 0123214569900000 7ff8000000000000 = 7ff8000000000000
+#40: xsdivdp 7ff0000000000000 fff0000000000000 = 7ff8000000000000
+#41: xsdivdp 7ff0000000000000 c0d0650f5a07b353 = fff0000000000000
+#42: xsdivdp 7ff0000000000000 8000000000000000 = fff0000000000000
+#43: xsdivdp 7ff0000000000000 0000000000000000 = 7ff0000000000000
+#44: xsdivdp 7ff0000000000000 0123214569900000 = 7ff0000000000000
+#45: xsdivdp 7ff0000000000000 7ff0000000000000 = 7ff8000000000000
+#46: xsdivdp 7ff0000000000000 7ff7ffffffffffff = 7fffffffffffffff
+#47: xsdivdp 7ff0000000000000 7ff8000000000000 = 7ff8000000000000
+#48: xsdivdp fff7ffffffffffff fff0000000000000 = ffffffffffffffff
+#49: xsdivdp fff7ffffffffffff c0d0650f5a07b353 = ffffffffffffffff
+#50: xsdivdp fff7ffffffffffff 8000000000000000 = ffffffffffffffff
+#51: xsdivdp fff7ffffffffffff 0000000000000000 = ffffffffffffffff
+#52: xsdivdp fff7ffffffffffff 0123214569900000 = ffffffffffffffff
+#53: xsdivdp fff7ffffffffffff 7ff0000000000000 = ffffffffffffffff
+#54: xsdivdp fff7ffffffffffff 7ff7ffffffffffff = ffffffffffffffff
+#55: xsdivdp fff7ffffffffffff 7ff8000000000000 = ffffffffffffffff
+#56: xsdivdp fff8000000000000 fff0000000000000 = fff8000000000000
+#57: xsdivdp fff8000000000000 c0d0650f5a07b353 = fff8000000000000
+#58: xsdivdp fff8000000000000 8000000000000000 = fff8000000000000
+#59: xsdivdp fff8000000000000 0000000000000000 = fff8000000000000
+#60: xsdivdp fff8000000000000 0123214569900000 = fff8000000000000
+#61: xsdivdp fff8000000000000 7ff0000000000000 = fff8000000000000
+#62: xsdivdp fff8000000000000 7ff7ffffffffffff = fff8000000000000
+#63: xsdivdp fff8000000000000 7ff8000000000000 = fff8000000000000
+
+#0: xsmaddadp fff0000000000000 fff0000000000000 c0d0650f5a07b353 = 7ff8000000000000
+#1: xsmaddadp c0d0650f5a07b353 fff0000000000000 0123214569900000 = fff0000000000000
+#2: xsmaddadp 8000000000000000 fff0000000000000 c0d0650f5a07b353 = 7ff0000000000000
+#3: xsmaddadp 0000000000000000 fff0000000000000 0123214569900000 = fff0000000000000
+#4: xsmaddadp 0123214569900000 fff0000000000000 c0d0650f5a07b353 = 7ff0000000000000
+#5: xsmaddadp 7ff0000000000000 fff0000000000000 0123214569900000 = 7ff8000000000000
+#6: xsmaddadp 7ff7ffffffffffff fff0000000000000 c0d0650f5a07b353 = 7fffffffffffffff
+#7: xsmaddadp 7ff8000000000000 fff0000000000000 0123214569900000 = 7ff8000000000000
+#8: xsmaddadp fff0000000000000 c0d0650f5a07b353 c0d0650f5a07b353 = fff0000000000000
+#9: xsmaddadp c0d0650f5a07b353 c0d0650f5a07b353 0123214569900000 = c0d0650f5a07b353
+#10: xsmaddadp 8000000000000000 c0d0650f5a07b353 c0d0650f5a07b353 = 41b0cc9d05eec2a7
+#11: xsmaddadp 0000000000000000 c0d0650f5a07b353 0123214569900000 = 82039a19ca8fcb5f
+#12: xsmaddadp 0123214569900000 c0d0650f5a07b353 c0d0650f5a07b353 = 41b0cc9d05eec2a7
+#13: xsmaddadp 7ff0000000000000 c0d0650f5a07b353 0123214569900000 = 7ff0000000000000
+#14: xsmaddadp 7ff7ffffffffffff c0d0650f5a07b353 c0d0650f5a07b353 = 7fffffffffffffff
+#15: xsmaddadp 7ff8000000000000 c0d0650f5a07b353 0123214569900000 = 7ff8000000000000
+#16: xsmaddadp fff0000000000000 8000000000000000 c0d0650f5a07b353 = fff0000000000000
+#17: xsmaddadp c0d0650f5a07b353 8000000000000000 0123214569900000 = c0d0650f5a07b353
+#18: xsmaddadp 8000000000000000 8000000000000000 c0d0650f5a07b353 = 0000000000000000
+#19: xsmaddadp 0000000000000000 8000000000000000 0123214569900000 = 0000000000000000
+#20: xsmaddadp 0123214569900000 8000000000000000 c0d0650f5a07b353 = 0123214569900000
+#21: xsmaddadp 7ff0000000000000 8000000000000000 0123214569900000 = 7ff0000000000000
+#22: xsmaddadp 7ff7ffffffffffff 8000000000000000 c0d0650f5a07b353 = 7fffffffffffffff
+#23: xsmaddadp 7ff8000000000000 8000000000000000 0123214569900000 = 7ff8000000000000
+#24: xsmaddadp fff0000000000000 0000000000000000 c0d0650f5a07b353 = fff0000000000000
+#25: xsmaddadp c0d0650f5a07b353 0000000000000000 0123214569900000 = c0d0650f5a07b353
+#26: xsmaddadp 8000000000000000 0000000000000000 c0d0650f5a07b353 = 8000000000000000
+#27: xsmaddadp 0000000000000000 0000000000000000 0123214569900000 = 0000000000000000
+#28: xsmaddadp 0123214569900000 0000000000000000 c0d0650f5a07b353 = 0123214569900000
+#29: xsmaddadp 7ff0000000000000 0000000000000000 0123214569900000 = 7ff0000000000000
+#30: xsmaddadp 7ff7ffffffffffff 0000000000000000 c0d0650f5a07b353 = 7fffffffffffffff
+#31: xsmaddadp 7ff8000000000000 0000000000000000 0123214569900000 = 7ff8000000000000
+#32: xsmaddadp fff0000000000000 0123214569900000 c0d0650f5a07b353 = fff0000000000000
+#33: xsmaddadp c0d0650f5a07b353 0123214569900000 0123214569900000 = c0d0650f5a07b353
+#34: xsmaddadp 8000000000000000 0123214569900000 c0d0650f5a07b353 = 82039a19ca8fcb5f
+#35: xsmaddadp 0000000000000000 0123214569900000 0123214569900000 = 0000000000000000
+#36: xsmaddadp 404f000000000000 0123214569900000 c0d0650f5a07b353 = 404f000000000000
+#37: xsmaddadp 7ff0000000000000 0123214569900000 0123214569900000 = 7ff0000000000000
+#38: xsmaddadp 7ff7ffffffffffff 0123214569900000 c0d0650f5a07b353 = 7fffffffffffffff
+#39: xsmaddadp 7ff8000000000000 0123214569900000 0123214569900000 = 7ff8000000000000
+#40: xsmaddadp fff0000000000000 7ff0000000000000 c0d0650f5a07b353 = fff0000000000000
+#41: xsmaddadp c0d0650f5a07b353 7ff0000000000000 0123214569900000 = 7ff0000000000000
+#42: xsmaddadp 8000000000000000 7ff0000000000000 c0d0650f5a07b353 = fff0000000000000
+#43: xsmaddadp 0000000000000000 7ff0000000000000 0123214569900000 = 7ff0000000000000
+#44: xsmaddadp 0123214569900000 7ff0000000000000 c0d0650f5a07b353 = fff0000000000000
+#45: xsmaddadp 7ff0000000000000 7ff0000000000000 0123214569900000 = 7ff0000000000000
+#46: xsmaddadp 7ff7ffffffffffff 7ff0000000000000 c0d0650f5a07b353 = 7fffffffffffffff
+#47: xsmaddadp 7ff8000000000000 7ff0000000000000 0123214569900000 = 7ff8000000000000
+#48: xsmaddadp fff0000000000000 fff7ffffffffffff c0d0650f5a07b353 = ffffffffffffffff
+#49: xsmaddadp c0d0650f5a07b353 fff7ffffffffffff 0123214569900000 = ffffffffffffffff
+#50: xsmaddadp 8000000000000000 fff7ffffffffffff c0d0650f5a07b353 = ffffffffffffffff
+#51: xsmaddadp 0000000000000000 fff7ffffffffffff 0123214569900000 = ffffffffffffffff
+#52: xsmaddadp 0123214569900000 fff7ffffffffffff c0d0650f5a07b353 = ffffffffffffffff
+#53: xsmaddadp 7ff0000000000000 fff7ffffffffffff 0123214569900000 = ffffffffffffffff
+#54: xsmaddadp 7ff7ffffffffffff fff7ffffffffffff c0d0650f5a07b353 = ffffffffffffffff
+#55: xsmaddadp 7ff8000000000000 fff7ffffffffffff 0123214569900000 = ffffffffffffffff
+#56: xsmaddadp fff0000000000000 fff8000000000000 c0d0650f5a07b353 = fff8000000000000
+#57: xsmaddadp c0d0650f5a07b353 fff8000000000000 0123214569900000 = fff8000000000000
+#58: xsmaddadp 8000000000000000 fff8000000000000 c0d0650f5a07b353 = fff8000000000000
+#59: xsmaddadp 0000000000000000 fff8000000000000 0123214569900000 = fff8000000000000
+#60: xsmaddadp 0123214569900000 fff8000000000000 c0d0650f5a07b353 = fff8000000000000
+#61: xsmaddadp 7ff0000000000000 fff8000000000000 0123214569900000 = fff8000000000000
+#62: xsmaddadp 7ff7ffffffffffff fff8000000000000 c0d0650f5a07b353 = fff8000000000000
+#63: xsmaddadp 7ff8000000000000 fff8000000000000 0123214569900000 = fff8000000000000
+
+#0: xsmaddmdp c0d0650f5a07b353 fff0000000000000 fff0000000000000 = 7ff8000000000000
+#1: xsmaddmdp 0123214569900000 fff0000000000000 c0d0650f5a07b353 = fff0000000000000
+#2: xsmaddmdp c0d0650f5a07b353 fff0000000000000 8000000000000000 = 7ff0000000000000
+#3: xsmaddmdp 0123214569900000 fff0000000000000 0000000000000000 = fff0000000000000
+#4: xsmaddmdp c0d0650f5a07b353 fff0000000000000 0123214569900000 = 7ff0000000000000
+#5: xsmaddmdp 0123214569900000 fff0000000000000 7ff0000000000000 = 7ff8000000000000
+#6: xsmaddmdp c0d0650f5a07b353 fff0000000000000 7ff7ffffffffffff = 7fffffffffffffff
+#7: xsmaddmdp 0123214569900000 fff0000000000000 7ff8000000000000 = 7ff8000000000000
+#8: xsmaddmdp c0d0650f5a07b353 c0d0650f5a07b353 fff0000000000000 = fff0000000000000
+#9: xsmaddmdp 0123214569900000 c0d0650f5a07b353 c0d0650f5a07b353 = c0d0650f5a07b353
+#10: xsmaddmdp c0d0650f5a07b353 c0d0650f5a07b353 8000000000000000 = 41b0cc9d05eec2a7
+#11: xsmaddmdp 0123214569900000 c0d0650f5a07b353 0000000000000000 = 82039a19ca8fcb5f
+#12: xsmaddmdp c0d0650f5a07b353 c0d0650f5a07b353 0123214569900000 = 41b0cc9d05eec2a7
+#13: xsmaddmdp 0123214569900000 c0d0650f5a07b353 7ff0000000000000 = 7ff0000000000000
+#14: xsmaddmdp c0d0650f5a07b353 c0d0650f5a07b353 7ff7ffffffffffff = 7fffffffffffffff
+#15: xsmaddmdp 0123214569900000 c0d0650f5a07b353 7ff8000000000000 = 7ff8000000000000
+#16: xsmaddmdp c0d0650f5a07b353 8000000000000000 fff0000000000000 = fff0000000000000
+#17: xsmaddmdp 0123214569900000 8000000000000000 c0d0650f5a07b353 = c0d0650f5a07b353
+#18: xsmaddmdp c0d0650f5a07b353 8000000000000000 8000000000000000 = 0000000000000000
+#19: xsmaddmdp 0123214569900000 8000000000000000 0000000000000000 = 0000000000000000
+#20: xsmaddmdp c0d0650f5a07b353 8000000000000000 0123214569900000 = 0123214569900000
+#21: xsmaddmdp 0123214569900000 8000000000000000 7ff0000000000000 = 7ff0000000000000
+#22: xsmaddmdp c0d0650f5a07b353 8000000000000000 7ff7ffffffffffff = 7fffffffffffffff
+#23: xsmaddmdp 0123214569900000 8000000000000000 7ff8000000000000 = 7ff8000000000000
+#24: xsmaddmdp c0d0650f5a07b353 0000000000000000 fff0000000000000 = fff0000000000000
+#25: xsmaddmdp 0123214569900000 0000000000000000 c0d0650f5a07b353 = c0d0650f5a07b353
+#26: xsmaddmdp c0d0650f5a07b353 0000000000000000 8000000000000000 = 8000000000000000
+#27: xsmaddmdp 0123214569900000 0000000000000000 0000000000000000 = 0000000000000000
+#28: xsmaddmdp c0d0650f5a07b353 0000000000000000 0123214569900000 = 0123214569900000
+#29: xsmaddmdp 0123214569900000 0000000000000000 7ff0000000000000 = 7ff0000000000000
+#30: xsmaddmdp c0d0650f5a07b353 0000000000000000 7ff7ffffffffffff = 7fffffffffffffff
+#31: xsmaddmdp 0123214569900000 0000000000000000 7ff8000000000000 = 7ff8000000000000
+#32: xsmaddmdp c0d0650f5a07b353 0123214569900000 fff0000000000000 = fff0000000000000
+#33: xsmaddmdp 0123214569900000 0123214569900000 c0d0650f5a07b353 = c0d0650f5a07b353
+#34: xsmaddmdp c0d0650f5a07b353 0123214569900000 8000000000000000 = 82039a19ca8fcb5f
+#35: xsmaddmdp 0123214569900000 0123214569900000 0000000000000000 = 0000000000000000
+#36: xsmaddmdp c0d0650f5a07b353 0123214569900000 404f000000000000 = 404f000000000000
+#37: xsmaddmdp 0123214569900000 0123214569900000 7ff0000000000000 = 7ff0000000000000
+#38: xsmaddmdp c0d0650f5a07b353 0123214569900000 7ff7ffffffffffff = 7fffffffffffffff
+#39: xsmaddmdp 0123214569900000 0123214569900000 7ff8000000000000 = 7ff8000000000000
+#40: xsmaddmdp c0d0650f5a07b353 7ff0000000000000 fff0000000000000 = fff0000000000000
+#41: xsmaddmdp 0123214569900000 7ff0000000000000 c0d0650f5a07b353 = 7ff0000000000000
+#42: xsmaddmdp c0d0650f5a07b353 7ff0000000000000 8000000000000000 = fff0000000000000
+#43: xsmaddmdp 0123214569900000 7ff0000000000000 0000000000000000 = 7ff0000000000000
+#44: xsmaddmdp c0d0650f5a07b353 7ff0000000000000 0123214569900000 = fff0000000000000
+#45: xsmaddmdp 0123214569900000 7ff0000000000000 7ff0000000000000 = 7ff0000000000000
+#46: xsmaddmdp c0d0650f5a07b353 7ff0000000000000 7ff7ffffffffffff = 7fffffffffffffff
+#47: xsmaddmdp 0123214569900000 7ff0000000000000 7ff8000000000000 = 7ff8000000000000
+#48: xsmaddmdp c0d0650f5a07b353 fff7ffffffffffff fff0000000000000 = ffffffffffffffff
+#49: xsmaddmdp 0123214569900000 fff7ffffffffffff c0d0650f5a07b353 = ffffffffffffffff
+#50: xsmaddmdp c0d0650f5a07b353 fff7ffffffffffff 8000000000000000 = ffffffffffffffff
+#51: xsmaddmdp 0123214569900000 fff7ffffffffffff 0000000000000000 = ffffffffffffffff
+#52: xsmaddmdp c0d0650f5a07b353 fff7ffffffffffff 0123214569900000 = ffffffffffffffff
+#53: xsmaddmdp 0123214569900000 fff7ffffffffffff 7ff0000000000000 = ffffffffffffffff
+#54: xsmaddmdp c0d0650f5a07b353 fff7ffffffffffff 7ff7ffffffffffff = ffffffffffffffff
+#55: xsmaddmdp 0123214569900000 fff7ffffffffffff 7ff8000000000000 = ffffffffffffffff
+#56: xsmaddmdp c0d0650f5a07b353 fff8000000000000 fff0000000000000 = fff8000000000000
+#57: xsmaddmdp 0123214569900000 fff8000000000000 c0d0650f5a07b353 = fff8000000000000
+#58: xsmaddmdp c0d0650f5a07b353 fff8000000000000 8000000000000000 = fff8000000000000
+#59: xsmaddmdp 0123214569900000 fff8000000000000 0000000000000000 = fff8000000000000
+#60: xsmaddmdp c0d0650f5a07b353 fff8000000000000 0123214569900000 = fff8000000000000
+#61: xsmaddmdp 0123214569900000 fff8000000000000 7ff0000000000000 = fff8000000000000
+#62: xsmaddmdp c0d0650f5a07b353 fff8000000000000 7ff7ffffffffffff = fff8000000000000
+#63: xsmaddmdp 0123214569900000 fff8000000000000 7ff8000000000000 = fff8000000000000
+
+#0: xsmsubadp fff0000000000000 fff0000000000000 c0d0650f5a07b353 = 7ff0000000000000
+#1: xsmsubadp c0d0650f5a07b353 fff0000000000000 0123214569900000 = fff0000000000000
+#2: xsmsubadp 8000000000000000 fff0000000000000 c0d0650f5a07b353 = 7ff0000000000000
+#3: xsmsubadp 0000000000000000 fff0000000000000 0123214569900000 = fff0000000000000
+#4: xsmsubadp 0123214569900000 fff0000000000000 c0d0650f5a07b353 = 7ff0000000000000
+#5: xsmsubadp 7ff0000000000000 fff0000000000000 0123214569900000 = fff0000000000000
+#6: xsmsubadp 7ff7ffffffffffff fff0000000000000 c0d0650f5a07b353 = 7fffffffffffffff
+#7: xsmsubadp 7ff8000000000000 fff0000000000000 0123214569900000 = 7ff8000000000000
+#8: xsmsubadp fff0000000000000 c0d0650f5a07b353 c0d0650f5a07b353 = 7ff0000000000000
+#9: xsmsubadp c0d0650f5a07b353 c0d0650f5a07b353 0123214569900000 = 40d0650f5a07b353
+#10: xsmsubadp 8000000000000000 c0d0650f5a07b353 c0d0650f5a07b353 = 41b0cc9d05eec2a7
+#11: xsmsubadp 0000000000000000 c0d0650f5a07b353 0123214569900000 = 82039a19ca8fcb5f
+#12: xsmsubadp 0123214569900000 c0d0650f5a07b353 c0d0650f5a07b353 = 41b0cc9d05eec2a7
+#13: xsmsubadp 7ff0000000000000 c0d0650f5a07b353 0123214569900000 = fff0000000000000
+#14: xsmsubadp 7ff7ffffffffffff c0d0650f5a07b353 c0d0650f5a07b353 = 7fffffffffffffff
+#15: xsmsubadp 7ff8000000000000 c0d0650f5a07b353 0123214569900000 = 7ff8000000000000
+#16: xsmsubadp fff0000000000000 8000000000000000 c0d0650f5a07b353 = 7ff0000000000000
+#17: xsmsubadp c0d0650f5a07b353 8000000000000000 0123214569900000 = 40d0650f5a07b353
+#18: xsmsubadp 8000000000000000 8000000000000000 c0d0650f5a07b353 = 0000000000000000
+#19: xsmsubadp 0000000000000000 8000000000000000 0123214569900000 = 8000000000000000
+#20: xsmsubadp 0123214569900000 8000000000000000 c0d0650f5a07b353 = 8123214569900000
+#21: xsmsubadp 7ff0000000000000 8000000000000000 0123214569900000 = fff0000000000000
+#22: xsmsubadp 7ff7ffffffffffff 8000000000000000 c0d0650f5a07b353 = 7fffffffffffffff
+#23: xsmsubadp 7ff8000000000000 8000000000000000 0123214569900000 = 7ff8000000000000
+#24: xsmsubadp fff0000000000000 0000000000000000 c0d0650f5a07b353 = 7ff0000000000000
+#25: xsmsubadp c0d0650f5a07b353 0000000000000000 0123214569900000 = 40d0650f5a07b353
+#26: xsmsubadp 8000000000000000 0000000000000000 c0d0650f5a07b353 = 0000000000000000
+#27: xsmsubadp 0000000000000000 0000000000000000 0123214569900000 = 0000000000000000
+#28: xsmsubadp 0123214569900000 0000000000000000 c0d0650f5a07b353 = 8123214569900000
+#29: xsmsubadp 7ff0000000000000 0000000000000000 0123214569900000 = fff0000000000000
+#30: xsmsubadp 7ff7ffffffffffff 0000000000000000 c0d0650f5a07b353 = 7fffffffffffffff
+#31: xsmsubadp 7ff8000000000000 0000000000000000 0123214569900000 = 7ff8000000000000
+#32: xsmsubadp fff0000000000000 0123214569900000 c0d0650f5a07b353 = 7ff0000000000000
+#33: xsmsubadp c0d0650f5a07b353 0123214569900000 0123214569900000 = 40d0650f5a07b353
+#34: xsmsubadp 8000000000000000 0123214569900000 c0d0650f5a07b353 = 82039a19ca8fcb5f
+#35: xsmsubadp 0000000000000000 0123214569900000 0123214569900000 = 0000000000000000
+#36: xsmsubadp 404f000000000000 0123214569900000 c0d0650f5a07b353 = c04f000000000000
+#37: xsmsubadp 7ff0000000000000 0123214569900000 0123214569900000 = fff0000000000000
+#38: xsmsubadp 7ff7ffffffffffff 0123214569900000 c0d0650f5a07b353 = 7fffffffffffffff
+#39: xsmsubadp 7ff8000000000000 0123214569900000 0123214569900000 = 7ff8000000000000
+#40: xsmsubadp fff0000000000000 7ff0000000000000 c0d0650f5a07b353 = 7ff8000000000000
+#41: xsmsubadp c0d0650f5a07b353 7ff0000000000000 0123214569900000 = 7ff0000000000000
+#42: xsmsubadp 8000000000000000 7ff0000000000000 c0d0650f5a07b353 = fff0000000000000
+#43: xsmsubadp 0000000000000000 7ff0000000000000 0123214569900000 = 7ff0000000000000
+#44: xsmsubadp 0123214569900000 7ff0000000000000 c0d0650f5a07b353 = fff0000000000000
+#45: xsmsubadp 7ff0000000000000 7ff0000000000000 0123214569900000 = 7ff8000000000000
+#46: xsmsubadp 7ff7ffffffffffff 7ff0000000000000 c0d0650f5a07b353 = 7fffffffffffffff
+#47: xsmsubadp 7ff8000000000000 7ff0000000000000 0123214569900000 = 7ff8000000000000
+#48: xsmsubadp fff0000000000000 fff7ffffffffffff c0d0650f5a07b353 = ffffffffffffffff
+#49: xsmsubadp c0d0650f5a07b353 fff7ffffffffffff 0123214569900000 = ffffffffffffffff
+#50: xsmsubadp 8000000000000000 fff7ffffffffffff c0d0650f5a07b353 = ffffffffffffffff
+#51: xsmsubadp 0000000000000000 fff7ffffffffffff 0123214569900000 = ffffffffffffffff
+#52: xsmsubadp 0123214569900000 fff7ffffffffffff c0d0650f5a07b353 = ffffffffffffffff
+#53: xsmsubadp 7ff0000000000000 fff7ffffffffffff 0123214569900000 = ffffffffffffffff
+#54: xsmsubadp 7ff7ffffffffffff fff7ffffffffffff c0d0650f5a07b353 = ffffffffffffffff
+#55: xsmsubadp 7ff8000000000000 fff7ffffffffffff 0123214569900000 = ffffffffffffffff
+#56: xsmsubadp fff0000000000000 fff8000000000000 c0d0650f5a07b353 = fff8000000000000
+#57: xsmsubadp c0d0650f5a07b353 fff8000000000000 0123214569900000 = fff8000000000000
+#58: xsmsubadp 8000000000000000 fff8000000000000 c0d0650f5a07b353 = fff8000000000000
+#59: xsmsubadp 0000000000000000 fff8000000000000 0123214569900000 = fff8000000000000
+#60: xsmsubadp 0123214569900000 fff8000000000000 c0d0650f5a07b353 = fff8000000000000
+#61: xsmsubadp 7ff0000000000000 fff8000000000000 0123214569900000 = fff8000000000000
+#62: xsmsubadp 7ff7ffffffffffff fff8000000000000 c0d0650f5a07b353 = fff8000000000000
+#63: xsmsubadp 7ff8000000000000 fff8000000000000 0123214569900000 = fff8000000000000
+
+#0: xsmsubmdp c0d0650f5a07b353 fff0000000000000 fff0000000000000 = 7ff0000000000000
+#1: xsmsubmdp 0123214569900000 fff0000000000000 c0d0650f5a07b353 = fff0000000000000
+#2: xsmsubmdp c0d0650f5a07b353 fff0000000000000 8000000000000000 = 7ff0000000000000
+#3: xsmsubmdp 0123214569900000 fff0000000000000 0000000000000000 = fff0000000000000
+#4: xsmsubmdp c0d0650f5a07b353 fff0000000000000 0123214569900000 = 7ff0000000000000
+#5: xsmsubmdp 0123214569900000 fff0000000000000 7ff0000000000000 = fff0000000000000
+#6: xsmsubmdp c0d0650f5a07b353 fff0000000000000 7ff7ffffffffffff = 7fffffffffffffff
+#7: xsmsubmdp 0123214569900000 fff0000000000000 7ff8000000000000 = 7ff8000000000000
+#8: xsmsubmdp c0d0650f5a07b353 c0d0650f5a07b353 fff0000000000000 = 7ff0000000000000
+#9: xsmsubmdp 0123214569900000 c0d0650f5a07b353 c0d0650f5a07b353 = 40d0650f5a07b353
+#10: xsmsubmdp c0d0650f5a07b353 c0d0650f5a07b353 8000000000000000 = 41b0cc9d05eec2a7
+#11: xsmsubmdp 0123214569900000 c0d0650f5a07b353 0000000000000000 = 82039a19ca8fcb5f
+#12: xsmsubmdp c0d0650f5a07b353 c0d0650f5a07b353 0123214569900000 = 41b0cc9d05eec2a7
+#13: xsmsubmdp 0123214569900000 c0d0650f5a07b353 7ff0000000000000 = fff0000000000000
+#14: xsmsubmdp c0d0650f5a07b353 c0d0650f5a07b353 7ff7ffffffffffff = 7fffffffffffffff
+#15: xsmsubmdp 0123214569900000 c0d0650f5a07b353 7ff8000000000000 = 7ff8000000000000
+#16: xsmsubmdp c0d0650f5a07b353 8000000000000000 fff0000000000000 = 7ff0000000000000
+#17: xsmsubmdp 0123214569900000 8000000000000000 c0d0650f5a07b353 = 40d0650f5a07b353
+#18: xsmsubmdp c0d0650f5a07b353 8000000000000000 8000000000000000 = 0000000000000000
+#19: xsmsubmdp 0123214569900000 8000000000000000 0000000000000000 = 8000000000000000
+#20: xsmsubmdp c0d0650f5a07b353 8000000000000000 0123214569900000 = 8123214569900000
+#21: xsmsubmdp 0123214569900000 8000000000000000 7ff0000000000000 = fff0000000000000
+#22: xsmsubmdp c0d0650f5a07b353 8000000000000000 7ff7ffffffffffff = 7fffffffffffffff
+#23: xsmsubmdp 0123214569900000 8000000000000000 7ff8000000000000 = 7ff8000000000000
+#24: xsmsubmdp c0d0650f5a07b353 0000000000000000 fff0000000000000 = 7ff0000000000000
+#25: xsmsubmdp 0123214569900000 0000000000000000 c0d0650f5a07b353 = 40d0650f5a07b353
+#26: xsmsubmdp c0d0650f5a07b353 0000000000000000 8000000000000000 = 0000000000000000
+#27: xsmsubmdp 0123214569900000 0000000000000000 0000000000000000 = 0000000000000000
+#28: xsmsubmdp c0d0650f5a07b353 0000000000000000 0123214569900000 = 8123214569900000
+#29: xsmsubmdp 0123214569900000 0000000000000000 7ff0000000000000 = fff0000000000000
+#30: xsmsubmdp c0d0650f5a07b353 0000000000000000 7ff7ffffffffffff = 7fffffffffffffff
+#31: xsmsubmdp 0123214569900000 0000000000000000 7ff8000000000000 = 7ff8000000000000
+#32: xsmsubmdp c0d0650f5a07b353 0123214569900000 fff0000000000000 = 7ff0000000000000
+#33: xsmsubmdp 0123214569900000 0123214569900000 c0d0650f5a07b353 = 40d0650f5a07b353
+#34: xsmsubmdp c0d0650f5a07b353 0123214569900000 8000000000000000 = 82039a19ca8fcb5f
+#35: xsmsubmdp 0123214569900000 0123214569900000 0000000000000000 = 0000000000000000
+#36: xsmsubmdp c0d0650f5a07b353 0123214569900000 404f000000000000 = c04f000000000000
+#37: xsmsubmdp 0123214569900000 0123214569900000 7ff0000000000000 = fff0000000000000
+#38: xsmsubmdp c0d0650f5a07b353 0123214569900000 7ff7ffffffffffff = 7fffffffffffffff
+#39: xsmsubmdp 0123214569900000 0123214569900000 7ff8000000000000 = 7ff8000000000000
+#40: xsmsubmdp c0d0650f5a07b353 7ff0000000000000 fff0000000000000 = 7ff8000000000000
+#41: xsmsubmdp 0123214569900000 7ff0000000000000 c0d0650f5a07b353 = 7ff0000000000000
+#42: xsmsubmdp c0d0650f5a07b353 7ff0000000000000 8000000000000000 = fff0000000000000
+#43: xsmsubmdp 0123214569900000 7ff0000000000000 0000000000000000 = 7ff0000000000000
+#44: xsmsubmdp c0d0650f5a07b353 7ff0000000000000 0123214569900000 = fff0000000000000
+#45: xsmsubmdp 0123214569900000 7ff0000000000000 7ff0000000000000 = 7ff8000000000000
+#46: xsmsubmdp c0d0650f5a07b353 7ff0000000000000 7ff7ffffffffffff = 7fffffffffffffff
+#47: xsmsubmdp 0123214569900000 7ff0000000000000 7ff8000000000000 = 7ff8000000000000
+#48: xsmsubmdp c0d0650f5a07b353 fff7ffffffffffff fff0000000000000 = ffffffffffffffff
+#49: xsmsubmdp 0123214569900000 fff7ffffffffffff c0d0650f5a07b353 = ffffffffffffffff
+#50: xsmsubmdp c0d0650f5a07b353 fff7ffffffffffff 8000000000000000 = ffffffffffffffff
+#51: xsmsubmdp 0123214569900000 fff7ffffffffffff 0000000000000000 = ffffffffffffffff
+#52: xsmsubmdp c0d0650f5a07b353 fff7ffffffffffff 0123214569900000 = ffffffffffffffff
+#53: xsmsubmdp 0123214569900000 fff7ffffffffffff 7ff0000000000000 = ffffffffffffffff
+#54: xsmsubmdp c0d0650f5a07b353 fff7ffffffffffff 7ff7ffffffffffff = ffffffffffffffff
+#55: xsmsubmdp 0123214569900000 fff7ffffffffffff 7ff8000000000000 = ffffffffffffffff
+#56: xsmsubmdp c0d0650f5a07b353 fff8000000000000 fff0000000000000 = fff8000000000000
+#57: xsmsubmdp 0123214569900000 fff8000000000000 c0d0650f5a07b353 = fff8000000000000
+#58: xsmsubmdp c0d0650f5a07b353 fff8000000000000 8000000000000000 = fff8000000000000
+#59: xsmsubmdp 0123214569900000 fff8000000000000 0000000000000000 = fff8000000000000
+#60: xsmsubmdp c0d0650f5a07b353 fff8000000000000 0123214569900000 = fff8000000000000
+#61: xsmsubmdp 0123214569900000 fff8000000000000 7ff0000000000000 = fff8000000000000
+#62: xsmsubmdp c0d0650f5a07b353 fff8000000000000 7ff7ffffffffffff = fff8000000000000
+#63: xsmsubmdp 0123214569900000 fff8000000000000 7ff8000000000000 = fff8000000000000
+
+#0: xsnmaddadp fff0000000000000 fff0000000000000 c0d0650f5a07b353 = 7ff8000000000000
+#1: xsnmaddadp c0d0650f5a07b353 fff0000000000000 0123214569900000 = 7ff0000000000000
+#2: xsnmaddadp 8000000000000000 fff0000000000000 c0d0650f5a07b353 = fff0000000000000
+#3: xsnmaddadp 0000000000000000 fff0000000000000 0123214569900000 = 7ff0000000000000
+#4: xsnmaddadp 0123214569900000 fff0000000000000 c0d0650f5a07b353 = fff0000000000000
+#5: xsnmaddadp 7ff0000000000000 fff0000000000000 0123214569900000 = 7ff8000000000000
+#6: xsnmaddadp 7ff7ffffffffffff fff0000000000000 c0d0650f5a07b353 = 7fffffffffffffff
+#7: xsnmaddadp 7ff8000000000000 fff0000000000000 0123214569900000 = 7ff8000000000000
+#8: xsnmaddadp fff0000000000000 c0d0650f5a07b353 c0d0650f5a07b353 = 7ff0000000000000
+#9: xsnmaddadp c0d0650f5a07b353 c0d0650f5a07b353 0123214569900000 = 40d0650f5a07b353
+#10: xsnmaddadp 8000000000000000 c0d0650f5a07b353 c0d0650f5a07b353 = c1b0cc9d05eec2a7
+#11: xsnmaddadp 0000000000000000 c0d0650f5a07b353 0123214569900000 = 02039a19ca8fcb5f
+#12: xsnmaddadp 0123214569900000 c0d0650f5a07b353 c0d0650f5a07b353 = c1b0cc9d05eec2a7
+#13: xsnmaddadp 7ff0000000000000 c0d0650f5a07b353 0123214569900000 = fff0000000000000
+#14: xsnmaddadp 7ff7ffffffffffff c0d0650f5a07b353 c0d0650f5a07b353 = 7fffffffffffffff
+#15: xsnmaddadp 7ff8000000000000 c0d0650f5a07b353 0123214569900000 = 7ff8000000000000
+#16: xsnmaddadp fff0000000000000 8000000000000000 c0d0650f5a07b353 = 7ff0000000000000
+#17: xsnmaddadp c0d0650f5a07b353 8000000000000000 0123214569900000 = 40d0650f5a07b353
+#18: xsnmaddadp 8000000000000000 8000000000000000 c0d0650f5a07b353 = 8000000000000000
+#19: xsnmaddadp 0000000000000000 8000000000000000 0123214569900000 = 8000000000000000
+#20: xsnmaddadp 0123214569900000 8000000000000000 c0d0650f5a07b353 = 8123214569900000
+#21: xsnmaddadp 7ff0000000000000 8000000000000000 0123214569900000 = fff0000000000000
+#22: xsnmaddadp 7ff7ffffffffffff 8000000000000000 c0d0650f5a07b353 = 7fffffffffffffff
+#23: xsnmaddadp 7ff8000000000000 8000000000000000 0123214569900000 = 7ff8000000000000
+#24: xsnmaddadp fff0000000000000 0000000000000000 c0d0650f5a07b353 = 7ff0000000000000
+#25: xsnmaddadp c0d0650f5a07b353 0000000000000000 0123214569900000 = 40d0650f5a07b353
+#26: xsnmaddadp 8000000000000000 0000000000000000 c0d0650f5a07b353 = 0000000000000000
+#27: xsnmaddadp 0000000000000000 0000000000000000 0123214569900000 = 8000000000000000
+#28: xsnmaddadp 0123214569900000 0000000000000000 c0d0650f5a07b353 = 8123214569900000
+#29: xsnmaddadp 7ff0000000000000 0000000000000000 0123214569900000 = fff0000000000000
+#30: xsnmaddadp 7ff7ffffffffffff 0000000000000000 c0d0650f5a07b353 = 7fffffffffffffff
+#31: xsnmaddadp 7ff8000000000000 0000000000000000 0123214569900000 = 7ff8000000000000
+#32: xsnmaddadp fff0000000000000 0123214569900000 c0d0650f5a07b353 = 7ff0000000000000
+#33: xsnmaddadp c0d0650f5a07b353 0123214569900000 0123214569900000 = 40d0650f5a07b353
+#34: xsnmaddadp 8000000000000000 0123214569900000 c0d0650f5a07b353 = 02039a19ca8fcb5f
+#35: xsnmaddadp 0000000000000000 0123214569900000 0123214569900000 = 8000000000000000
+#36: xsnmaddadp 404f000000000000 0123214569900000 c0d0650f5a07b353 = c04f000000000000
+#37: xsnmaddadp 7ff0000000000000 0123214569900000 0123214569900000 = fff0000000000000
+#38: xsnmaddadp 7ff7ffffffffffff 0123214569900000 c0d0650f5a07b353 = 7fffffffffffffff
+#39: xsnmaddadp 7ff8000000000000 0123214569900000 0123214569900000 = 7ff8000000000000
+#40: xsnmaddadp fff0000000000000 7ff0000000000000 c0d0650f5a07b353 = 7ff0000000000000
+#41: xsnmaddadp c0d0650f5a07b353 7ff0000000000000 0123214569900000 = fff0000000000000
+#42: xsnmaddadp 8000000000000000 7ff0000000000000 c0d0650f5a07b353 = 7ff0000000000000
+#43: xsnmaddadp 0000000000000000 7ff0000000000000 0123214569900000 = fff0000000000000
+#44: xsnmaddadp 0123214569900000 7ff0000000000000 c0d0650f5a07b353 = 7ff0000000000000
+#45: xsnmaddadp 7ff0000000000000 7ff0000000000000 0123214569900000 = fff0000000000000
+#46: xsnmaddadp 7ff7ffffffffffff 7ff0000000000000 c0d0650f5a07b353 = 7fffffffffffffff
+#47: xsnmaddadp 7ff8000000000000 7ff0000000000000 0123214569900000 = 7ff8000000000000
+#48: xsnmaddadp fff0000000000000 fff7ffffffffffff c0d0650f5a07b353 = ffffffffffffffff
+#49: xsnmaddadp c0d0650f5a07b353 fff7ffffffffffff 0123214569900000 = ffffffffffffffff
+#50: xsnmaddadp 8000000000000000 fff7ffffffffffff c0d0650f5a07b353 = ffffffffffffffff
+#51: xsnmaddadp 0000000000000000 fff7ffffffffffff 0123214569900000 = ffffffffffffffff
+#52: xsnmaddadp 0123214569900000 fff7ffffffffffff c0d0650f5a07b353 = ffffffffffffffff
+#53: xsnmaddadp 7ff0000000000000 fff7ffffffffffff 0123214569900000 = ffffffffffffffff
+#54: xsnmaddadp 7ff7ffffffffffff fff7ffffffffffff c0d0650f5a07b353 = ffffffffffffffff
+#55: xsnmaddadp 7ff8000000000000 fff7ffffffffffff 0123214569900000 = ffffffffffffffff
+#56: xsnmaddadp fff0000000000000 fff8000000000000 c0d0650f5a07b353 = fff8000000000000
+#57: xsnmaddadp c0d0650f5a07b353 fff8000000000000 0123214569900000 = fff8000000000000
+#58: xsnmaddadp 8000000000000000 fff8000000000000 c0d0650f5a07b353 = fff8000000000000
+#59: xsnmaddadp 0000000000000000 fff8000000000000 0123214569900000 = fff8000000000000
+#60: xsnmaddadp 0123214569900000 fff8000000000000 c0d0650f5a07b353 = fff8000000000000
+#61: xsnmaddadp 7ff0000000000000 fff8000000000000 0123214569900000 = fff8000000000000
+#62: xsnmaddadp 7ff7ffffffffffff fff8000000000000 c0d0650f5a07b353 = fff8000000000000
+#63: xsnmaddadp 7ff8000000000000 fff8000000000000 0123214569900000 = fff8000000000000
+
+#0: xsnmaddmdp c0d0650f5a07b353 fff0000000000000 fff0000000000000 = 7ff8000000000000
+#1: xsnmaddmdp 0123214569900000 fff0000000000000 c0d0650f5a07b353 = 7ff0000000000000
+#2: xsnmaddmdp c0d0650f5a07b353 fff0000000000000 8000000000000000 = fff0000000000000
+#3: xsnmaddmdp 0123214569900000 fff0000000000000 0000000000000000 = 7ff0000000000000
+#4: xsnmaddmdp c0d0650f5a07b353 fff0000000000000 0123214569900000 = fff0000000000000
+#5: xsnmaddmdp 0123214569900000 fff0000000000000 7ff0000000000000 = 7ff8000000000000
+#6: xsnmaddmdp c0d0650f5a07b353 fff0000000000000 7ff7ffffffffffff = 7fffffffffffffff
+#7: xsnmaddmdp 0123214569900000 fff0000000000000 7ff8000000000000 = 7ff8000000000000
+#8: xsnmaddmdp c0d0650f5a07b353 c0d0650f5a07b353 fff0000000000000 = 7ff0000000000000
+#9: xsnmaddmdp 0123214569900000 c0d0650f5a07b353 c0d0650f5a07b353 = 40d0650f5a07b353
+#10: xsnmaddmdp c0d0650f5a07b353 c0d0650f5a07b353 8000000000000000 = c1b0cc9d05eec2a7
+#11: xsnmaddmdp 0123214569900000 c0d0650f5a07b353 0000000000000000 = 02039a19ca8fcb5f
+#12: xsnmaddmdp c0d0650f5a07b353 c0d0650f5a07b353 0123214569900000 = c1b0cc9d05eec2a7
+#13: xsnmaddmdp 0123214569900000 c0d0650f5a07b353 7ff0000000000000 = fff0000000000000
+#14: xsnmaddmdp c0d0650f5a07b353 c0d0650f5a07b353 7ff7ffffffffffff = 7fffffffffffffff
+#15: xsnmaddmdp 0123214569900000 c0d0650f5a07b353 7ff8000000000000 = 7ff8000000000000
+#16: xsnmaddmdp c0d0650f5a07b353 8000000000000000 fff0000000000000 = 7ff0000000000000
+#17: xsnmaddmdp 0123214569900000 8000000000000000 c0d0650f5a07b353 = 40d0650f5a07b353
+#18: xsnmaddmdp c0d0650f5a07b353 8000000000000000 8000000000000000 = 8000000000000000
+#19: xsnmaddmdp 0123214569900000 8000000000000000 0000000000000000 = 8000000000000000
+#20: xsnmaddmdp c0d0650f5a07b353 8000000000000000 0123214569900000 = 8123214569900000
+#21: xsnmaddmdp 0123214569900000 8000000000000000 7ff0000000000000 = fff0000000000000
+#22: xsnmaddmdp c0d0650f5a07b353 8000000000000000 7ff7ffffffffffff = 7fffffffffffffff
+#23: xsnmaddmdp 0123214569900000 8000000000000000 7ff8000000000000 = 7ff8000000000000
+#24: xsnmaddmdp c0d0650f5a07b353 0000000000000000 fff0000000000000 = 7ff0000000000000
+#25: xsnmaddmdp 0123214569900000 0000000000000000 c0d0650f5a07b353 = 40d0650f5a07b353
+#26: xsnmaddmdp c0d0650f5a07b353 0000000000000000 8000000000000000 = 0000000000000000
+#27: xsnmaddmdp 0123214569900000 0000000000000000 0000000000000000 = 8000000000000000
+#28: xsnmaddmdp c0d0650f5a07b353 0000000000000000 0123214569900000 = 8123214569900000
+#29: xsnmaddmdp 0123214569900000 0000000000000000 7ff0000000000000 = fff0000000000000
+#30: xsnmaddmdp c0d0650f5a07b353 0000000000000000 7ff7ffffffffffff = 7fffffffffffffff
+#31: xsnmaddmdp 0123214569900000 0000000000000000 7ff8000000000000 = 7ff8000000000000
+#32: xsnmaddmdp c0d0650f5a07b353 0123214569900000 fff0000000000000 = 7ff0000000000000
+#33: xsnmaddmdp 0123214569900000 0123214569900000 c0d0650f5a07b353 = 40d0650f5a07b353
+#34: xsnmaddmdp c0d0650f5a07b353 0123214569900000 8000000000000000 = 02039a19ca8fcb5f
+#35: xsnmaddmdp 0123214569900000 0123214569900000 0000000000000000 = 8000000000000000
+#36: xsnmaddmdp c0d0650f5a07b353 0123214569900000 404f000000000000 = c04f000000000000
+#37: xsnmaddmdp 0123214569900000 0123214569900000 7ff0000000000000 = fff0000000000000
+#38: xsnmaddmdp c0d0650f5a07b353 0123214569900000 7ff7ffffffffffff = 7fffffffffffffff
+#39: xsnmaddmdp 0123214569900000 0123214569900000 7ff8000000000000 = 7ff8000000000000
+#40: xsnmaddmdp c0d0650f5a07b353 7ff0000000000000 fff0000000000000 = 7ff0000000000000
+#41: xsnmaddmdp 0123214569900000 7ff0000000000000 c0d0650f5a07b353 = fff0000000000000
+#42: xsnmaddmdp c0d0650f5a07b353 7ff0000000000000 8000000000000000 = 7ff0000000000000
+#43: xsnmaddmdp 0123214569900000 7ff0000000000000 0000000000000000 = fff0000000000000
+#44: xsnmaddmdp c0d0650f5a07b353 7ff0000000000000 0123214569900000 = 7ff0000000000000
+#45: xsnmaddmdp 0123214569900000 7ff0000000000000 7ff0000000000000 = fff0000000000000
+#46: xsnmaddmdp c0d0650f5a07b353 7ff0000000000000 7ff7ffffffffffff = 7fffffffffffffff
+#47: xsnmaddmdp 0123214569900000 7ff0000000000000 7ff8000000000000 = 7ff8000000000000
+#48: xsnmaddmdp c0d0650f5a07b353 fff7ffffffffffff fff0000000000000 = ffffffffffffffff
+#49: xsnmaddmdp 0123214569900000 fff7ffffffffffff c0d0650f5a07b353 = ffffffffffffffff
+#50: xsnmaddmdp c0d0650f5a07b353 fff7ffffffffffff 8000000000000000 = ffffffffffffffff
+#51: xsnmaddmdp 0123214569900000 fff7ffffffffffff 0000000000000000 = ffffffffffffffff
+#52: xsnmaddmdp c0d0650f5a07b353 fff7ffffffffffff 0123214569900000 = ffffffffffffffff
+#53: xsnmaddmdp 0123214569900000 fff7ffffffffffff 7ff0000000000000 = ffffffffffffffff
+#54: xsnmaddmdp c0d0650f5a07b353 fff7ffffffffffff 7ff7ffffffffffff = ffffffffffffffff
+#55: xsnmaddmdp 0123214569900000 fff7ffffffffffff 7ff8000000000000 = ffffffffffffffff
+#56: xsnmaddmdp c0d0650f5a07b353 fff8000000000000 fff0000000000000 = fff8000000000000
+#57: xsnmaddmdp 0123214569900000 fff8000000000000 c0d0650f5a07b353 = fff8000000000000
+#58: xsnmaddmdp c0d0650f5a07b353 fff8000000000000 8000000000000000 = fff8000000000000
+#59: xsnmaddmdp 0123214569900000 fff8000000000000 0000000000000000 = fff8000000000000
+#60: xsnmaddmdp c0d0650f5a07b353 fff8000000000000 0123214569900000 = fff8000000000000
+#61: xsnmaddmdp 0123214569900000 fff8000000000000 7ff0000000000000 = fff8000000000000
+#62: xsnmaddmdp c0d0650f5a07b353 fff8000000000000 7ff7ffffffffffff = fff8000000000000
+#63: xsnmaddmdp 0123214569900000 fff8000000000000 7ff8000000000000 = fff8000000000000
+
+#0: xsmuldp fff0000000000000 fff0000000000000 = 7ff0000000000000
+#1: xsmuldp fff0000000000000 c0d0650f5a07b353 = 7ff0000000000000
+#2: xsmuldp fff0000000000000 8000000000000000 = 7ff8000000000000
+#3: xsmuldp fff0000000000000 0000000000000000 = 7ff8000000000000
+#4: xsmuldp fff0000000000000 0123214569900000 = fff0000000000000
+#5: xsmuldp fff0000000000000 7ff0000000000000 = fff0000000000000
+#6: xsmuldp fff0000000000000 7ff7ffffffffffff = 7fffffffffffffff
+#7: xsmuldp fff0000000000000 7ff8000000000000 = 7ff8000000000000
+#8: xsmuldp c0d0650f5a07b353 fff0000000000000 = 7ff0000000000000
+#9: xsmuldp c0d0650f5a07b353 c0d0650f5a07b353 = 41b0cc9d05eec2a7
+#10: xsmuldp c0d0650f5a07b353 8000000000000000 = 0000000000000000
+#11: xsmuldp c0d0650f5a07b353 0000000000000000 = 8000000000000000
+#12: xsmuldp c0d0650f5a07b353 0123214569900000 = 82039a19ca8fcb5f
+#13: xsmuldp c0d0650f5a07b353 7ff0000000000000 = fff0000000000000
+#14: xsmuldp c0d0650f5a07b353 7ff7ffffffffffff = 7fffffffffffffff
+#15: xsmuldp c0d0650f5a07b353 7ff8000000000000 = 7ff8000000000000
+#16: xsmuldp 8000000000000000 fff0000000000000 = 7ff8000000000000
+#17: xsmuldp 8000000000000000 c0d0650f5a07b353 = 0000000000000000
+#18: xsmuldp 8000000000000000 8000000000000000 = 0000000000000000
+#19: xsmuldp 8000000000000000 0000000000000000 = 8000000000000000
+#20: xsmuldp 8000000000000000 0123214569900000 = 8000000000000000
+#21: xsmuldp 8000000000000000 7ff0000000000000 = 7ff8000000000000
+#22: xsmuldp 8000000000000000 7ff7ffffffffffff = 7fffffffffffffff
+#23: xsmuldp 8000000000000000 7ff8000000000000 = 7ff8000000000000
+#24: xsmuldp 0000000000000000 fff0000000000000 = 7ff8000000000000
+#25: xsmuldp 0000000000000000 c0d0650f5a07b353 = 8000000000000000
+#26: xsmuldp 0000000000000000 8000000000000000 = 8000000000000000
+#27: xsmuldp 0000000000000000 0000000000000000 = 0000000000000000
+#28: xsmuldp 0000000000000000 0123214569900000 = 0000000000000000
+#29: xsmuldp 0000000000000000 7ff0000000000000 = 7ff8000000000000
+#30: xsmuldp 0000000000000000 7ff7ffffffffffff = 7fffffffffffffff
+#31: xsmuldp 0000000000000000 7ff8000000000000 = 7ff8000000000000
+#32: xsmuldp 0123214569900000 fff0000000000000 = fff0000000000000
+#33: xsmuldp 0123214569900000 c0d0650f5a07b353 = 82039a19ca8fcb5f
+#34: xsmuldp 0123214569900000 8000000000000000 = 8000000000000000
+#35: xsmuldp 0123214569900000 0000000000000000 = 0000000000000000
+#36: xsmuldp 0123214569900000 404f000000000000 = 0182883b3e438000
+#37: xsmuldp 0123214569900000 7ff0000000000000 = 7ff0000000000000
+#38: xsmuldp 0123214569900000 7ff7ffffffffffff = 7fffffffffffffff
+#39: xsmuldp 0123214569900000 7ff8000000000000 = 7ff8000000000000
+#40: xsmuldp 7ff0000000000000 fff0000000000000 = fff0000000000000
+#41: xsmuldp 7ff0000000000000 c0d0650f5a07b353 = fff0000000000000
+#42: xsmuldp 7ff0000000000000 8000000000000000 = 7ff8000000000000
+#43: xsmuldp 7ff0000000000000 0000000000000000 = 7ff8000000000000
+#44: xsmuldp 7ff0000000000000 0123214569900000 = 7ff0000000000000
+#45: xsmuldp 7ff0000000000000 7ff0000000000000 = 7ff0000000000000
+#46: xsmuldp 7ff0000000000000 7ff7ffffffffffff = 7fffffffffffffff
+#47: xsmuldp 7ff0000000000000 7ff8000000000000 = 7ff8000000000000
+#48: xsmuldp fff7ffffffffffff fff0000000000000 = ffffffffffffffff
+#49: xsmuldp fff7ffffffffffff c0d0650f5a07b353 = ffffffffffffffff
+#50: xsmuldp fff7ffffffffffff 8000000000000000 = ffffffffffffffff
+#51: xsmuldp fff7ffffffffffff 0000000000000000 = ffffffffffffffff
+#52: xsmuldp fff7ffffffffffff 0123214569900000 = ffffffffffffffff
+#53: xsmuldp fff7ffffffffffff 7ff0000000000000 = ffffffffffffffff
+#54: xsmuldp fff7ffffffffffff 7ff7ffffffffffff = ffffffffffffffff
+#55: xsmuldp fff7ffffffffffff 7ff8000000000000 = ffffffffffffffff
+#56: xsmuldp fff8000000000000 fff0000000000000 = fff8000000000000
+#57: xsmuldp fff8000000000000 c0d0650f5a07b353 = fff8000000000000
+#58: xsmuldp fff8000000000000 8000000000000000 = fff8000000000000
+#59: xsmuldp fff8000000000000 0000000000000000 = fff8000000000000
+#60: xsmuldp fff8000000000000 0123214569900000 = fff8000000000000
+#61: xsmuldp fff8000000000000 7ff0000000000000 = fff8000000000000
+#62: xsmuldp fff8000000000000 7ff7ffffffffffff = fff8000000000000
+#63: xsmuldp fff8000000000000 7ff8000000000000 = fff8000000000000
+
+#0: xssubdp fff0000000000000 fff0000000000000 = 7ff8000000000000
+#1: xssubdp fff0000000000000 c0d0650f5a07b353 = fff0000000000000
+#2: xssubdp fff0000000000000 8000000000000000 = fff0000000000000
+#3: xssubdp fff0000000000000 0000000000000000 = fff0000000000000
+#4: xssubdp fff0000000000000 0123214569900000 = fff0000000000000
+#5: xssubdp fff0000000000000 7ff0000000000000 = fff0000000000000
+#6: xssubdp fff0000000000000 7ff7ffffffffffff = 7fffffffffffffff
+#7: xssubdp fff0000000000000 7ff8000000000000 = 7ff8000000000000
+#8: xssubdp c0d0650f5a07b353 fff0000000000000 = 7ff0000000000000
+#9: xssubdp c0d0650f5a07b353 c0d0650f5a07b353 = 0000000000000000
+#10: xssubdp c0d0650f5a07b353 8000000000000000 = c0d0650f5a07b353
+#11: xssubdp c0d0650f5a07b353 0000000000000000 = c0d0650f5a07b353
+#12: xssubdp c0d0650f5a07b353 0123214569900000 = c0d0650f5a07b353
+#13: xssubdp c0d0650f5a07b353 7ff0000000000000 = fff0000000000000
+#14: xssubdp c0d0650f5a07b353 7ff7ffffffffffff = 7fffffffffffffff
+#15: xssubdp c0d0650f5a07b353 7ff8000000000000 = 7ff8000000000000
+#16: xssubdp 8000000000000000 fff0000000000000 = 7ff0000000000000
+#17: xssubdp 8000000000000000 c0d0650f5a07b353 = 40d0650f5a07b353
+#18: xssubdp 8000000000000000 8000000000000000 = 0000000000000000
+#19: xssubdp 8000000000000000 0000000000000000 = 8000000000000000
+#20: xssubdp 8000000000000000 0123214569900000 = 8123214569900000
+#21: xssubdp 8000000000000000 7ff0000000000000 = fff0000000000000
+#22: xssubdp 8000000000000000 7ff7ffffffffffff = 7fffffffffffffff
+#23: xssubdp 8000000000000000 7ff8000000000000 = 7ff8000000000000
+#24: xssubdp 0000000000000000 fff0000000000000 = 7ff0000000000000
+#25: xssubdp 0000000000000000 c0d0650f5a07b353 = 40d0650f5a07b353
+#26: xssubdp 0000000000000000 8000000000000000 = 0000000000000000
+#27: xssubdp 0000000000000000 0000000000000000 = 0000000000000000
+#28: xssubdp 0000000000000000 0123214569900000 = 8123214569900000
+#29: xssubdp 0000000000000000 7ff0000000000000 = fff0000000000000
+#30: xssubdp 0000000000000000 7ff7ffffffffffff = 7fffffffffffffff
+#31: xssubdp 0000000000000000 7ff8000000000000 = 7ff8000000000000
+#32: xssubdp 0123214569900000 fff0000000000000 = 7ff0000000000000
+#33: xssubdp 0123214569900000 c0d0650f5a07b353 = 40d0650f5a07b353
+#34: xssubdp 0123214569900000 8000000000000000 = 0123214569900000
+#35: xssubdp 0123214569900000 0000000000000000 = 0123214569900000
+#36: xssubdp 0123214569900000 404f000000000000 = c04f000000000000
+#37: xssubdp 0123214569900000 7ff0000000000000 = fff0000000000000
+#38: xssubdp 0123214569900000 7ff7ffffffffffff = 7fffffffffffffff
+#39: xssubdp 0123214569900000 7ff8000000000000 = 7ff8000000000000
+#40: xssubdp 7ff0000000000000 fff0000000000000 = 7ff0000000000000
+#41: xssubdp 7ff0000000000000 c0d0650f5a07b353 = 7ff0000000000000
+#42: xssubdp 7ff0000000000000 8000000000000000 = 7ff0000000000000
+#43: xssubdp 7ff0000000000000 0000000000000000 = 7ff0000000000000
+#44: xssubdp 7ff0000000000000 0123214569900000 = 7ff0000000000000
+#45: xssubdp 7ff0000000000000 7ff0000000000000 = 7ff8000000000000
+#46: xssubdp 7ff0000000000000 7ff7ffffffffffff = 7fffffffffffffff
+#47: xssubdp 7ff0000000000000 7ff8000000000000 = 7ff8000000000000
+#48: xssubdp fff7ffffffffffff fff0000000000000 = ffffffffffffffff
+#49: xssubdp fff7ffffffffffff c0d0650f5a07b353 = ffffffffffffffff
+#50: xssubdp fff7ffffffffffff 8000000000000000 = ffffffffffffffff
+#51: xssubdp fff7ffffffffffff 0000000000000000 = ffffffffffffffff
+#52: xssubdp fff7ffffffffffff 0123214569900000 = ffffffffffffffff
+#53: xssubdp fff7ffffffffffff 7ff0000000000000 = ffffffffffffffff
+#54: xssubdp fff7ffffffffffff 7ff7ffffffffffff = ffffffffffffffff
+#55: xssubdp fff7ffffffffffff 7ff8000000000000 = ffffffffffffffff
+#56: xssubdp fff8000000000000 fff0000000000000 = fff8000000000000
+#57: xssubdp fff8000000000000 c0d0650f5a07b353 = fff8000000000000
+#58: xssubdp fff8000000000000 8000000000000000 = fff8000000000000
+#59: xssubdp fff8000000000000 0000000000000000 = fff8000000000000
+#60: xssubdp fff8000000000000 0123214569900000 = fff8000000000000
+#61: xssubdp fff8000000000000 7ff0000000000000 = fff8000000000000
+#62: xssubdp fff8000000000000 7ff7ffffffffffff = fff8000000000000
+#63: xssubdp fff8000000000000 7ff8000000000000 = fff8000000000000
+
+
+Test VSX scalar integer conversion instructions
+#0: xscvdpsxds 3fd8000000000000 => 0000000000000000
+#1: xscvdpsxds 404f000000000000 => 000000000000003e
+#2: xscvdpsxds 0018000000b77501 => 0000000000000000
+#3: xscvdpsxds 7fe800000000051b => 7fffffffffffffff
+#4: xscvdpsxds 0123214569900000 => 0000000000000000
+#5: xscvdpsxds 0000000000000000 => 0000000000000000
+#6: xscvdpsxds 8000000000000000 => 0000000000000000
+#7: xscvdpsxds 7ff0000000000000 => 7fffffffffffffff
+#8: xscvdpsxds fff0000000000000 => 8000000000000000
+#9: xscvdpsxds 7ff7ffffffffffff => 8000000000000000
+#10: xscvdpsxds fff7ffffffffffff => 8000000000000000
+#11: xscvdpsxds 7ff8000000000000 => 8000000000000000
+#12: xscvdpsxds fff8000000000000 => 8000000000000000
+#13: xscvdpsxds 8008340000078000 => 0000000000000000
+#14: xscvdpsxds c0d0650f5a07b353 => ffffffffffffbe6c
+
+#0: xscvsxddp 3fd8000000000000 => 43cfec0000000000
+#1: xscvsxddp 404f000000000000 => 43d013c000000000
+#2: xscvsxddp 0018000000b77501 => 4338000000b77501
+#3: xscvsxddp 7fe800000000051b => 43dffa0000000001
+#4: xscvsxddp 0123214569900000 => 4372321456990000
+#5: xscvsxddp 0000000000000000 => 0000000000000000
+#6: xscvsxddp 8000000000000000 => c3e0000000000000
+#7: xscvsxddp 7ff0000000000000 => 43dffc0000000000
+#8: xscvsxddp fff0000000000000 => c330000000000000
+#9: xscvsxddp 7ff7ffffffffffff => 43dffe0000000000
+#10: xscvsxddp fff7ffffffffffff => c320000000000002
+#11: xscvsxddp 7ff8000000000000 => 43dffe0000000000
+#12: xscvsxddp fff8000000000000 => c320000000000000
+#13: xscvsxddp 8008340000078000 => c3dffdf2fffffe20
+#14: xscvsxddp c0d0650f5a07b353 => c3cf97cd7852fc26
+
+#0: xscvuxddp 3fd8000000000000 => 43cfec0000000000
+#1: xscvuxddp 404f000000000000 => 43d013c000000000
+#2: xscvuxddp 0018000000b77501 => 4338000000b77501
+#3: xscvuxddp 7fe800000000051b => 43dffa0000000001
+#4: xscvuxddp 0123214569900000 => 4372321456990000
+#5: xscvuxddp 0000000000000000 => 0000000000000000
+#6: xscvuxddp 8000000000000000 => 43e0000000000000
+#7: xscvuxddp 7ff0000000000000 => 43dffc0000000000
+#8: xscvuxddp fff0000000000000 => 43effe0000000000
+#9: xscvuxddp 7ff7ffffffffffff => 43dffe0000000000
+#10: xscvuxddp fff7ffffffffffff => 43efff0000000000
+#11: xscvuxddp 7ff8000000000000 => 43dffe0000000000
+#12: xscvuxddp fff8000000000000 => 43efff0000000000
+#13: xscvuxddp 8008340000078000 => 43e00106800000f0
+#14: xscvuxddp c0d0650f5a07b353 => 43e81a0ca1eb40f6
+
+
+Testcase PASSED
--- valgrind-3.6.0/none/tests/ppc64/test_isa_2_06_part1.stderr.exp	(revision 0)
+++ valgrind-3.6.0/none/tests/ppc64/test_isa_2_06_part1.stderr.exp	(revision 11700)
@@ -0,0 +1,2 @@
+
+
--- valgrind-3.6.0/none/tests/ppc64/test_isa_2_06_part1.vgtest	(revision 0)
+++ valgrind-3.6.0/none/tests/ppc64/test_isa_2_06_part1.vgtest	(revision 11700)
@@ -0,0 +1,2 @@
+prereq: ../../../tests/check_isa-2_06_cap
+prog: test_isa_2_06_part1
--- valgrind-3.6.0/none/tests/ppc64/test_isa_2_06_part1.c	(revision 0)
+++ valgrind-3.6.0/none/tests/ppc64/test_isa_2_06_part1.c	(revision 11700)
@@ -0,0 +1,2189 @@
+/*  Copyright (C) 2011 IBM
+
+ Author: Maynard Johnson <maynardj@us.ibm.com>
+
+ This program is free software; you can redistribute it and/or
+ modify it under the terms of the GNU General Public License as
+ published by the Free Software Foundation; either version 2 of the
+ License, or (at your option) any later version.
+
+ This program is distributed in the hope that it will be useful, but
+ WITHOUT ANY WARRANTY; without even the implied warranty of
+ MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ General Public License for more details.
+
+ You should have received a copy of the GNU General Public License
+ along with this program; if not, write to the Free Software
+ Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+ 02111-1307, USA.
+
+ The GNU General Public License is contained in the file COPYING.
+ */
+
+#ifdef HAS_VSX
+
+#include <stdio.h>
+#include <stdint.h>
+#include <stdlib.h>
+#include <string.h>
+#include <malloc.h>
+#include <altivec.h>
+
+#ifndef __powerpc64__
+typedef uint32_t HWord_t;
+#else
+typedef uint64_t HWord_t;
+#endif /* __powerpc64__ */
+
+static int errors;
+register HWord_t r14 __asm__ ("r14");
+register HWord_t r15 __asm__ ("r15");
+register HWord_t r16 __asm__ ("r16");
+register HWord_t r17 __asm__ ("r17");
+register double f14 __asm__ ("fr14");
+register double f15 __asm__ ("fr15");
+register double f16 __asm__ ("fr16");
+register double f17 __asm__ ("fr17");
+
+static volatile unsigned int cond_reg;
+
+#define ALLCR "cr0","cr1","cr2","cr3","cr4","cr5","cr6","cr7"
+
+#define SET_CR(_arg) \
+      __asm__ __volatile__ ("mtcr  %0" : : "b"(_arg) : ALLCR );
+
+#define SET_XER(_arg) \
+      __asm__ __volatile__ ("mtxer %0" : : "b"(_arg) : "xer" );
+
+#define GET_CR(_lval) \
+      __asm__ __volatile__ ("mfcr %0"  : "=b"(_lval) )
+
+#define GET_XER(_lval) \
+      __asm__ __volatile__ ("mfxer %0" : "=b"(_lval) )
+
+#define GET_CR_XER(_lval_cr,_lval_xer) \
+   do { GET_CR(_lval_cr); GET_XER(_lval_xer); } while (0)
+
+#define SET_CR_ZERO \
+      SET_CR(0)
+
+#define SET_XER_ZERO \
+      SET_XER(0)
+
+#define SET_CR_XER_ZERO \
+   do { SET_CR_ZERO; SET_XER_ZERO; } while (0)
+
+#define SET_FPSCR_ZERO \
+   do { double _d = 0.0; \
+        __asm__ __volatile__ ("mtfsf 0xFF, %0" : : "f"(_d) ); \
+   } while (0)
+
+
+typedef void (*test_func_t)(void);
+typedef struct ldst_test ldst_test_t;
+typedef struct vsx_logic_test logic_test_t;
+typedef struct xs_conv_test xs_conv_test_t;
+typedef struct p7_fp_test fp_test_t;
+typedef struct vx_fp_test vx_fp_test_t;
+typedef struct vsx_move_test move_test_t;
+typedef struct vsx_permute_test permute_test_t;
+typedef struct test_table test_table_t;
+
+static double *fargs = NULL;
+static int nb_fargs;
+
+/* These functions below that construct a table of floating point
+ * values were lifted from none/tests/ppc32/jm-insns.c.
+ */
+
+#if defined (DEBUG_ARGS_BUILD)
+#define AB_DPRINTF(fmt, args...) do { fprintf(stderr, fmt , ##args); } while (0)
+#else
+#define AB_DPRINTF(fmt, args...) do { } while (0)
+#endif
+
+static inline void register_farg (void *farg,
+                                  int s, uint16_t _exp, uint64_t mant)
+{
+   uint64_t tmp;
+
+   tmp = ((uint64_t)s << 63) | ((uint64_t)_exp << 52) | mant;
+   *(uint64_t *)farg = tmp;
+   AB_DPRINTF("%d %03x %013llx => %016llx %0e\n",
+              s, _exp, mant, *(uint64_t *)farg, *(double *)farg);
+}
+
+static void build_fargs_table(void)
+/*
+ * Double precision:
+ * Sign goes from zero to one               (1 bit)
+ * Exponent goes from 0 to ((1 << 12) - 1)  (11 bits)
+ * Mantissa goes from 1 to ((1 << 52) - 1)  (52 bits)
+ * + special values:
+ * +0.0      : 0 0x000 0x0000000000000 => 0x0000000000000000
+ * -0.0      : 1 0x000 0x0000000000000 => 0x8000000000000000
+ * +infinity : 0 0x7FF 0x0000000000000 => 0x7FF0000000000000
+ * -infinity : 1 0x7FF 0x0000000000000 => 0xFFF0000000000000
+ * +QNaN     : 0 0x7FF 0x7FFFFFFFFFFFF => 0x7FF7FFFFFFFFFFFF
+ * -QNaN     : 1 0x7FF 0x7FFFFFFFFFFFF => 0xFFF7FFFFFFFFFFFF
+ * +SNaN     : 0 0x7FF 0x8000000000000 => 0x7FF8000000000000
+ * -SNaN     : 1 0x7FF 0x8000000000000 => 0xFFF8000000000000
+ * (8 values)
+ *
+ * Single precision
+ * Sign:     1 bit
+ * Exponent: 8 bits
+ * Mantissa: 23 bits
+ * +0.0      : 0 0x00 0x000000 => 0x00000000
+ * -0.0      : 1 0x00 0x000000 => 0x80000000
+ * +infinity : 0 0xFF 0x000000 => 0x7F800000
+ * -infinity : 1 0xFF 0x000000 => 0xFF800000
+ * +QNaN     : 0 0xFF 0x3FFFFF => 0x7FBFFFFF
+ * -QNaN     : 1 0xFF 0x3FFFFF => 0xFFBFFFFF
+ * +SNaN     : 0 0xFF 0x400000 => 0x7FC00000
+ * -SNaN     : 1 0xFF 0x400000 => 0xFFC00000
+*/
+{
+   uint64_t mant;
+   uint16_t _exp, e1;
+   int s;
+   int i=0;
+
+   if (nb_fargs)
+      return;
+
+   fargs = malloc( 16 * sizeof(double) );
+   for (s = 0; s < 2; s++) {
+      for (e1 = 0x001;; e1 = ((e1 + 1) << 13) + 7) {
+         if (e1 >= 0x400)
+            e1 = 0x3fe;
+         _exp = e1;
+         for (mant = 0x0000000000001ULL; mant < (1ULL << 52);
+         /* Add 'random' bits */
+         mant = ((mant + 0x4A6) << 29) + 0x359) {
+            register_farg( &fargs[i++], s, _exp, mant );
+         }
+         if (e1 == 0x3fe)
+            break;
+      }
+   }
+   // add a few smaller values to fargs . . .
+   s = 0;
+   _exp = 0x002;
+   mant = 0x0000000000b01ULL;
+   register_farg(&fargs[i++], s, _exp, mant);
+
+   _exp = 0x000;
+   mant = 0x00000203f0b3dULL;
+   register_farg(&fargs[i++], s, _exp, mant);
+
+   mant = 0x00000005a203dULL;
+   register_farg(&fargs[i++], s, _exp, mant);
+
+   s = 1;
+   _exp = 0x002;
+   mant = 0x0000000000b01ULL;
+   register_farg(&fargs[i++], s, _exp, mant);
+
+   _exp = 0x000;
+   mant = 0x00000203f0b3dULL;
+   register_farg(&fargs[i++], s, _exp, mant);
+
+   nb_fargs = i;
+}
+
+
+typedef struct ftdiv_test {
+   int fra_idx;
+   int frb_idx;
+   int cr_flags;
+} ftdiv_test_args_t;
+
+typedef struct fp_test_args {
+   int fra_idx;
+   int frb_idx;
+   int cr_flags;
+   unsigned long long dp_bin_result;
+} fp_test_args_t;
+
+unsigned long long xscvuxddp_results[] = {
+                                          0x43cfec0000000000ULL,
+                                          0x43d013c000000000ULL,
+                                          0x4338000000b77501ULL,
+                                          0x43dffa0000000001ULL,
+                                          0x4372321456990000ULL,
+                                          0x0000000000000000ULL,
+                                          0x43e0000000000000ULL,
+                                          0x43dffc0000000000ULL,
+                                          0x43effe0000000000ULL,
+                                          0x43dffe0000000000ULL,
+                                          0x43efff0000000000ULL,
+                                          0x43dffe0000000000ULL,
+                                          0x43efff0000000000ULL,
+                                          0x43e00106800000f0ULL,
+                                          0x43e81a0ca1eb40f6ULL
+};
+
+unsigned long long xscvsxddp_results[] = {
+                                           0x43cfec0000000000ULL,
+                                           0x43d013c000000000ULL,
+                                           0x4338000000b77501ULL,
+                                           0x43dffa0000000001ULL,
+                                           0x4372321456990000ULL,
+                                           0x0000000000000000ULL,
+                                           0xc3e0000000000000ULL,
+                                           0x43dffc0000000000ULL,
+                                           0xc330000000000000ULL,
+                                           0x43dffe0000000000ULL,
+                                           0xc320000000000002ULL,
+                                           0x43dffe0000000000ULL,
+                                           0xc320000000000000ULL,
+                                           0xc3dffdf2fffffe20ULL,
+                                           0xc3cf97cd7852fc26ULL,
+};
+
+unsigned long long xscvdpsxds_results[] = {
+                                           0x0000000000000000ULL,
+                                           0x000000000000003eULL,
+                                           0x0000000000000000ULL,
+                                           0x7fffffffffffffffULL,
+                                           0x0000000000000000ULL,
+                                           0x0000000000000000ULL,
+                                           0x0000000000000000ULL,
+                                           0x7fffffffffffffffULL,
+                                           0x8000000000000000ULL,
+                                           0x8000000000000000ULL,
+                                           0x8000000000000000ULL,
+                                           0x8000000000000000ULL,
+                                           0x8000000000000000ULL,
+                                           0x0000000000000000ULL,
+                                           0xffffffffffffbe6cULL
+};
+
+ftdiv_test_args_t ftdiv_tests[] = {
+                              {0, 1, 0x8},
+                              {9, 1, 0xa},
+                              {1, 12, 0xa},
+                              {0, 2, 0xa},
+                              {1, 3, 0xa},
+                              {3, 0, 0xa},
+                              {0, 3, 0xa},
+                              {4, 0, 0xa},
+                              {7, 1, 0xe},
+                              {8, 1, 0xe},
+                              {1, 7, 0xe},
+                              {0, 13, 0xe},
+                              {5, 5, 0xe},
+                              {5, 6, 0xe},
+};
+
+fp_test_args_t xscmpX_tests[] = {
+                                   {8, 8, 0x2, 0ULL},
+                                   {8, 14, 0x8, 0ULL},
+                                   {8, 6, 0x8, 0ULL},
+                                   {8, 5, 0x8, 0ULL},
+                                   {8, 4, 0x8, 0ULL},
+                                   {8, 7, 0x8, 0ULL},
+                                   {8, 9, 0x1, 0ULL},
+                                   {8, 11, 0x1, 0ULL},
+                                   {14, 8, 0x4, 0ULL},
+                                   {14, 14, 0x2, 0ULL},
+                                   {14, 6, 0x8, 0ULL},
+                                   {14, 5, 0x8, 0ULL},
+                                   {14, 4, 0x8, 0ULL},
+                                   {14, 7, 0x8, 0ULL},
+                                   {14, 9, 0x1, 0ULL},
+                                   {14, 11, 0x1, 0ULL},
+                                   {6, 8, 0x4, 0ULL},
+                                   {6, 14, 0x4, 0ULL},
+                                   {6, 6, 0x2, 0ULL},
+                                   {6, 5, 0x2, 0ULL},
+                                   {6, 4, 0x8, 0ULL},
+                                   {6, 7, 0x8, 0ULL},
+                                   {6, 9, 0x1, 0ULL},
+                                   {6, 11, 0x1, 0ULL},
+                                   {5, 8, 0x4, 0ULL},
+                                   {5, 14, 0x4, 0ULL},
+                                   {5, 6, 0x2, 0ULL},
+                                   {5, 5, 0x2, 0ULL},
+                                   {5, 4, 0x8, 0ULL},
+                                   {5, 7, 0x8, 0ULL},
+                                   {5, 9, 0x1, 0ULL},
+                                   {5, 11, 0x1, 0ULL},
+                                   {4, 8, 0x4, 0ULL},
+                                   {4, 14, 0x4, 0ULL},
+                                   {4, 6, 0x4, 0ULL},
+                                   {4, 5, 0x4, 0ULL},
+                                   {4, 1, 0x8, 0ULL},
+                                   {4, 7, 0x8, 0ULL},
+                                   {4, 9, 0x1, 0ULL},
+                                   {4, 11, 0x1, 0ULL},
+                                   {7, 8, 0x4, 0ULL},
+                                   {7, 14, 0x4, 0ULL},
+                                   {7, 6, 0x4, 0ULL},
+                                   {7, 5, 0x4, 0ULL},
+                                   {7, 4, 0x4, 0ULL},
+                                   {7, 7, 0x2, 0ULL},
+                                   {7, 9, 0x1, 0ULL},
+                                   {7, 11, 0x1, 0ULL},
+                                   {10, 8, 0x1, 0ULL},
+                                   {10, 14, 0x1, 0ULL},
+                                   {10, 6, 0x1, 0ULL},
+                                   {10, 5, 0x1, 0ULL},
+                                   {10, 4, 0x1, 0ULL},
+                                   {10, 7, 0x1, 0ULL},
+                                   {10, 9, 0x1, 0ULL},
+                                   {10, 11, 0x1, 0ULL},
+                                   {12, 8, 0x1, 0ULL},
+                                   {12, 14, 0x1, 0ULL},
+                                   {12, 6, 0x1, 0ULL},
+                                   {12, 5, 0x1, 0ULL},
+                                   {12, 4, 0x1, 0ULL},
+                                   {12, 7, 0x1, 0ULL},
+                                   {12, 9, 0x1, 0ULL},
+                                   {12, 11, 0x1, 0ULL},
+};
+
+fp_test_args_t xsadddp_tests[] = {
+                                   {8, 8, 0x0,   0xfff0000000000000ULL},
+                                   {8, 14, 0x0,  0xfff0000000000000ULL},
+                                   {8, 6, 0x0,   0xfff0000000000000ULL},
+                                   {8, 5, 0x0,   0xfff0000000000000ULL},
+                                   {8, 4, 0x0,   0xfff0000000000000ULL},
+                                   {8, 7, 0x0,   0x7ff8000000000000ULL},
+                                   {8, 9, 0x0,   0x7fffffffffffffffULL},
+                                   {8, 11, 0x0,  0x7ff8000000000000ULL},
+                                   {14, 8, 0x0,  0xfff0000000000000ULL},
+                                   {14, 14, 0x0, 0xc0e0650f5a07b353ULL},
+                                   {14, 6, 0x0,  0xc0d0650f5a07b353ULL},
+                                   {14, 5, 0x0,  0xc0d0650f5a07b353ULL},
+                                   {14, 4, 0x0,  0xc0d0650f5a07b353ULL},
+                                   {14, 7, 0x0,  0x7ff0000000000000ULL},
+                                   {14, 9, 0x0,  0x7fffffffffffffffULL},
+                                   {14, 11, 0x0, 0x7ff8000000000000ULL},
+                                   {6, 8, 0x0,   0xfff0000000000000ULL},
+                                   {6, 14, 0x0,  0xc0d0650f5a07b353ULL},
+                                   {6, 6, 0x0,   0x8000000000000000ULL},
+                                   {6, 5, 0x0,   0x0000000000000000ULL},
+                                   {6, 4, 0x0,   0x0123214569900000ULL},
+                                   {6, 7, 0x0,   0x7ff0000000000000ULL},
+                                   {6, 9, 0x0,   0x7fffffffffffffffULL},
+                                   {6, 11, 0x0,  0x7ff8000000000000ULL},
+                                   {5, 8, 0x0,   0xfff0000000000000ULL},
+                                   {5, 14, 0x0,  0xc0d0650f5a07b353ULL},
+                                   {5, 6, 0x0,   0x0000000000000000ULL},
+                                   {5, 5, 0x0,   0x0000000000000000ULL},
+                                   {5, 4, 0x0,   0x0123214569900000ULL},
+                                   {5, 7, 0x0,   0x7ff0000000000000ULL},
+                                   {5, 9, 0x0,   0x7fffffffffffffffULL},
+                                   {5, 11, 0x0,  0x7ff8000000000000ULL},
+                                   {4, 8, 0x0,   0xfff0000000000000ULL},
+                                   {4, 14, 0x0,  0xc0d0650f5a07b353ULL},
+                                   {4, 6, 0x0,   0x0123214569900000ULL},
+                                   {4, 5, 0x0,   0x0123214569900000ULL},
+                                   {4, 1, 0x0,   0x404f000000000000ULL},
+                                   {4, 7, 0x0,   0x7ff0000000000000ULL},
+                                   {4, 9, 0x0,   0x7fffffffffffffffULL},
+                                   {4, 11, 0x0,  0x7ff8000000000000ULL},
+                                   {7, 8, 0x0,   0x7ff8000000000000ULL},
+                                   {7, 14, 0x0,  0x7ff0000000000000ULL},
+                                   {7, 6, 0x0,   0x7ff0000000000000ULL},
+                                   {7, 5, 0x0,   0x7ff0000000000000ULL},
+                                   {7, 4, 0x0,   0x7ff0000000000000ULL},
+                                   {7, 7, 0x0,   0x7ff0000000000000ULL},
+                                   {7, 9, 0x0,   0x7fffffffffffffffULL},
+                                   {7, 11, 0x0,  0x7ff8000000000000ULL},
+                                   {10, 8, 0x0,  0xffffffffffffffffULL},
+                                   {10, 14, 0x0, 0xffffffffffffffffULL},
+                                   {10, 6, 0x0,  0xffffffffffffffffULL},
+                                   {10, 5, 0x0,  0xffffffffffffffffULL},
+                                   {10, 4, 0x0,  0xffffffffffffffffULL},
+                                   {10, 7, 0x0,  0xffffffffffffffffULL},
+                                   {10, 9, 0x0,  0xffffffffffffffffULL},
+                                   {10, 11, 0x0, 0xffffffffffffffffULL},
+                                   {12, 8, 0x0,  0xfff8000000000000ULL},
+                                   {12, 14, 0x0, 0xfff8000000000000ULL},
+                                   {12, 6, 0x0,  0xfff8000000000000ULL},
+                                   {12, 5, 0x0,  0xfff8000000000000ULL},
+                                   {12, 4, 0x0,  0xfff8000000000000ULL},
+                                   {12, 7, 0x0,  0xfff8000000000000ULL},
+                                   {12, 9, 0x0,  0xfff8000000000000ULL},
+                                   {12, 11, 0x0, 0xfff8000000000000ULL},
+};
+
+fp_test_args_t xsdivdp_tests[] = {
+                                   {8, 8, 0x0,   0x7ff8000000000000ULL},
+                                   {8, 14, 0x0,  0x7ff0000000000000ULL},
+                                   {8, 6, 0x0,   0x7ff0000000000000ULL},
+                                   {8, 5, 0x0,   0xfff0000000000000ULL},
+                                   {8, 4, 0x0,   0xfff0000000000000ULL},
+                                   {8, 7, 0x0,   0x7ff8000000000000ULL},
+                                   {8, 9, 0x0,   0x7fffffffffffffffULL},
+                                   {8, 11, 0x0,  0x7ff8000000000000ULL},
+                                   {14, 8, 0x0,  0x0000000000000000ULL},
+                                   {14, 14, 0x0, 0x3ff0000000000000ULL},
+                                   {14, 6, 0x0,  0x7ff0000000000000ULL},
+                                   {14, 5, 0x0,  0xfff0000000000000ULL},
+                                   {14, 4, 0x0,  0xff9b6cb57ca13c00ULL},
+                                   {14, 7, 0x0,  0x8000000000000000ULL},
+                                   {14, 9, 0x0,  0x7fffffffffffffffULL},
+                                   {14, 11, 0x0, 0x7ff8000000000000ULL},
+                                   {6, 8, 0x0,   0x0000000000000000ULL},
+                                   {6, 14, 0x0,  0x0000000000000000ULL},
+                                   {6, 6, 0x0,   0x7ff8000000000000ULL},
+                                   {6, 5, 0x0,   0x7ff8000000000000ULL},
+                                   {6, 4, 0x0,   0x8000000000000000ULL},
+                                   {6, 7, 0x0,   0x8000000000000000ULL},
+                                   {6, 9, 0x0,   0x7fffffffffffffffULL},
+                                   {6, 11, 0x0,  0x7ff8000000000000ULL},
+                                   {5, 8, 0x0,   0x8000000000000000ULL},
+                                   {5, 14, 0x0,  0x8000000000000000ULL},
+                                   {5, 6, 0x0,   0x7ff8000000000000ULL},
+                                   {5, 5, 0x0,   0x7ff8000000000000ULL},
+                                   {5, 4, 0x0,   0x0000000000000000ULL},
+                                   {5, 7, 0x0,   0x0000000000000000ULL},
+                                   {5, 9, 0x0,   0x7fffffffffffffffULL},
+                                   {5, 11, 0x0,  0x7ff8000000000000ULL},
+                                   {4, 8, 0x0,   0x8000000000000000ULL},
+                                   {4, 14, 0x0,  0x8042ab59d8b6ec87ULL},
+                                   {4, 6, 0x0,   0xfff0000000000000ULL},
+                                   {4, 5, 0x0,   0x7ff0000000000000ULL},
+                                   {4, 1, 0x0,   0x00c3bf3f64b5ad6bULL},
+                                   {4, 7, 0x0,   0x0000000000000000ULL},
+                                   {4, 9, 0x0,   0x7fffffffffffffffULL},
+                                   {4, 11, 0x0,  0x7ff8000000000000ULL},
+                                   {7, 8, 0x0,   0x7ff8000000000000ULL},
+                                   {7, 14, 0x0,  0xfff0000000000000ULL},
+                                   {7, 6, 0x0,   0xfff0000000000000ULL},
+                                   {7, 5, 0x0,   0x7ff0000000000000ULL},
+                                   {7, 4, 0x0,   0x7ff0000000000000ULL},
+                                   {7, 7, 0x0,   0x7ff8000000000000ULL},
+                                   {7, 9, 0x0,   0x7fffffffffffffffULL},
+                                   {7, 11, 0x0,  0x7ff8000000000000ULL},
+                                   {10, 8, 0x0,  0xffffffffffffffffULL},
+                                   {10, 14, 0x0, 0xffffffffffffffffULL},
+                                   {10, 6, 0x0,  0xffffffffffffffffULL},
+                                   {10, 5, 0x0,  0xffffffffffffffffULL},
+                                   {10, 4, 0x0,  0xffffffffffffffffULL},
+                                   {10, 7, 0x0,  0xffffffffffffffffULL},
+                                   {10, 9, 0x0,  0xffffffffffffffffULL},
+                                   {10, 11, 0x0, 0xffffffffffffffffULL},
+                                   {12, 8, 0x0,  0xfff8000000000000ULL},
+                                   {12, 14, 0x0, 0xfff8000000000000ULL},
+                                   {12, 6, 0x0,  0xfff8000000000000ULL},
+                                   {12, 5, 0x0,  0xfff8000000000000ULL},
+                                   {12, 4, 0x0,  0xfff8000000000000ULL},
+                                   {12, 7, 0x0,  0xfff8000000000000ULL},
+                                   {12, 9, 0x0,  0xfff8000000000000ULL},
+                                   {12, 11, 0x0, 0xfff8000000000000ULL},
+};
+
+fp_test_args_t xsmaddXdp_tests[] = {
+                                   {8, 8, 0x0,   0x7ff8000000000000ULL},
+                                   {8, 14, 0x0,  0xfff0000000000000ULL},
+                                   {8, 6, 0x0,   0x7ff0000000000000ULL},
+                                   {8, 5, 0x0,   0xfff0000000000000ULL},
+                                   {8, 4, 0x0,   0x7ff0000000000000ULL},
+                                   {8, 7, 0x0,   0x7ff8000000000000ULL},
+                                   {8, 9, 0x0,   0x7fffffffffffffffULL},
+                                   {8, 11, 0x0,  0x7ff8000000000000ULL},
+                                   {14, 8, 0x0,  0xfff0000000000000ULL},
+                                   {14, 14, 0x0, 0xc0d0650f5a07b353ULL},
+                                   {14, 6, 0x0,  0x41b0cc9d05eec2a7ULL},
+                                   {14, 5, 0x0,  0x82039a19ca8fcb5fULL},
+                                   {14, 4, 0x0,  0x41b0cc9d05eec2a7ULL},
+                                   {14, 7, 0x0,  0x7ff0000000000000ULL},
+                                   {14, 9, 0x0,  0x7fffffffffffffffULL},
+                                   {14, 11, 0x0, 0x7ff8000000000000ULL},
+                                   {6, 8, 0x0,   0xfff0000000000000ULL},
+                                   {6, 14, 0x0,  0xc0d0650f5a07b353ULL},
+                                   {6, 6, 0x0,   0x0000000000000000ULL},
+                                   {6, 5, 0x0,   0x0000000000000000ULL},
+                                   {6, 4, 0x0,   0x0123214569900000ULL},
+                                   {6, 7, 0x0,   0x7ff0000000000000ULL},
+                                   {6, 9, 0x0,   0x7fffffffffffffffULL},
+                                   {6, 11, 0x0,  0x7ff8000000000000ULL},
+                                   {5, 8, 0x0,   0xfff0000000000000ULL},
+                                   {5, 14, 0x0,  0xc0d0650f5a07b353ULL},
+                                   {5, 6, 0x0,   0x8000000000000000ULL},
+                                   {5, 5, 0x0,   0x0000000000000000ULL},
+                                   {5, 4, 0x0,   0x0123214569900000ULL},
+                                   {5, 7, 0x0,   0x7ff0000000000000ULL},
+                                   {5, 9, 0x0,   0x7fffffffffffffffULL},
+                                   {5, 11, 0x0,  0x7ff8000000000000ULL},
+                                   {4, 8, 0x0,   0xfff0000000000000ULL},
+                                   {4, 14, 0x0,  0xc0d0650f5a07b353ULL},
+                                   {4, 6, 0x0,   0x82039a19ca8fcb5fULL},
+                                   {4, 5, 0x0,   0x0000000000000000ULL},
+                                   {4, 1, 0x0,   0x404f000000000000ULL},
+                                   {4, 7, 0x0,   0x7ff0000000000000ULL},
+                                   {4, 9, 0x0,   0x7fffffffffffffffULL},
+                                   {4, 11, 0x0,  0x7ff8000000000000ULL},
+                                   {7, 8, 0x0,   0xfff0000000000000ULL},
+                                   {7, 14, 0x0,  0x7ff0000000000000ULL},
+                                   {7, 6, 0x0,   0xfff0000000000000ULL},
+                                   {7, 5, 0x0,   0x7ff0000000000000ULL},
+                                   {7, 4, 0x0,   0xfff0000000000000ULL},
+                                   {7, 7, 0x0,   0x7ff0000000000000ULL},
+                                   {7, 9, 0x0,   0x7fffffffffffffffULL},
+                                   {7, 11, 0x0,  0x7ff8000000000000ULL},
+                                   {10, 8, 0x0,  0xffffffffffffffffULL},
+                                   {10, 14, 0x0, 0xffffffffffffffffULL},
+                                   {10, 6, 0x0,  0xffffffffffffffffULL},
+                                   {10, 5, 0x0,  0xffffffffffffffffULL},
+                                   {10, 4, 0x0,  0xffffffffffffffffULL},
+                                   {10, 7, 0x0,  0xffffffffffffffffULL},
+                                   {10, 9, 0x0,  0xffffffffffffffffULL},
+                                   {10, 11, 0x0, 0xffffffffffffffffULL},
+                                   {12, 8, 0x0,  0xfff8000000000000ULL},
+                                   {12, 14, 0x0, 0xfff8000000000000ULL},
+                                   {12, 6, 0x0,  0xfff8000000000000ULL},
+                                   {12, 5, 0x0,  0xfff8000000000000ULL},
+                                   {12, 4, 0x0,  0xfff8000000000000ULL},
+                                   {12, 7, 0x0,  0xfff8000000000000ULL},
+                                   {12, 9, 0x0,  0xfff8000000000000ULL},
+                                   {12, 11, 0x0, 0xfff8000000000000ULL},
+};
+
+fp_test_args_t xsmsubXdp_tests[] = {
+                                   {8, 8, 0x0,   0x7ff0000000000000ULL},
+                                   {8, 14, 0x0,  0xfff0000000000000ULL},
+                                   {8, 6, 0x0,   0x7ff0000000000000ULL},
+                                   {8, 5, 0x0,   0xfff0000000000000ULL},
+                                   {8, 4, 0x0,   0x7ff0000000000000ULL},
+                                   {8, 7, 0x0,   0xfff0000000000000ULL},
+                                   {8, 9, 0x0,   0x7fffffffffffffffULL},
+                                   {8, 11, 0x0,  0x7ff8000000000000ULL},
+                                   {14, 8, 0x0,  0x7ff0000000000000ULL},
+                                   {14, 14, 0x0, 0x40d0650f5a07b353ULL},
+                                   {14, 6, 0x0,  0x41b0cc9d05eec2a7ULL},
+                                   {14, 5, 0x0,  0x82039a19ca8fcb5fULL},
+                                   {14, 4, 0x0,  0x41b0cc9d05eec2a7ULL},
+                                   {14, 7, 0x0,  0xfff0000000000000ULL},
+                                   {14, 9, 0x0,  0x7fffffffffffffffULL},
+                                   {14, 11, 0x0, 0x7ff8000000000000ULL},
+                                   {6, 8, 0x0,   0x7ff0000000000000ULL},
+                                   {6, 14, 0x0,  0x40d0650f5a07b353ULL},
+                                   {6, 6, 0x0,   0x0000000000000000ULL},
+                                   {6, 5, 0x0,   0x8000000000000000ULL},
+                                   {6, 4, 0x0,   0x8123214569900000ULL},
+                                   {6, 7, 0x0,   0xfff0000000000000ULL},
+                                   {6, 9, 0x0,   0x7fffffffffffffffULL},
+                                   {6, 11, 0x0,  0x7ff8000000000000ULL},
+                                   {5, 8, 0x0,   0x7ff0000000000000ULL},
+                                   {5, 14, 0x0,  0x40d0650f5a07b353ULL},
+                                   {5, 6, 0x0,   0x0000000000000000ULL},
+                                   {5, 5, 0x0,   0x0000000000000000ULL},
+                                   {5, 4, 0x0,   0x8123214569900000ULL},
+                                   {5, 7, 0x0,   0xfff0000000000000ULL},
+                                   {5, 9, 0x0,   0x7fffffffffffffffULL},
+                                   {5, 11, 0x0,  0x7ff8000000000000ULL},
+                                   {4, 8, 0x0,   0x7ff0000000000000ULL},
+                                   {4, 14, 0x0,  0x40d0650f5a07b353ULL},
+                                   {4, 6, 0x0,   0x82039a19ca8fcb5fULL},
+                                   {4, 5, 0x0,   0x0000000000000000ULL},
+                                   {4, 1, 0x0,   0xc04f000000000000ULL},
+                                   {4, 7, 0x0,   0xfff0000000000000ULL},
+                                   {4, 9, 0x0,   0x7fffffffffffffffULL},
+                                   {4, 11, 0x0,  0x7ff8000000000000ULL},
+                                   {7, 8, 0x0,   0x7ff8000000000000ULL},
+                                   {7, 14, 0x0,  0x7ff0000000000000ULL},
+                                   {7, 6, 0x0,   0xfff0000000000000ULL},
+                                   {7, 5, 0x0,   0x7ff0000000000000ULL},
+                                   {7, 4, 0x0,   0xfff0000000000000ULL},
+                                   {7, 7, 0x0,   0x7ff8000000000000ULL},
+                                   {7, 9, 0x0,   0x7fffffffffffffffULL},
+                                   {7, 11, 0x0,  0x7ff8000000000000ULL},
+                                   {10, 8, 0x0,  0xffffffffffffffffULL},
+                                   {10, 14, 0x0, 0xffffffffffffffffULL},
+                                   {10, 6, 0x0,  0xffffffffffffffffULL},
+                                   {10, 5, 0x0,  0xffffffffffffffffULL},
+                                   {10, 4, 0x0,  0xffffffffffffffffULL},
+                                   {10, 7, 0x0,  0xffffffffffffffffULL},
+                                   {10, 9, 0x0,  0xffffffffffffffffULL},
+                                   {10, 11, 0x0, 0xffffffffffffffffULL},
+                                   {12, 8, 0x0,  0xfff8000000000000ULL},
+                                   {12, 14, 0x0, 0xfff8000000000000ULL},
+                                   {12, 6, 0x0,  0xfff8000000000000ULL},
+                                   {12, 5, 0x0,  0xfff8000000000000ULL},
+                                   {12, 4, 0x0,  0xfff8000000000000ULL},
+                                   {12, 7, 0x0,  0xfff8000000000000ULL},
+                                   {12, 9, 0x0,  0xfff8000000000000ULL},
+                                   {12, 11, 0x0, 0xfff8000000000000ULL},
+};
+
+fp_test_args_t xsnmaddXdp_tests[] = {
+                                     {8, 8, 0x0,   0x7ff8000000000000ULL},
+                                     {8, 14, 0x0,  0x7ff0000000000000ULL},
+                                     {8, 6, 0x0,   0xfff0000000000000ULL},
+                                     {8, 5, 0x0,   0x7ff0000000000000ULL},
+                                     {8, 4, 0x0,   0xfff0000000000000ULL},
+                                     {8, 7, 0x0,   0x7ff8000000000000ULL},
+                                     {8, 9, 0x0,   0x7fffffffffffffffULL},
+                                     {8, 11, 0x0,  0x7ff8000000000000ULL},
+                                     {14, 8, 0x0,  0x7ff0000000000000ULL},
+                                     {14, 14, 0x0, 0x40d0650f5a07b353ULL},
+                                     {14, 6, 0x0,  0xc1b0cc9d05eec2a7ULL},
+                                     {14, 5, 0x0,  0x02039a19ca8fcb5fULL},
+                                     {14, 4, 0x0,  0xc1b0cc9d05eec2a7ULL},
+                                     {14, 7, 0x0,  0xfff0000000000000ULL},
+                                     {14, 9, 0x0,  0x7fffffffffffffffULL},
+                                     {14, 11, 0x0, 0x7ff8000000000000ULL},
+                                     {6, 8, 0x0,   0x7ff0000000000000ULL},
+                                     {6, 14, 0x0,  0x40d0650f5a07b353ULL},
+                                     {6, 6, 0x0,   0x8000000000000000ULL},
+                                     {6, 5, 0x0,   0x8000000000000000ULL},
+                                     {6, 4, 0x0,   0x8123214569900000ULL},
+                                     {6, 7, 0x0,   0xfff0000000000000ULL},
+                                     {6, 9, 0x0,   0x7fffffffffffffffULL},
+                                     {6, 11, 0x0,  0x7ff8000000000000ULL},
+                                     {5, 8, 0x0,   0x7ff0000000000000ULL},
+                                     {5, 14, 0x0,  0x40d0650f5a07b353ULL},
+                                     {5, 6, 0x0,   0x0000000000000000ULL},
+                                     {5, 5, 0x0,   0x8000000000000000ULL},
+                                     {5, 4, 0x0,   0x8123214569900000ULL},
+                                     {5, 7, 0x0,   0xfff0000000000000ULL},
+                                     {5, 9, 0x0,   0x7fffffffffffffffULL},
+                                     {5, 11, 0x0,  0x7ff8000000000000ULL},
+                                     {4, 8, 0x0,   0x7ff0000000000000ULL},
+                                     {4, 14, 0x0,  0x40d0650f5a07b353ULL},
+                                     {4, 6, 0x0,   0x02039a19ca8fcb5fULL},
+                                     {4, 5, 0x0,   0x8000000000000000ULL},
+                                     {4, 1, 0x0,   0xc04f000000000000ULL},
+                                     {4, 7, 0x0,   0xfff0000000000000ULL},
+                                     {4, 9, 0x0,   0x7fffffffffffffffULL},
+                                     {4, 11, 0x0,  0x7ff8000000000000ULL},
+                                     {7, 8, 0x0,   0x7ff0000000000000ULL},
+                                     {7, 14, 0x0,  0xfff0000000000000ULL},
+                                     {7, 6, 0x0,   0x7ff0000000000000ULL},
+                                     {7, 5, 0x0,   0xfff0000000000000ULL},
+                                     {7, 4, 0x0,   0x7ff0000000000000ULL},
+                                     {7, 7, 0x0,   0xfff0000000000000ULL},
+                                     {7, 9, 0x0,   0x7fffffffffffffffULL},
+                                     {7, 11, 0x0,  0x7ff8000000000000ULL},
+                                     {10, 8, 0x0,  0xffffffffffffffffULL},
+                                     {10, 14, 0x0, 0xffffffffffffffffULL},
+                                     {10, 6, 0x0,  0xffffffffffffffffULL},
+                                     {10, 5, 0x0,  0xffffffffffffffffULL},
+                                     {10, 4, 0x0,  0xffffffffffffffffULL},
+                                     {10, 7, 0x0,  0xffffffffffffffffULL},
+                                     {10, 9, 0x0,  0xffffffffffffffffULL},
+                                     {10, 11, 0x0, 0xffffffffffffffffULL},
+                                     {12, 8, 0x0,  0xfff8000000000000ULL},
+                                     {12, 14, 0x0, 0xfff8000000000000ULL},
+                                     {12, 6, 0x0,  0xfff8000000000000ULL},
+                                     {12, 5, 0x0,  0xfff8000000000000ULL},
+                                     {12, 4, 0x0,  0xfff8000000000000ULL},
+                                     {12, 7, 0x0,  0xfff8000000000000ULL},
+                                     {12, 9, 0x0,  0xfff8000000000000ULL},
+                                     {12, 11, 0x0, 0xfff8000000000000ULL},
+};
+
+fp_test_args_t xsmuldp_tests[] = {
+                                  {8, 8, 0x0,   0x7ff0000000000000ULL},
+                                  {8, 14, 0x0,  0x7ff0000000000000ULL},
+                                  {8, 6, 0x0,   0x7ff8000000000000ULL},
+                                  {8, 5, 0x0,   0x7ff8000000000000ULL},
+                                  {8, 4, 0x0,   0xfff0000000000000ULL},
+                                  {8, 7, 0x0,   0xfff0000000000000ULL},
+                                  {8, 9, 0x0,   0x7fffffffffffffffULL},
+                                  {8, 11, 0x0,  0x7ff8000000000000ULL},
+                                  {14, 8, 0x0,  0x7ff0000000000000ULL},
+                                  {14, 14, 0x0, 0x41b0cc9d05eec2a7ULL},
+                                  {14, 6, 0x0,  0x0000000000000000ULL},
+                                  {14, 5, 0x0,  0x8000000000000000ULL},
+                                  {14, 4, 0x0,  0x82039a19ca8fcb5fULL},
+                                  {14, 7, 0x0,  0xfff0000000000000ULL},
+                                  {14, 9, 0x0,  0x7fffffffffffffffULL},
+                                  {14, 11, 0x0, 0x7ff8000000000000ULL},
+                                  {6, 8, 0x0,   0x7ff8000000000000ULL},
+                                  {6, 14, 0x0,  0x0000000000000000ULL},
+                                  {6, 6, 0x0,   0x0000000000000000ULL},
+                                  {6, 5, 0x0,   0x8000000000000000ULL},
+                                  {6, 4, 0x0,   0x8000000000000000ULL},
+                                  {6, 7, 0x0,   0x7ff8000000000000ULL},
+                                  {6, 9, 0x0,   0x7fffffffffffffffULL},
+                                  {6, 11, 0x0,  0x7ff8000000000000ULL},
+                                  {5, 8, 0x0,   0x7ff8000000000000ULL},
+                                  {5, 14, 0x0,  0x8000000000000000ULL},
+                                  {5, 6, 0x0,   0x8000000000000000ULL},
+                                  {5, 5, 0x0,   0x0000000000000000ULL},
+                                  {5, 4, 0x0,   0x0000000000000000ULL},
+                                  {5, 7, 0x0,   0x7ff8000000000000ULL},
+                                  {5, 9, 0x0,   0x7fffffffffffffffULL},
+                                  {5, 11, 0x0,  0x7ff8000000000000ULL},
+                                  {4, 8, 0x0,   0xfff0000000000000ULL},
+                                  {4, 14, 0x0,  0x82039a19ca8fcb5fULL},
+                                  {4, 6, 0x0,   0x8000000000000000ULL},
+                                  {4, 5, 0x0,   0x0000000000000000ULL},
+                                  {4, 1, 0x0,   0x0182883b3e438000ULL},
+                                  {4, 7, 0x0,   0x7ff0000000000000ULL},
+                                  {4, 9, 0x0,   0x7fffffffffffffffULL},
+                                  {4, 11, 0x0,  0x7ff8000000000000ULL},
+                                  {7, 8, 0x0,   0xfff0000000000000ULL},
+                                  {7, 14, 0x0,  0xfff0000000000000ULL},
+                                  {7, 6, 0x0,   0x7ff8000000000000ULL},
+                                  {7, 5, 0x0,   0x7ff8000000000000ULL},
+                                  {7, 4, 0x0,   0x7ff0000000000000ULL},
+                                  {7, 7, 0x0,   0x7ff0000000000000ULL},
+                                  {7, 9, 0x0,   0x7fffffffffffffffULL},
+                                  {7, 11, 0x0,  0x7ff8000000000000ULL},
+                                  {10, 8, 0x0,  0xffffffffffffffffULL},
+                                  {10, 14, 0x0, 0xffffffffffffffffULL},
+                                  {10, 6, 0x0,  0xffffffffffffffffULL},
+                                  {10, 5, 0x0,  0xffffffffffffffffULL},
+                                  {10, 4, 0x0,  0xffffffffffffffffULL},
+                                  {10, 7, 0x0,  0xffffffffffffffffULL},
+                                  {10, 9, 0x0,  0xffffffffffffffffULL},
+                                  {10, 11, 0x0, 0xffffffffffffffffULL},
+                                  {12, 8, 0x0,  0xfff8000000000000ULL},
+                                  {12, 14, 0x0, 0xfff8000000000000ULL},
+                                  {12, 6, 0x0,  0xfff8000000000000ULL},
+                                  {12, 5, 0x0,  0xfff8000000000000ULL},
+                                  {12, 4, 0x0,  0xfff8000000000000ULL},
+                                  {12, 7, 0x0,  0xfff8000000000000ULL},
+                                  {12, 9, 0x0,  0xfff8000000000000ULL},
+                                  {12, 11, 0x0, 0xfff8000000000000ULL},
+};
+
+fp_test_args_t xssubdp_tests[] = {
+                                  {8, 8, 0x0,   0x7ff8000000000000ULL},
+                                  {8, 14, 0x0,  0xfff0000000000000ULL},
+                                  {8, 6, 0x0,   0xfff0000000000000ULL},
+                                  {8, 5, 0x0,   0xfff0000000000000ULL},
+                                  {8, 4, 0x0,   0xfff0000000000000ULL},
+                                  {8, 7, 0x0,   0xfff0000000000000ULL},
+                                  {8, 9, 0x0,   0x7fffffffffffffffULL},
+                                  {8, 11, 0x0,  0x7ff8000000000000ULL},
+                                  {14, 8, 0x0,  0x7ff0000000000000ULL},
+                                  {14, 14, 0x0, 0x0000000000000000ULL},
+                                  {14, 6, 0x0,  0xc0d0650f5a07b353ULL},
+                                  {14, 5, 0x0,  0xc0d0650f5a07b353ULL},
+                                  {14, 4, 0x0,  0xc0d0650f5a07b353ULL},
+                                  {14, 7, 0x0,  0xfff0000000000000ULL},
+                                  {14, 9, 0x0,  0x7fffffffffffffffULL},
+                                  {14, 11, 0x0, 0x7ff8000000000000ULL},
+                                  {6, 8, 0x0,   0x7ff0000000000000ULL},
+                                  {6, 14, 0x0,  0x40d0650f5a07b353ULL},
+                                  {6, 6, 0x0,   0x0000000000000000ULL},
+                                  {6, 5, 0x0,   0x8000000000000000ULL},
+                                  {6, 4, 0x0,   0x8123214569900000ULL},
+                                  {6, 7, 0x0,   0xfff0000000000000ULL},
+                                  {6, 9, 0x0,   0x7fffffffffffffffULL},
+                                  {6, 11, 0x0,  0x7ff8000000000000ULL},
+                                  {5, 8, 0x0,   0x7ff0000000000000ULL},
+                                  {5, 14, 0x0,  0x40d0650f5a07b353ULL},
+                                  {5, 6, 0x0,   0x0000000000000000ULL},
+                                  {5, 5, 0x0,   0x0000000000000000ULL},
+                                  {5, 4, 0x0,   0x8123214569900000ULL},
+                                  {5, 7, 0x0,   0xfff0000000000000ULL},
+                                  {5, 9, 0x0,   0x7fffffffffffffffULL},
+                                  {5, 11, 0x0,  0x7ff8000000000000ULL},
+                                  {4, 8, 0x0,   0x7ff0000000000000ULL},
+                                  {4, 14, 0x0,  0x40d0650f5a07b353ULL},
+                                  {4, 6, 0x0,   0x0123214569900000ULL},
+                                  {4, 5, 0x0,   0x0123214569900000ULL},
+                                  {4, 1, 0x0,   0xc04f000000000000ULL},
+                                  {4, 7, 0x0,   0xfff0000000000000ULL},
+                                  {4, 9, 0x0,   0x7fffffffffffffffULL},
+                                  {4, 11, 0x0,  0x7ff8000000000000ULL},
+                                  {7, 8, 0x0,   0x7ff0000000000000ULL},
+                                  {7, 14, 0x0,  0x7ff0000000000000ULL},
+                                  {7, 6, 0x0,   0x7ff0000000000000ULL},
+                                  {7, 5, 0x0,   0x7ff0000000000000ULL},
+                                  {7, 4, 0x0,   0x7ff0000000000000ULL},
+                                  {7, 7, 0x0,   0x7ff8000000000000ULL},
+                                  {7, 9, 0x0,   0x7fffffffffffffffULL},
+                                  {7, 11, 0x0,  0x7ff8000000000000ULL},
+                                  {10, 8, 0x0,  0xffffffffffffffffULL},
+                                  {10, 14, 0x0, 0xffffffffffffffffULL},
+                                  {10, 6, 0x0,  0xffffffffffffffffULL},
+                                  {10, 5, 0x0,  0xffffffffffffffffULL},
+                                  {10, 4, 0x0,  0xffffffffffffffffULL},
+                                  {10, 7, 0x0,  0xffffffffffffffffULL},
+                                  {10, 9, 0x0,  0xffffffffffffffffULL},
+                                  {10, 11, 0x0, 0xffffffffffffffffULL},
+                                  {12, 8, 0x0,  0xfff8000000000000ULL},
+                                  {12, 14, 0x0, 0xfff8000000000000ULL},
+                                  {12, 6, 0x0,  0xfff8000000000000ULL},
+                                  {12, 5, 0x0,  0xfff8000000000000ULL},
+                                  {12, 4, 0x0,  0xfff8000000000000ULL},
+                                  {12, 7, 0x0,  0xfff8000000000000ULL},
+                                  {12, 9, 0x0,  0xfff8000000000000ULL},
+                                  {12, 11, 0x0, 0xfff8000000000000ULL},
+};
+
+
+
+static int nb_special_fargs;
+static double * spec_fargs;
+
+static void build_special_fargs_table(void)
+{
+   /* The special floating point values created below are for
+    * use in the ftdiv tests for setting the fe_flag and fg_flag,
+    * but they can also be used for other tests (e.g., xscmpudp).
+    *
+    * Note that fl_flag is 'always '1' on ppc64 Linux.
+    *
+  Entry  Sign Exp   fraction                  Special value
+   0      0   3fd   0x8000000000000ULL         Positive finite number
+   1      0   404   0xf000000000000ULL         ...
+   2      0   001   0x8000000b77501ULL         ...
+   3      0   7fe   0x800000000051bULL         ...
+   4      0   012   0x3214569900000ULL         ...
+   5      0   000   0x0000000000000ULL         +0.0 (+zero)
+   6      1   000   0x0000000000000ULL         -0.0 (-zero)
+   7      0   7ff   0x0000000000000ULL         +infinity
+   8      1   7ff   0x0000000000000ULL         -infinity
+   9      0   7ff   0x7FFFFFFFFFFFFULL         +QNaN
+   10     1   7ff   0x7FFFFFFFFFFFFULL         -QNaN
+   11     0   7ff   0x8000000000000ULL         +SNaN
+   12     1   7ff   0x8000000000000ULL         -SNaN
+   13     1   000   0x8340000078000ULL         Denormalized val (zero exp and non-zero fraction)
+   14     1   40d   0x0650f5a07b353ULL         Negative finite number
+    */
+
+   uint64_t mant;
+   uint16_t _exp;
+   int s;
+   int i = 0;
+
+   if (spec_fargs)
+      return;
+
+   spec_fargs = malloc( 16 * sizeof(double) );
+
+   // #0
+   s = 0;
+   _exp = 0x3fd;
+   mant = 0x8000000000000ULL;
+   register_farg(&spec_fargs[i++], s, _exp, mant);
+
+   // #1
+   s = 0;
+   _exp = 0x404;
+   mant = 0xf000000000000ULL;
+   register_farg(&spec_fargs[i++], s, _exp, mant);
+
+   /* None of the ftdiv tests succeed.
+    * FRA = value #0; FRB = value #1
+    * ea_ = -2; e_b = 5
+    * fl_flag || fg_flag || fe_flag = 100
+    */
+
+   /*************************************************
+    *     fe_flag tests
+    *
+    *************************************************/
+
+   /* fe_flag <- 1 if FRA is a NaN
+    * FRA = value #9; FRB = value #1
+    * e_a = 1024; e_b = 5
+    * fl_flag || fg_flag || fe_flag = 101
+    */
+
+   /* fe_flag <- 1 if FRB is a NaN
+    * FRA = value #1; FRB = value #12
+    * e_a = 5; e_b = 1024
+    * fl_flag || fg_flag || fe_flag = 101
+    */
+
+   /* fe_flag <- 1 if e_b <= -1022
+    * FRA = value #0; FRB = value #2
+    * e_a = -2; e_b = -1022
+    * fl_flag || fg_flag || fe_flag = 101
+    *
+    */
+   // #2
+   s = 0;
+   _exp = 0x001;
+   mant = 0x8000000b77501ULL;
+   register_farg(&spec_fargs[i++], s, _exp, mant);
+
+   /* fe_flag <- 1 if e_b >= 1021
+    * FRA = value #1; FRB = value #3
+    * e_a = 5; e_b = 1023
+    * fl_flag || fg_flag || fe_flag = 101
+    */
+   // #3
+   s = 0;
+   _exp = 0x7fe;
+   mant = 0x800000000051bULL;
+   register_farg(&spec_fargs[i++], s, _exp, mant);
+
+   /* fe_flag <- 1 if FRA != 0 && e_a - e_b >= 1023
+    * Let FRA = value #3 and FRB be value #0.
+    * e_a = 1023; e_b = -2
+    * fl_flag || fg_flag || fe_flag = 101
+    */
+
+   /* fe_flag <- 1 if FRA != 0 && e_a - e_b <= -1023
+    * Let FRA = value #0 above and FRB be value #3 above
+    * e_a = -2; e_b = 1023
+    * fl_flag || fg_flag || fe_flag = 101
+    */
+
+   /* fe_flag <- 1 if FRA != 0 && e_a <= -970
+    * Let FRA = value #4 and FRB be value #0
+    * e_a = -1005; e_b = -2
+    * fl_flag || fg_flag || fe_flag = 101
+   */
+   // #4
+   s = 0;
+   _exp = 0x012;
+   mant = 0x3214569900000ULL;
+   register_farg(&spec_fargs[i++], s, _exp, mant);
+
+   /*************************************************
+    *     fg_flag tests
+    *
+    *************************************************/
+   /* fg_flag <- 1 if FRA is an Infinity
+    * NOTE: FRA = Inf also sets fe_flag
+    * Do two tests, using values #7 and #8 (+/- Inf) for FRA.
+    * Test 1:
+    *   Let FRA be value #7 and FRB be value #1
+    *   e_a = 1024; e_b = 5
+    *   fl_flag || fg_flag || fe_flag = 111
+    *
+    * Test 2:
+    *   Let FRA be value #8 and FRB be value #1
+    *   e_a = 1024; e_b = 5
+    *   fl_flag || fg_flag || fe_flag = 111
+    *
+    */
+
+   /* fg_flag <- 1 if FRB is an Infinity
+    * NOTE: FRB = Inf also sets fe_flag
+    * Let FRA be value #1 and FRB be value #7
+    * e_a = 5; e_b = 1024
+    * fl_flag || fg_flag || fe_flag = 111
+    */
+
+   /* fg_flag <- 1 if FRB is denormalized
+    * NOTE: e_b < -1022 ==> fe_flag <- 1
+    * Let FRA be value #0 and FRB be value #13
+    * e_a = -2; e_b = -1023
+    * fl_flag || fg_flag || fe_flag = 111
+    */
+
+   /* fg_flag <- 1 if FRB is +zero
+    * NOTE: FRA = Inf also sets fe_flag
+    * Let FRA = val #5; FRB = val #5
+    * ea_ = -1023; e_b = -1023
+    * fl_flag || fg_flag || fe_flag = 111
+    */
+
+   /* fg_flag <- 1 if FRB is -zero
+    * NOTE: FRA = Inf also sets fe_flag
+    * Let FRA = val #5; FRB = val #6
+    * ea_ = -1023; e_b = -1023
+    * fl_flag || fg_flag || fe_flag = 111
+    */
+
+   /* Special values */
+   /* +0.0      : 0 0x000 0x0000000000000 */
+   // #5
+   s = 0;
+   _exp = 0x000;
+   mant = 0x0000000000000ULL;
+   register_farg(&spec_fargs[i++], s, _exp, mant);
+
+   /* -0.0      : 1 0x000 0x0000000000000 */
+   // #6
+   s = 1;
+   _exp = 0x000;
+   mant = 0x0000000000000ULL;
+   register_farg(&spec_fargs[i++], s, _exp, mant);
+
+   /* +infinity : 0 0x7FF 0x0000000000000  */
+   // #7
+   s = 0;
+   _exp = 0x7FF;
+   mant = 0x0000000000000ULL;
+   register_farg(&spec_fargs[i++], s, _exp, mant);
+
+   /* -infinity : 1 0x7FF 0x0000000000000 */
+   // #8
+   s = 1;
+   _exp = 0x7FF;
+   mant = 0x0000000000000ULL;
+   register_farg(&spec_fargs[i++], s, _exp, mant);
+
+   /* +QNaN     : 0 0x7FF 0x7FFFFFFFFFFFF */
+   // #9
+   s = 0;
+   _exp = 0x7FF;
+   mant = 0x7FFFFFFFFFFFFULL;
+   register_farg(&spec_fargs[i++], s, _exp, mant);
+
+   /* -QNaN     : 1 0x7FF 0x7FFFFFFFFFFFF */
+   // #10
+   s = 1;
+   _exp = 0x7FF;
+   mant = 0x7FFFFFFFFFFFFULL;
+   register_farg(&spec_fargs[i++], s, _exp, mant);
+
+   /* +SNaN     : 0 0x7FF 0x8000000000000 */
+   // #11
+   s = 0;
+   _exp = 0x7FF;
+   mant = 0x8000000000000ULL;
+   register_farg(&spec_fargs[i++], s, _exp, mant);
+
+   /* -SNaN     : 1 0x7FF 0x8000000000000 */
+   // #12
+   s = 1;
+   _exp = 0x7FF;
+   mant = 0x8000000000000ULL;
+   register_farg(&spec_fargs[i++], s, _exp, mant);
+
+   /* denormalized value */
+   // #13
+   s = 1;
+   _exp = 0x000;
+   mant = 0x8340000078000ULL;
+   register_farg(&spec_fargs[i++], s, _exp, mant);
+
+   /* Negative finite number */
+   // #14
+   s = 1;
+   _exp = 0x40d;
+   mant = 0x0650f5a07b353ULL;
+   register_farg(&spec_fargs[i++], s, _exp, mant);
+
+   nb_special_fargs = i;
+}
+
+
+struct test_table
+{
+   test_func_t test_category;
+   char * name;
+};
+
+struct p7_fp_test
+{
+   test_func_t test_func;
+   const char *name;
+   int single;  // 1=single precision result; 0=double precision result
+};
+
+typedef enum {
+   VX_FP_CMP,
+   VX_FP_SMA,
+   VX_FP_SMS,
+   VX_FP_SNMA,
+   VX_FP_OTHER
+} vx_fp_test_type;
+
+struct vx_fp_test
+{
+   test_func_t test_func;
+   const char *name;
+   fp_test_args_t * targs;
+   int num_tests;
+   vx_fp_test_type test_type;
+};
+
+struct xs_conv_test
+{
+   test_func_t test_func;
+   const char *name;
+   unsigned long long * results;
+   int num_tests;
+};
+
+typedef enum {
+   VSX_LOAD =1,
+   VSX_LOAD_SPLAT,
+   VSX_STORE
+} vsx_ldst_type;
+
+struct ldst_test
+{
+   test_func_t test_func;
+   const char *name;
+   void * base_addr;
+   uint32_t offset;
+   int num_words_to_process;
+   vsx_ldst_type type;
+};
+
+typedef enum {
+   VSX_AND = 1,
+   VSX_XOR,
+   VSX_ANDC,
+   VSX_OR,
+   VSX_NOR
+} vsx_log_op;
+
+struct vsx_logic_test
+{
+   test_func_t test_func;
+   const char *name;
+   vsx_log_op op;
+};
+
+struct vsx_move_test
+{
+   test_func_t test_func;
+   const char *name;
+   int xa_idx, xb_idx;
+   unsigned long long expected_result;
+};
+
+struct vsx_permute_test
+{
+   test_func_t test_func;
+   const char *name;
+   unsigned int xa[4];
+   unsigned int xb[4];
+   unsigned int expected_output[4];
+};
+
+static vector unsigned int vec_out, vec_inA, vec_inB;
+
+static void test_lxsdx(void)
+{
+   __asm__ __volatile__ ("lxsdx          %x0, %1, %2" : "=wa" (vec_out): "b" (r14),"r" (r15));
+}
+
+static void
+test_lxvd2x(void)
+{
+   __asm__ __volatile__ ("lxvd2x          %x0, %1, %2" : "=wa" (vec_out): "b" (r14),"r" (r15));
+}
+
+static void test_lxvdsx(void)
+{
+   __asm__ __volatile__ ("lxvdsx          %x0, %1, %2" : "=wa" (vec_out): "b" (r14),"r" (r15));
+}
+
+static void test_lxvw4x(void)
+{
+   __asm__ __volatile__ ("lxvw4x          %x0, %1, %2" : "=wa" (vec_out): "b" (r14),"r" (r15));
+}
+
+static void test_stxsdx(void)
+{
+   __asm__ __volatile__ ("stxsdx          %x0, %1, %2" : : "wa" (vec_inA), "b" (r14),"r" (r15));
+}
+
+static void test_stxvd2x(void)
+{
+   __asm__ __volatile__ ("stxvd2x          %x0, %1, %2" : : "wa" (vec_inA), "b" (r14),"r" (r15));
+}
+
+static void test_stxvw4x(void)
+{
+   __asm__ __volatile__ ("stxvw4x          %x0, %1, %2" : : "wa" (vec_inA), "b" (r14),"r" (r15));
+}
+
+static void test_xxlxor(void)
+{
+   __asm__ __volatile__ ("xxlxor          %x0, %x1, %x2" : "=wa" (vec_out): "wa" (vec_inA),"wa" (vec_inB));
+}
+
+static void test_xxlor(void)
+{
+   __asm__ __volatile__ ("xxlor          %x0, %x1, %x2" : "=wa" (vec_out): "wa" (vec_inA),"wa" (vec_inB));
+}
+
+static void test_xxlnor(void)
+{
+   __asm__ __volatile__ ("xxlnor          %x0, %x1, %x2" : "=wa" (vec_out): "wa" (vec_inA),"wa" (vec_inB));
+}
+
+static void test_xxland(void)
+{
+   __asm__ __volatile__ ("xxland          %x0, %x1, %x2" : "=wa" (vec_out): "wa" (vec_inA),"wa" (vec_inB));
+}
+
+static void test_xxlandc(void)
+{
+   __asm__ __volatile__ ("xxlandc          %x0, %x1, %x2" : "=wa" (vec_out): "wa" (vec_inA),"wa" (vec_inB));
+}
+
+static void test_xxmrghw(void)
+{
+   __asm__ __volatile__ ("xxmrghw          %x0, %x1, %x2" : "=wa" (vec_out): "wa" (vec_inA),"wa" (vec_inB));
+}
+
+static void test_xxmrglw(void)
+{
+   __asm__ __volatile__ ("xxmrglw          %x0, %x1, %x2" : "=wa" (vec_out): "wa" (vec_inA),"wa" (vec_inB));
+}
+
+static void test_xxpermdi_00(void)
+{
+   __asm__ __volatile__ ("xxpermdi         %x0, %x1, %x2, 0x0" : "=wa" (vec_out): "wa" (vec_inA),"wa" (vec_inB));
+}
+
+static void test_xxpermdi_01(void)
+{
+   __asm__ __volatile__ ("xxpermdi         %x0, %x1, %x2, 0x1" : "=wa" (vec_out): "wa" (vec_inA),"wa" (vec_inB));
+}
+
+static void test_xxpermdi_10(void)
+{
+   __asm__ __volatile__ ("xxpermdi         %x0, %x1, %x2, 0x2" : "=wa" (vec_out): "wa" (vec_inA),"wa" (vec_inB));
+}
+
+static void test_xxpermdi_11(void)
+{
+   __asm__ __volatile__ ("xxpermdi         %x0, %x1, %x2, 0x3" : "=wa" (vec_out): "wa" (vec_inA),"wa" (vec_inB));
+}
+
+static void test_xxsldwi_0(void)
+{
+   __asm__ __volatile__ ("xxsldwi         %x0, %x1, %x2, 0" : "=wa" (vec_out): "wa" (vec_inA),"wa" (vec_inB));
+}
+
+static void test_xxsldwi_1(void)
+{
+   __asm__ __volatile__ ("xxsldwi         %x0, %x1, %x2, 1" : "=wa" (vec_out): "wa" (vec_inA),"wa" (vec_inB));
+}
+
+static void test_xxsldwi_2(void)
+{
+   __asm__ __volatile__ ("xxsldwi         %x0, %x1, %x2, 2" : "=wa" (vec_out): "wa" (vec_inA),"wa" (vec_inB));
+}
+
+static void test_xxsldwi_3(void)
+{
+   __asm__ __volatile__ ("xxsldwi         %x0, %x1, %x2, 3" : "=wa" (vec_out): "wa" (vec_inA),"wa" (vec_inB));
+}
+
+static void test_fcfids (void)
+{
+    __asm__ __volatile__ ("fcfids          %0, %1" : "=f" (f17): "d" (f14));
+}
+
+static void test_fcfidus (void)
+{
+    __asm__ __volatile__ ("fcfidus          %0, %1" : "=f" (f17): "d" (f14));
+}
+
+static void test_fcfidu (void)
+{
+    __asm__ __volatile__ ("fcfidu          %0, %1" : "=f" (f17): "d" (f14));
+}
+
+static void test_xsabsdp (void)
+{
+   __asm__ __volatile__ ("xsabsdp          %x0, %x1" : "=wa" (vec_out): "wa" (vec_inB));
+}
+
+static void test_xscpsgndp (void)
+{
+   __asm__ __volatile__ ("xscpsgndp          %x0, %x1, %x2" : "=wa" (vec_out): "wa" (vec_inA),"wa" (vec_inB));
+}
+
+static void test_xsnabsdp (void)
+{
+   __asm__ __volatile__ ("xsnabsdp          %x0, %x1" : "=wa" (vec_out): "wa" (vec_inB));
+}
+
+static void test_xsnegdp (void)
+{
+   __asm__ __volatile__ ("xsnegdp          %x0, %x1" : "=wa" (vec_out): "wa" (vec_inB));
+}
+
+static int do_cmpudp;
+static void test_xscmp (void)
+{
+   if (do_cmpudp)
+      __asm__ __volatile__ ("xscmpudp          cr1, %x0, %x1" : : "wa" (vec_inA),"wa" (vec_inB));
+   else
+      __asm__ __volatile__ ("xscmpodp          cr1, %x0, %x1" : : "wa" (vec_inA),"wa" (vec_inB));
+}
+
+static void test_xsadddp(void)
+{
+   __asm__ __volatile__ ("xsadddp          %x0, %x1, %x2" : "=wa" (vec_out): "wa" (vec_inA),"wa" (vec_inB));
+}
+
+static void test_xsdivdp(void)
+{
+   __asm__ __volatile__ ("xsdivdp          %x0, %x1, %x2" : "=wa" (vec_out): "wa" (vec_inA),"wa" (vec_inB));
+}
+
+static int do_adp;
+static void test_xsmadd(void)
+{
+   if (do_adp)
+      __asm__ __volatile__ ("xsmaddadp          %x0, %x1, %x2" : "+wa" (vec_out): "wa" (vec_inA),"wa" (vec_inB));
+   else
+      __asm__ __volatile__ ("xsmaddmdp          %x0, %x1, %x2" : "+wa" (vec_out): "wa" (vec_inA),"wa" (vec_inB));
+}
+
+static void test_xsmsub(void)
+{
+   if (do_adp)
+      __asm__ __volatile__ ("xsmsubadp          %x0, %x1, %x2" : "+wa" (vec_out): "wa" (vec_inA),"wa" (vec_inB));
+   else
+      __asm__ __volatile__ ("xsmsubmdp          %x0, %x1, %x2" : "+wa" (vec_out): "wa" (vec_inA),"wa" (vec_inB));
+}
+
+static void test_xsnmadd(void)
+{
+   if (do_adp)
+      __asm__ __volatile__ ("xsnmaddadp          %x0, %x1, %x2" : "+wa" (vec_out): "wa" (vec_inA),"wa" (vec_inB));
+   else
+      __asm__ __volatile__ ("xsnmaddmdp          %x0, %x1, %x2" : "+wa" (vec_out): "wa" (vec_inA),"wa" (vec_inB));
+}
+
+static void test_xsmuldp(void)
+{
+   __asm__ __volatile__ ("xsmuldp          %x0, %x1, %x2" : "=wa" (vec_out): "wa" (vec_inA),"wa" (vec_inB));
+}
+
+static void test_xssubdp(void)
+{
+   __asm__ __volatile__ ("xssubdp          %x0, %x1, %x2" : "=wa" (vec_out): "wa" (vec_inA),"wa" (vec_inB));
+}
+
+static void test_xscvdpsxds (void)
+{
+   __asm__ __volatile__ ("xscvdpsxds          %x0, %x1" : "=wa" (vec_out): "wa" (vec_inB));
+}
+
+static void test_xscvsxddp (void)
+{
+   __asm__ __volatile__ ("xscvsxddp          %x0, %x1" : "=wa" (vec_out): "wa" (vec_inB));
+}
+
+static void test_xscvuxddp (void)
+{
+   __asm__ __volatile__ ("xscvuxddp          %x0, %x1" : "=wa" (vec_out): "wa" (vec_inB));
+}
+
+static unsigned int vstg[] __attribute__ ((aligned (16))) = { 0, 0, 0,0,
+                                                              0, 0, 0, 0 };
+
+#define NUM_VSTG_INTS (sizeof vstg/sizeof vstg[0])
+#define NUM_VSTG_VECS (NUM_VSTG_INTS/4)
+
+static unsigned int viargs[] __attribute__ ((aligned (16))) = { 0x01234567,
+                                                                0x89abcdef,
+                                                                0x00112233,
+                                                                0x44556677,
+                                                                0x8899aabb,
+                                                                0x91929394,
+                                                                0xa1a2a3a4,
+                                                                0xb1b2b3b4,
+                                                                0xc1c2c3c4,
+                                                                0xd1d2d3d4,
+                                                                0x7a6b5d3e
+};
+#define NUM_VIARGS_INTS (sizeof viargs/sizeof viargs[0])
+#define NUM_VIARGS_VECS  (NUM_VIARGS_INTS/4)
+
+static ldst_test_t ldst_tests[] = { { &test_lxsdx, "lxsdx", viargs, 0, 2, VSX_LOAD },
+                                     { &test_lxsdx, "lxsdx", viargs, 4, 2, VSX_LOAD },
+                                     { &test_lxvd2x, "lxvd2x", viargs, 0, 4, VSX_LOAD },
+                                     { &test_lxvd2x, "lxvd2x", viargs, 4, 4, VSX_LOAD },
+                                     { &test_lxvdsx, "lxvdsx", viargs, 0, 4, VSX_LOAD_SPLAT },
+                                     { &test_lxvdsx, "lxvdsx", viargs, 4, 4, VSX_LOAD_SPLAT },
+                                     { &test_lxvw4x, "lxvw4x", viargs, 0, 4, VSX_LOAD },
+                                     { &test_lxvw4x, "lxvw4x", viargs, 4, 4, VSX_LOAD },
+                                     { &test_stxsdx, "stxsdx", vstg, 0, 2, VSX_STORE },
+                                     { &test_stxsdx, "stxsdx", vstg, 4, 2, VSX_STORE },
+                                     { &test_stxvd2x, "stxvd2x", vstg, 0, 4, VSX_STORE },
+                                     { &test_stxvd2x, "stxvd2x", vstg, 4, 4, VSX_STORE },
+                                     { &test_stxvw4x, "stxvw4x", vstg, 0, 4, VSX_STORE },
+                                     { &test_stxvw4x, "stxvw4x", vstg, 4, 4, VSX_STORE },
+                                     { NULL, NULL, NULL, 0, 0, 0 } };
+
+static logic_test_t logic_tests[] = { { &test_xxlxor, "xxlxor", VSX_XOR },
+                                      { &test_xxlor, "xxlor", VSX_OR } ,
+                                      { &test_xxlnor, "xxlnor", VSX_NOR },
+                                      { &test_xxland, "xxland", VSX_AND },
+                                      { &test_xxlandc, "xxlandc", VSX_ANDC },
+                                      { NULL, NULL}};
+
+static move_test_t move_tests[] = { { &test_xsabsdp, "xsabsdp", 0, 4, 0x0899aabb91929394ULL },
+                                    { &test_xscpsgndp, "xscpsgndp", 4, 0, 0x8123456789abcdefULL },
+                                    { &test_xsnabsdp, "xsnabsdp", 7, 3, 0xc45566778899aabbULL, },
+                                    { &test_xsnegdp, "xsnegdp", 0, 7, 0x31b2b3b4c1c2c3c4ULL, },
+                                    { NULL, NULL, 0, 0, 0 }
+
+};
+
+static permute_test_t permute_tests[] =
+{
+  { &test_xxmrghw, "xxmrghw", 
+    { 0x11111111, 0x22222222, 0x33333333, 0x44444444 }, /* XA input */
+    { 0x55555555, 0x66666666, 0x77777777, 0x88888888 }, /* XB input */
+    { 0x11111111, 0x55555555, 0x22222222, 0x66666666 }  /* XT expected output */
+  },
+  { &test_xxmrghw, "xxmrghw", 
+    { 0x00112233, 0x44556677, 0x8899aabb, 0xccddeeff }, /* XA input */
+    { 0x11111111, 0x22222222, 0x33333333, 0x44444444 }, /* XB input */
+    { 0x00112233, 0x11111111, 0x44556677, 0x22222222 }  /* XT expected output */
+  },
+  { &test_xxmrglw, "xxmrglw", 
+    { 0x11111111, 0x22222222, 0x33333333, 0x44444444 }, /* XA input */
+    { 0x55555555, 0x66666666, 0x77777777, 0x88888888 }, /* XB input */
+    { 0x33333333, 0x77777777, 0x44444444, 0x88888888 }  /* XT expected output */
+  },
+  { &test_xxmrglw, "xxmrglw", 
+    { 0x00112233, 0x44556677, 0x8899aabb, 0xccddeeff}, /* XA input */
+    { 0x11111111, 0x22222222, 0x33333333, 0x44444444}, /* XB input */
+    { 0x8899aabb, 0x33333333, 0xccddeeff, 0x44444444}  /* XT expected output */
+  },
+  { &test_xxpermdi_00, "xxpermdi DM=00", 
+    { 0x11111111, 0x22222222, 0x33333333, 0x44444444 }, /* XA input */
+    { 0x55555555, 0x66666666, 0x77777777, 0x88888888 }, /* XB input */
+    { 0x11111111, 0x22222222, 0x55555555, 0x66666666 }  /* XT expected output */
+  },
+  { &test_xxpermdi_01, "xxpermdi DM=01", 
+    { 0x11111111, 0x22222222, 0x33333333, 0x44444444 }, /* XA input */
+    { 0x55555555, 0x66666666, 0x77777777, 0x88888888 }, /* XB input */
+    { 0x11111111, 0x22222222, 0x77777777, 0x88888888 }  /* XT expected output */
+  },
+  { &test_xxpermdi_10, "xxpermdi DM=10", 
+    { 0x11111111, 0x22222222, 0x33333333, 0x44444444 }, /* XA input */
+    { 0x55555555, 0x66666666, 0x77777777, 0x88888888 }, /* XB input */
+    { 0x33333333, 0x44444444, 0x55555555, 0x66666666 }  /* XT expected output */
+  },
+  { &test_xxpermdi_11, "xxpermdi DM=11", 
+    { 0x11111111, 0x22222222, 0x33333333, 0x44444444 }, /* XA input */
+    { 0x55555555, 0x66666666, 0x77777777, 0x88888888 }, /* XB input */
+    { 0x33333333, 0x44444444, 0x77777777, 0x88888888 }  /* XT expected output */
+  },
+  { &test_xxsldwi_0, "xxsldwi SHW=0", 
+    { 0x11111111, 0x22222222, 0x33333333, 0x44444444 }, /* XA input */
+    { 0x55555555, 0x66666666, 0x77777777, 0x88888888 }, /* XB input */
+    { 0x11111111, 0x22222222, 0x33333333, 0x44444444 }  /* XT expected output */
+  },
+  { &test_xxsldwi_1, "xxsldwi SHW=1", 
+    { 0x11111111, 0x22222222, 0x33333333, 0x44444444 }, /* XA input */
+    { 0x55555555, 0x66666666, 0x77777777, 0x88888888 }, /* XB input */
+    { 0x22222222, 0x33333333, 0x44444444, 0x55555555 }  /* XT expected output */
+  },
+  { &test_xxsldwi_2, "xxsldwi SHW=2", 
+    { 0x11111111, 0x22222222, 0x33333333, 0x44444444 }, /* XA input */
+    { 0x55555555, 0x66666666, 0x77777777, 0x88888888 }, /* XB input */
+    { 0x33333333, 0x44444444, 0x55555555, 0x66666666 }  /* XT expected output */
+  },
+  { &test_xxsldwi_3, "xxsldwi SHW=3", 
+    { 0x11111111, 0x22222222, 0x33333333, 0x44444444 }, /* XA input */
+    { 0x55555555, 0x66666666, 0x77777777, 0x88888888 }, /* XB input */
+    { 0x44444444, 0x55555555, 0x66666666, 0x77777777 }  /* XT expected output */
+  },
+  { NULL, NULL }
+};
+
+static fp_test_t fp_tests[] = { { &test_fcfids, "fcfids", 1 },
+                                { &test_fcfidus, "fcfidus", 1 },
+                                { &test_fcfidu, "fcfidu", 1 },
+                                { NULL, NULL, 0 },
+
+};
+
+static vx_fp_test_t vx_fp_tests[] = {
+                                     { &test_xscmp, "xscmp", xscmpX_tests, 64, VX_FP_CMP},
+                                     { &test_xsadddp, "xsadddp", xsadddp_tests, 64, VX_FP_OTHER},
+                                     { &test_xsdivdp, "xsdivdp", xsdivdp_tests, 64, VX_FP_OTHER},
+                                     { &test_xsmadd, "xsmadd", xsmaddXdp_tests, 64, VX_FP_SMA},
+                                     { &test_xsmsub, "xsmsub", xsmsubXdp_tests, 64, VX_FP_SMS},
+                                     { &test_xsnmadd, "xsnmadd", xsnmaddXdp_tests, 64, VX_FP_SNMA},
+                                     { & test_xsmuldp, "xsmuldp", xsmuldp_tests, 64, VX_FP_OTHER},
+                                     { & test_xssubdp, "xssubdp", xssubdp_tests, 64, VX_FP_OTHER},
+                                     { NULL, NULL, NULL, 0, 0 }
+};
+
+static xs_conv_test_t xs_conv_tests[] = {
+                                         { &test_xscvdpsxds, "xscvdpsxds", xscvdpsxds_results, 15},
+                                         { &test_xscvsxddp, "xscvsxddp", xscvsxddp_results, 15},
+                                         { &test_xscvuxddp, "xscvuxddp", xscvuxddp_results, 15},
+                                         { NULL, NULL, NULL, 0}
+};
+
+#ifdef __powerpc64__
+static void test_ldbrx(void)
+{
+   int i, equality;
+   HWord_t reg_out;
+   unsigned char * byteIn, * byteOut;
+   r14 = (HWord_t)viargs;
+   // Just try the instruction an arbitrary number of times at different r15 offsets.
+   for (i = 0; i < 3; i++) {
+      int j, k;
+      reg_out = 0;
+      r15 = i * 4;
+      equality = 1;
+      __asm__ __volatile__ ("ldbrx          %0, %1, %2" : "=r" (reg_out): "b" (r14),"r" (r15));
+      byteIn = ((unsigned char *)(r14 + r15));
+      byteOut = (unsigned char *)&reg_out;
+
+      printf("ldbrx:");
+      for (k = 0; k < 7; k++) {
+         printf( " %02x", (byteIn[k]));
+      }
+      printf(" (reverse) =>");
+      for (j = 0; j < 8; j++) {
+         printf( " %02x", (byteOut[j]));
+      }
+      printf("\n");
+      for (j = 0, k = 7; j < 8; j++, k--) {
+         equality &= (byteIn[k] == byteOut[j]);
+      }
+      if (!equality) {
+         printf("FAILED: load with byte reversal is incorrect\n");
+         errors++;
+      }
+   }
+   printf( "\n" );
+}
+
+static void
+test_popcntd(void)
+{
+   uint64_t res;
+   unsigned long long src = 0x9182736405504536ULL;
+   int i, answer = 0;
+   r14 = src;
+   __asm__ __volatile__ ("popcntd          %0, %1" : "=r" (res): "r" (r14));
+   for (i = 0; i < 64; i++) {
+      answer += (r14 & 1ULL);
+      r14 = r14 >> 1;
+   }
+   printf("popcntd: 0x%llx => %d\n", src, (int)res);
+   if (res!= answer) {
+      printf("Error: unexpected result from popcntd\n");
+      errors++;
+   }
+   printf( "\n" );
+}
+#endif
+
+static void
+test_lfiwzx(void)
+{
+   unsigned int i;
+   unsigned int * src;
+   uint64_t reg_out;
+   r14 = (HWord_t)viargs;
+   // Just try the instruction an arbitrary number of times at different r15 offsets.
+   for (i = 0; i < 3; i++) {
+      reg_out = 0;
+      r15 = i * 4;
+      __asm__ __volatile__ ("lfiwzx          %0, %1, %2" : "=d" (reg_out): "b" (r14),"r" (r15));
+      src = ((unsigned int *)(r14 + r15));
+      printf("lfiwzx: %u => %llu.00\n", *src, (unsigned long long)reg_out);
+
+      if (reg_out > 0xFFFFFFFFULL || *src != (unsigned int)reg_out) {
+         printf("FAILED: integer load to FP register is incorrect\n");
+         errors++;
+      }
+   }
+   printf( "\n" );
+}
+
+static void test_vx_fp_ops(void)
+{
+
+   test_func_t func;
+   int k;
+   char * test_name = (char *)malloc(20);
+   k = 0;
+
+   build_special_fargs_table();
+   while ((func = vx_fp_tests[k].test_func)) {
+      int i, condreg, repeat = 0;
+      unsigned int flags;
+      unsigned long long * frap, * frbp, * dst;
+      vx_fp_test_t test_group = vx_fp_tests[k];
+      vx_fp_test_type test_type = test_group.test_type;
+
+      switch (test_type) {
+         case VX_FP_CMP:
+            strcpy(test_name, "xscmp");
+            if (!repeat) {
+               repeat = 1;
+               strcat(test_name, "udp");
+               do_cmpudp = 1;
+            }
+            break;
+         case VX_FP_SMA:
+         case VX_FP_SMS:
+         case VX_FP_SNMA:
+            if (test_type == VX_FP_SMA)
+               strcpy(test_name, "xsmadd");
+            else if (test_type == VX_FP_SMS)
+               strcpy(test_name, "xsmsub");
+            else
+               strcpy(test_name, "xsnmadd");
+            if (!repeat) {
+               repeat = 1;
+               strcat(test_name, "adp");
+               do_adp = 1;
+            }
+            break;
+         case VX_FP_OTHER:
+            strcpy(test_name, test_group.name);
+            break;
+         default:
+            printf("ERROR:  Invalid VX FP test type %d\n", test_type);
+            exit(1);
+      }
+
+again:
+      for (i = 0; i < test_group.num_tests; i++) {
+         unsigned int * inA, * inB, * pv;
+
+         fp_test_args_t aTest = test_group.targs[i];
+         inA = (unsigned int *)&spec_fargs[aTest.fra_idx];
+         inB = (unsigned int *)&spec_fargs[aTest.frb_idx];
+         frap = (unsigned long long *)&spec_fargs[aTest.fra_idx];
+         frbp = (unsigned long long *)&spec_fargs[aTest.frb_idx];
+         // Only need to copy one doubleword into each vector's element 0
+         memcpy(&vec_inA, inA, 8);
+         memcpy(&vec_inB, inB, 8);
+
+         switch (test_type) {
+            case VX_FP_CMP:
+               SET_FPSCR_ZERO;
+               SET_CR_XER_ZERO;
+               (*func)();
+               GET_CR(flags);
+               condreg = (flags & 0x0f000000) >> 24;
+               printf("#%d: %s %016llx <=> %016llx ? %x (CRx)\n", i, test_name, *frap, *frbp, condreg);
+              // printf("\tFRA: %e;  FRB: %e\n", spec_fargs[aTest.fra_idx], spec_fargs[aTest.frb_idx]);
+               if ( condreg != aTest.cr_flags) {
+                  printf("Error: Expected CR flags 0x%x; actual flags: 0x%x\n", aTest.cr_flags, condreg);
+                  errors++;
+               }
+               break;
+            case VX_FP_SMA:
+            case VX_FP_SMS:
+            case VX_FP_SNMA:
+            case VX_FP_OTHER:
+            {
+               int idx;
+               unsigned long long vsr_XT;
+               pv = (unsigned int *)&vec_out;
+               // clear vec_out
+               for (idx = 0; idx < 4; idx++, pv++)
+                  *pv = 0;
+
+               if (test_type != VX_FP_OTHER) {
+                  /* Then we need a third src argument, which is stored in element 0 of
+                   * VSX[XT] -- i.e., vec_out.  For the xs<ZZZ>mdp cases, VSX[XT] holds
+                   * src3 and VSX[XB] holds src2; for the xs<ZZZ>adp cases, VSX[XT] holds
+                   * src2 and VSX[XB] holds src3.  The fp_test_args_t that holds the test
+                   * data (input args, result) contain only two inputs, so I arbitrarily
+                   * use spec_fargs elements 4 and 14 (alternating) for the third source
+                   * argument.  We can use the same input data for a given pair of
+                   * adp/mdp-type instructions by swapping the src2 and src3 arguments; thus
+                   * the expected result should be the same.
+                   */
+                  int extra_arg_idx;
+                  if (i % 2)
+                     extra_arg_idx = 4;
+                  else
+                     extra_arg_idx = 14;
+
+                     //memcpy(&vec_out, &spec_fargs[14], 8);
+
+                  if (repeat) {
+                     /* We're on the first time through of one of the VX_FP_SMx
+                      * test types, meaning we're testing a xs<ZZZ>adp case, thus we
+                      * have to swap inputs as described above:
+                      *    src2 <= VSX[XT]
+                      *    src3 <= VSX[XB]
+                      */
+                     memcpy(&vec_out, inB, 8);  // src2
+                     memcpy(&vec_inB, &spec_fargs[extra_arg_idx], 8);  //src3
+                     frbp = (unsigned long long *)&spec_fargs[extra_arg_idx];
+                  } else {
+                     // Don't need to init src2, as it's done before the switch()
+                     memcpy(&vec_out, &spec_fargs[extra_arg_idx], 8);  //src3
+                  }
+                  memcpy(&vsr_XT, &vec_out, 8);
+               }
+
+               (*func)();
+               dst = (unsigned long long *) &vec_out;
+               if (test_type == VX_FP_OTHER)
+                  printf("#%d: %s %016llx %016llx = %016llx\n", i, test_name, *frap, *frbp, *dst);
+               else
+                  printf( "#%d: %s %016llx %016llx %016llx = %016llx\n", i,
+                          test_name, vsr_XT, *frap, *frbp, *dst );
+
+               if ( *dst != aTest.dp_bin_result) {
+                  printf("Error: Expected result %016llx; actual result %016llx\n", aTest.dp_bin_result, *dst);
+                  errors++;
+               }
+               /*
+              {
+                  // Debug code.  Keep this block commented out except when debugging.
+                  double result, expected;
+                  memcpy(&result, dst, 8);
+                  memcpy(&expected, &aTest.dp_bin_result, 8);
+                  printf( "\tFRA + FRB: %e + %e: Expected = %e; Actual = %e\n",
+                          spec_fargs[aTest.fra_idx], spec_fargs[aTest.frb_idx],
+                          expected, result );
+               }
+              */
+               break;
+            }
+         }
+
+
+      }
+      printf( "\n" );
+
+      if (repeat) {
+         repeat = 0;
+         switch (test_type) {
+            case VX_FP_CMP:
+               strcpy(test_name, "xscmp");
+               strcat(test_name, "odp");
+               do_cmpudp = 0;
+               break;
+            case VX_FP_SMA:
+            case VX_FP_SMS:
+            case VX_FP_SNMA:
+               if (test_type == VX_FP_SMA)
+                  strcpy(test_name, "xsmadd");
+               else if (test_type == VX_FP_SMS)
+                  strcpy(test_name, "xsmsub");
+               else
+                  strcpy(test_name, "xsnmadd");
+               strcat(test_name, "mdp");
+               do_adp = 0;
+               break;
+            case VX_FP_OTHER:
+               break;
+         }
+         goto again;
+      }
+      k++;
+   }
+   printf( "\n" );
+   free(test_name);
+}
+
+static void test_xs_conv_ops(void)
+{
+
+   test_func_t func;
+   int k = 0;
+
+   build_special_fargs_table();
+   while ((func = xs_conv_tests[k].test_func)) {
+      int i;
+      unsigned long long * frbp, * dst;
+      xs_conv_test_t test_group = xs_conv_tests[k];
+      for (i = 0; i < test_group.num_tests; i++) {
+         unsigned int * inB, * pv;
+         int idx;
+         unsigned long long exp_result = test_group.results[i];
+         inB = (unsigned int *)&spec_fargs[i];
+         frbp = (unsigned long long *)&spec_fargs[i];
+         memcpy(&vec_inB, inB, 8);
+         pv = (unsigned int *)&vec_out;
+         // clear vec_out
+         for (idx = 0; idx < 4; idx++, pv++)
+            *pv = 0;
+         (*func)();
+         dst = (unsigned long long *) &vec_out;
+         printf("#%d: %s %016llx => %016llx\n", i, test_group.name, *frbp, *dst);
+
+         if ( *dst != exp_result) {
+            printf("Error: Expected result %016llx; actual result %016llx\n", exp_result, *dst);
+            errors++;
+         }
+      }
+      k++;
+      printf("\n");
+   }
+   printf( "\n" );
+}
+
+static void do_load_test(ldst_test_t loadTest)
+{
+   test_func_t func;
+   unsigned int *src, *dst;
+   int splat = loadTest.type == VSX_LOAD_SPLAT ? 1: 0;
+   int i, j, m, equality;
+   i = j = 0;
+
+   func = loadTest.test_func;
+   for (i = 0, r14 = (HWord_t) loadTest.base_addr; i < NUM_VIARGS_VECS; i++) {
+      int again;
+      j = 0;
+       r14 += i * 16;
+      do {
+         unsigned int * pv = (unsigned int *)&vec_out;
+         int idx;
+         // clear vec_out
+         for (idx = 0; idx < 4; idx++, pv+=idx)
+            *pv = 0;
+
+         again = 0;
+         r15 = j;
+
+         // execute test insn
+         (*func)();
+
+         src = (unsigned int*) (((unsigned char *)r14) + j);
+         dst = (unsigned int*) &vec_out;
+
+         printf( "%s:", loadTest.name);
+         for (m = 0; m < loadTest.num_words_to_process; m++) {
+            printf( " %08x", src[splat ? m % 2 : m]);
+         }
+         printf( " =>");
+         for (m = 0; m < loadTest.num_words_to_process; m++) {
+            printf( " %08x", dst[m]);
+         }
+         printf("\n");
+         equality = 1;
+         for (m = 0; m < loadTest.num_words_to_process; m++) {
+            equality = equality && (src[splat ? m % 2 : m] == dst[m]);
+         }
+
+         if (!equality) {
+            printf("FAILED: loaded vector is incorrect\n");
+            errors++;
+         }
+
+         if (j == 0 && loadTest.offset) {
+            again = 1;
+            j += loadTest.offset;
+         }
+      }
+      while (again);
+   }
+}
+
+static void
+do_store_test ( ldst_test_t storeTest )
+{
+   test_func_t func;
+   unsigned int *src, *dst;
+   int i, j, m, equality;
+   i = j = 0;
+
+   func = storeTest.test_func;
+   r14 = (HWord_t) storeTest.base_addr;
+   r15 = (HWord_t) storeTest.offset;
+   unsigned int * pv = (unsigned int *) storeTest.base_addr;
+   int idx;
+   // clear out storage destination
+   for (idx = 0; idx < 4; idx++, pv += idx)
+      *pv = 0;
+
+   memcpy(&vec_inA, &viargs[0], sizeof(vector unsigned char));
+
+   // execute test insn
+   (*func)();
+   src = &viargs[0];
+   dst = (unsigned int*) (((unsigned char *) r14) + storeTest.offset);
+
+   printf( "%s:", storeTest.name );
+   for (m = 0; m < storeTest.num_words_to_process; m++) {
+      printf( " %08x", src[m] );
+   }
+   printf( " =>" );
+   for (m = 0; m < storeTest.num_words_to_process; m++) {
+      printf( " %08x", dst[m] );
+   }
+   printf( "\n" );
+   equality = 1;
+   for (m = 0; m < storeTest.num_words_to_process; m++) {
+      equality = equality && (src[m] == dst[m]);
+   }
+
+   if (!equality) {
+      printf( "FAILED: vector store result is incorrect\n" );
+      errors++;
+   }
+
+}
+
+
+static void test_ldst(void)
+{
+   int k = 0;
+
+   while (ldst_tests[k].test_func) {
+      if (ldst_tests[k].type == VSX_STORE)
+         do_store_test(ldst_tests[k]);
+      else
+         do_load_test(ldst_tests[k]);
+      k++;
+      printf("\n");
+   }
+}
+
+static void test_ftdiv(void)
+{
+   int i, num_tests, crx;
+   unsigned int flags;
+   unsigned long long * frap, * frbp;
+   build_special_fargs_table();
+
+   num_tests = sizeof ftdiv_tests/sizeof ftdiv_tests[0];
+
+   for (i = 0; i < num_tests; i++) {
+      ftdiv_test_args_t aTest = ftdiv_tests[i];
+      f14 = spec_fargs[aTest.fra_idx];
+      f15 = spec_fargs[aTest.frb_idx];
+      frap = (unsigned long long *)&spec_fargs[aTest.fra_idx];
+      frbp = (unsigned long long *)&spec_fargs[aTest.frb_idx];
+      SET_FPSCR_ZERO;
+      SET_CR_XER_ZERO;
+      __asm__ __volatile__ ("ftdiv           cr1, %0, %1" : : "d" (f14), "d" (f15));
+      GET_CR(flags);
+      crx = (flags & 0x0f000000) >> 24;
+      printf( "ftdiv: %016llx <=> %016llx ? %x (CRx)\n", *frap, *frbp, crx);
+//      printf("\tFRA: %e;  FRB: %e\n", f14, f15);
+      if ( crx != aTest.cr_flags) {
+         printf("Error: Expected CR flags 0x%x; actual flags: 0x%x\n", aTest.cr_flags, crx);
+         errors++;
+      }
+   }
+   printf( "\n" );
+}
+
+
+static void test_p7_fpops ( void )
+{
+   int k = 0;
+   test_func_t func;
+
+   build_fargs_table();
+   while ((func = fp_tests[k].test_func)) {
+      float res;
+      double resd;
+      unsigned long long u0;
+      int i;
+      int res32 = strcmp(fp_tests[k].name, "fcfidu");
+
+      for (i = 0; i < nb_fargs; i++) {
+         u0 = *(unsigned long long *) (&fargs[i]);
+         f14 = fargs[i];
+         (*func)();
+         if (res32) {
+            res = f17;
+            printf( "%s %016llx => (raw sp) %08x)",
+                    fp_tests[k].name, u0, *((unsigned int *)&res));
+         } else {
+            resd = f17;
+            printf( "%s %016llx => (raw sp) %016llx)",
+                    fp_tests[k].name, u0, *(unsigned long long *)(&resd));
+         }
+         printf( "\n" );
+      }
+
+      k++;
+      printf( "\n" );
+   }
+}
+
+static void test_vsx_logic(void)
+{
+   logic_test_t aTest;
+   test_func_t func;
+   int equality, k;
+   k = 0;
+
+   while ((func = logic_tests[k].test_func)) {
+      unsigned int * pv;
+      int startA, startB;
+      unsigned int * inA, * inB, * dst;
+      int idx, i;
+      startA = 0;
+      aTest = logic_tests[k];
+      for (i = 0; i <= (NUM_VIARGS_INTS - (NUM_VIARGS_VECS * sizeof(int))); i++, startA++) {
+         startB = startA + 4;
+         pv = (unsigned int *)&vec_out;
+         inA = &viargs[startA];
+         inB = &viargs[startB];
+         memcpy(&vec_inA, inA, sizeof(vector unsigned char));
+         memcpy(&vec_inB, inB, sizeof(vector unsigned char));
+         // clear vec_out
+         for (idx = 0; idx < 4; idx++, pv++)
+            *pv = 0;
+
+         // execute test insn
+         (*func)();
+         dst = (unsigned int*) &vec_out;
+
+         printf( "%s:", aTest.name);
+         printf( " %08x %08x %08x %08x %s", inA[0], inA[1], inA[2], inA[3], aTest.name);
+         printf( " %08x %08x %08x %08x", inB[0], inB[1], inB[2], inB[3]);
+         printf(" => %08x %08x %08x %08x\n", dst[0], dst[1], dst[2], dst[3]);
+
+         equality = 1;
+         for (idx = 0; idx < 4; idx++) {
+            switch (aTest.op) {
+               case VSX_AND:
+                  equality &= (dst[idx] == (inA[idx] & inB[idx]));
+                  break;
+               case VSX_ANDC:
+                  equality &= (dst[idx] == (inA[idx] & ~inB[idx]));
+                  break;
+               case VSX_NOR:
+                  equality &= (dst[idx] == ~(inA[idx] | inB[idx]));
+                  break;
+               case VSX_XOR:
+                  equality &= (dst[idx] == (inA[idx] ^ inB[idx]));
+                  break;
+               case VSX_OR:
+                  equality &= (dst[idx] == (inA[idx] | inB[idx]));
+                  break;
+               default:
+                  fprintf(stderr, "Error in test_vsx_logic(): unknown VSX logical op %d\n", aTest.op);
+                  exit(1);
+            }
+         }
+         if (!equality) {
+            printf( "FAILED: vector out is incorrect\n" );
+            errors++;
+         }
+      }
+      k++;
+   }
+   printf( "\n" );
+}
+
+static void test_move_ops (void)
+{
+   move_test_t aTest;
+   test_func_t func;
+   int equality, k;
+   k = 0;
+
+   while ((func = move_tests[k].test_func)) {
+      unsigned int * pv;
+      int startA, startB;
+      unsigned int * inA, * inB, * dst;
+      unsigned long long exp_out;
+      int idx;
+      aTest = move_tests[k];
+      exp_out = aTest.expected_result;
+      startA = aTest.xa_idx;
+      startB = aTest.xb_idx;
+      pv = (unsigned int *)&vec_out;
+      inA = &viargs[startA];
+      inB = &viargs[startB];
+      memcpy(&vec_inA, inA, sizeof(vector unsigned char));
+      memcpy(&vec_inB, inB, sizeof(vector unsigned char));
+      // clear vec_out
+      for (idx = 0; idx < 4; idx++, pv++)
+         *pv = 0;
+
+      // execute test insn
+      (*func)();
+      dst = (unsigned int*) &vec_out;
+
+      printf( "%s:", aTest.name);
+      printf( " %08x %08x %s", inA[0], inA[1], aTest.name);
+      printf( " %08x %08xx", inB[0], inB[1]);
+      printf(" => %08x %08x\n", dst[0], dst[1]);
+
+      equality = 1;
+      pv = (unsigned int *)&exp_out;
+      for (idx = 0; idx < 2; idx++) {
+         equality &= (dst[idx] == pv[idx]);
+      }
+      if (!equality) {
+         printf( "FAILED: vector out is incorrect\n" );
+         errors++;
+      }
+      k++;
+      printf( "\n" );
+   }
+}
+
+static void test_permute_ops (void)
+{
+  permute_test_t *aTest;
+  unsigned int *dst = (unsigned int *) &vec_out;
+
+  for (aTest = &(permute_tests[0]); aTest->test_func != NULL; aTest++)
+    {
+      /* Grab test input and clear output vector.  */
+      memcpy(&vec_inA, aTest->xa, sizeof(vec_inA));
+      memcpy(&vec_inB, aTest->xb, sizeof(vec_inB));
+      memset(dst, 0, sizeof(vec_out));
+
+      /* execute test insn */
+      aTest->test_func();
+
+      printf( "%s:\n", aTest->name);
+      printf( "        XA[%08x,%08x,%08x,%08x]\n",
+              aTest->xa[0], aTest->xa[1], aTest->xa[2], aTest->xa[3]);
+      printf( "        XB[%08x,%08x,%08x,%08x]\n",
+              aTest->xb[0], aTest->xb[1], aTest->xb[2], aTest->xb[3]);
+      printf( "   =>   XT[%08x,%08x,%08x,%08x]\n",
+              dst[0], dst[1], dst[2], dst[3]);
+
+      if (memcmp (dst, &aTest->expected_output, sizeof(vec_out)))
+       {
+         printf( "FAILED: vector out is incorrect\n" );
+         errors++;
+       }
+    }
+  printf( "\n" );
+}
+
+static test_table_t all_tests[] = { { &test_ldst,
+                                       "Test VSX load/store instructions" },
+                                     { &test_vsx_logic,
+                                       "Test VSX logic instructions" },
+#ifdef __powerpc64__
+                                     { &test_ldbrx,
+                                       "Test ldbrx instruction" },
+                                     { &test_popcntd,
+                                       "Test popcntd instruction" },
+#endif
+                                     { &test_lfiwzx,
+                                       "Test lfiwzx instruction" },
+                                     { &test_p7_fpops,
+                                       "Test P7 floating point convert instructions"},
+                                     { &test_ftdiv,
+                                       "Test ftdiv instruction" },
+                                     { &test_move_ops,
+                                       "Test VSX move instructions"},
+                                     { &test_permute_ops,
+                                       "Test VSX permute instructions"},
+                                     { &test_vx_fp_ops,
+                                       "Test VSX floating point instructions"},
+                                     { &test_xs_conv_ops,
+                                       "Test VSX scalar integer conversion instructions" },
+                                     { NULL, NULL }
+};
+#endif // HAS_VSX
+
+int main(int argc, char *argv[])
+{
+#ifdef HAS_VSX
+
+   test_table_t aTest;
+   test_func_t func;
+   int i = 0;
+
+   while ((func = all_tests[i].test_category)) {
+      aTest = all_tests[i];
+      printf( "%s\n", aTest.name );
+      (*func)();
+      i++;
+   }
+   if (errors)
+      printf("Testcase FAILED with %d errors \n", errors);
+   else
+      printf("Testcase PASSED\n");
+
+#endif // HAS _VSX
+
+   return 0;
+}
--- valgrind-3.6.0/none/tests/ppc64/Makefile.am	(revision 11696)
+++ valgrind-3.6.0/none/tests/ppc64/Makefile.am	(revision 11700)
@@ -13,10 +13,11 @@ EXTRA_DIST = \
 	twi_tdi.stderr.exp twi_tdi.stdout.exp twi_tdi.vgtest \
 	tw_td.stderr.exp tw_td.stdout.exp tw_td.vgtest \
 	power6_bcmp.stderr.exp power6_bcmp.stdout.exp power6_bcmp.vgtest \
-	power6_mf_gpr.stderr.exp power6_mf_gpr.stdout.exp power6_mf_gpr.vgtest
+	power6_mf_gpr.stderr.exp power6_mf_gpr.stdout.exp power6_mf_gpr.vgtest \
+	test_isa_2_06_part1.stderr.exp  test_isa_2_06_part1.stdout.exp  test_isa_2_06_part1.vgtest
 
 check_PROGRAMS = \
-	jm-insns lsw round std_reg_imm twi_tdi tw_td power6_bcmp power6_mf_gpr
+	jm-insns lsw round std_reg_imm twi_tdi tw_td power6_bcmp power6_mf_gpr test_isa_2_06_part1
 
 AM_CFLAGS    += @FLAG_M64@
 AM_CXXFLAGS  += @FLAG_M64@
@@ -28,6 +29,17 @@ else
 ALTIVEC_FLAG =
 endif
 
+if HAS_VSX
+BUILD_FLAG_VSX = -mvsx
+VSX_FLAG = -DHAS_VSX
+else
+VSX_FLAG =
+BUILD_FLAG_VSX =
+endif
+
+test_isa_2_06_part1_CFLAGS = $(AM_CFLAGS) -Winline -Wall -O -g -mregnames $(VSX_FLAG) \
+			@FLAG_M64@ $(ALTIVEC_FLAG) $(BUILD_FLAG_VSX)
+
 jm_insns_CFLAGS = $(AM_CFLAGS) -Winline -Wall -O -g -mregnames -maltivec \
 			@FLAG_M64@ $(ALTIVEC_FLAG)
 
--- valgrind-3.6.0/coregrind/m_machine.c	(revision 11696)
+++ valgrind-3.6.0/coregrind/m_machine.c	(revision 11700)
@@ -652,7 +652,7 @@ Bool VG_(machine_get_hwcaps)( void )
      vki_sigaction_fromK_t saved_sigill_act, saved_sigfpe_act;
      vki_sigaction_toK_t     tmp_sigill_act,   tmp_sigfpe_act;
 
-     volatile Bool have_F, have_V, have_FX, have_GX;
+     volatile Bool have_F, have_V, have_FX, have_GX, have_VX;
      Int r;
 
      /* This is a kludge.  Really we ought to back-convert saved_act
@@ -731,6 +731,14 @@ Bool VG_(machine_get_hwcaps)( void )
         __asm__ __volatile__(".long 0xFC000034"); /* frsqrte 0,0 */
      }
 
+     /* VSX support implies Power ISA 2.06 */
+     have_VX = True;
+     if (VG_MINIMAL_SETJMP(env_unsup_insn)) {
+        have_VX = False;
+     } else {
+        __asm__ __volatile__(".long 0xf0000564"); /* xsabsdp XT,XB */
+     }
+
      /* determine dcbz/dcbzl sizes while we still have the signal
       * handlers registered */
      find_ppc_dcbz_sz(&vai);
@@ -741,8 +749,9 @@ Bool VG_(machine_get_hwcaps)( void )
      vg_assert(r == 0);
      r = VG_(sigprocmask)(VKI_SIG_SETMASK, &saved_set, NULL);
      vg_assert(r == 0);
-     VG_(debugLog)(1, "machine", "F %d V %d FX %d GX %d\n", 
-                    (Int)have_F, (Int)have_V, (Int)have_FX, (Int)have_GX);
+     VG_(debugLog)(1, "machine", "F %d V %d FX %d GX %d VX %d\n",
+                    (Int)have_F, (Int)have_V, (Int)have_FX,
+                    (Int)have_GX, (Int)have_VX);
      /* Make FP a prerequisite for VMX (bogusly so), and for FX and GX. */
      if (have_V && !have_F)
         have_V = False;
@@ -761,6 +770,7 @@ Bool VG_(machine_get_hwcaps)( void )
      if (have_V)  vai.hwcaps |= VEX_HWCAPS_PPC32_V;
      if (have_FX) vai.hwcaps |= VEX_HWCAPS_PPC32_FX;
      if (have_GX) vai.hwcaps |= VEX_HWCAPS_PPC32_GX;
+     if (have_VX) vai.hwcaps |= VEX_HWCAPS_PPC32_VX;
 
      /* But we're not done yet: VG_(machine_ppc32_set_clszB) must be
         called before we're ready to go. */
@@ -774,7 +784,7 @@ Bool VG_(machine_get_hwcaps)( void )
      vki_sigaction_fromK_t saved_sigill_act, saved_sigfpe_act;
      vki_sigaction_toK_t     tmp_sigill_act,   tmp_sigfpe_act;
 
-     volatile Bool have_F, have_V, have_FX, have_GX;
+     volatile Bool have_F, have_V, have_FX, have_GX, have_VX;
      Int r;
 
      /* This is a kludge.  Really we ought to back-convert saved_act
@@ -845,6 +855,14 @@ Bool VG_(machine_get_hwcaps)( void )
         __asm__ __volatile__(".long 0xFC000034"); /*frsqrte 0,0*/
      }
 
+     /* VSX support implies Power ISA 2.06 */
+     have_VX = True;
+     if (VG_MINIMAL_SETJMP(env_unsup_insn)) {
+        have_VX = False;
+     } else {
+        __asm__ __volatile__(".long 0xf0000564"); /* xsabsdp XT,XB */
+     }
+
      /* determine dcbz/dcbzl sizes while we still have the signal
       * handlers registered */
      find_ppc_dcbz_sz(&vai);
@@ -852,8 +870,9 @@ Bool VG_(machine_get_hwcaps)( void )
      VG_(sigaction)(VKI_SIGILL, &saved_sigill_act, NULL);
      VG_(sigaction)(VKI_SIGFPE, &saved_sigfpe_act, NULL);
      VG_(sigprocmask)(VKI_SIG_SETMASK, &saved_set, NULL);
-     VG_(debugLog)(1, "machine", "F %d V %d FX %d GX %d\n", 
-                    (Int)have_F, (Int)have_V, (Int)have_FX, (Int)have_GX);
+     VG_(debugLog)(1, "machine", "F %d V %d FX %d GX %d VX %d\n", 
+                    (Int)have_F, (Int)have_V, (Int)have_FX,
+                    (Int)have_GX, (Int)have_VX);
      /* on ppc64, if we don't even have FP, just give up. */
      if (!have_F)
         return False;
@@ -866,6 +885,7 @@ Bool VG_(machine_get_hwcaps)( void )
      if (have_V)  vai.hwcaps |= VEX_HWCAPS_PPC64_V;
      if (have_FX) vai.hwcaps |= VEX_HWCAPS_PPC64_FX;
      if (have_GX) vai.hwcaps |= VEX_HWCAPS_PPC64_GX;
+     if (have_VX) vai.hwcaps |= VEX_HWCAPS_PPC64_VX;
 
      /* But we're not done yet: VG_(machine_ppc64_set_clszB) must be
         called before we're ready to go. */
--- valgrind-3.6.0/coregrind/m_coredump/coredump-elf.c	(revision 11696)
+++ valgrind-3.6.0/coregrind/m_coredump/coredump-elf.c	(revision 11700)
@@ -410,8 +410,9 @@ static void fill_fpu(const ThreadState *
 
 #elif defined(VGP_ppc32_linux)
    /* The guest state has the FPR fields declared as ULongs, so need
-      to fish out the values without converting them. */
-#  define DO(n)  (*fpu)[n] = *(double*)(&arch->vex.guest_FPR##n)
+      to fish out the values without converting them.
+      NOTE: The 32 FP registers map to the first 32 VSX registers.*/
+#  define DO(n)  (*fpu)[n] = *(double*)(&arch->vex.guest_VSR##n)
    DO(0);  DO(1);  DO(2);  DO(3);  DO(4);  DO(5);  DO(6);  DO(7);
    DO(8);  DO(9);  DO(10); DO(11); DO(12); DO(13); DO(14); DO(15);
    DO(16); DO(17); DO(18); DO(19); DO(20); DO(21); DO(22); DO(23);
@@ -420,8 +421,9 @@ static void fill_fpu(const ThreadState *
 
 #elif defined(VGP_ppc64_linux)
    /* The guest state has the FPR fields declared as ULongs, so need
-      to fish out the values without converting them. */
-#  define DO(n)  (*fpu)[n] = *(double*)(&arch->vex.guest_FPR##n)
+      to fish out the values without converting them.
+      NOTE: The 32 FP registers map to the first 32 VSX registers.*/
+#  define DO(n)  (*fpu)[n] = *(double*)(&arch->vex.guest_VSR##n)
    DO(0);  DO(1);  DO(2);  DO(3);  DO(4);  DO(5);  DO(6);  DO(7);
    DO(8);  DO(9);  DO(10); DO(11); DO(12); DO(13); DO(14); DO(15);
    DO(16); DO(17); DO(18); DO(19); DO(20); DO(21); DO(22); DO(23);
--- valgrind-3.6.0/coregrind/m_scheduler/scheduler.c	(revision 11696)
+++ valgrind-3.6.0/coregrind/m_scheduler/scheduler.c	(revision 11700)
@@ -658,13 +658,13 @@ static void do_pre_run_checks ( ThreadSt
 #  if defined(VGA_ppc32) || defined(VGA_ppc64)
    /* ppc guest_state vector regs must be 16 byte aligned for
       loads/stores.  This is important! */
-   vg_assert(VG_IS_16_ALIGNED(& tst->arch.vex.guest_VR0));
-   vg_assert(VG_IS_16_ALIGNED(& tst->arch.vex_shadow1.guest_VR0));
-   vg_assert(VG_IS_16_ALIGNED(& tst->arch.vex_shadow2.guest_VR0));
+   vg_assert(VG_IS_16_ALIGNED(& tst->arch.vex.guest_VSR0));
+   vg_assert(VG_IS_16_ALIGNED(& tst->arch.vex_shadow1.guest_VSR0));
+   vg_assert(VG_IS_16_ALIGNED(& tst->arch.vex_shadow2.guest_VSR0));
    /* be extra paranoid .. */
-   vg_assert(VG_IS_16_ALIGNED(& tst->arch.vex.guest_VR1));
-   vg_assert(VG_IS_16_ALIGNED(& tst->arch.vex_shadow1.guest_VR1));
-   vg_assert(VG_IS_16_ALIGNED(& tst->arch.vex_shadow2.guest_VR1));
+   vg_assert(VG_IS_16_ALIGNED(& tst->arch.vex.guest_VSR1));
+   vg_assert(VG_IS_16_ALIGNED(& tst->arch.vex_shadow1.guest_VSR1));
+   vg_assert(VG_IS_16_ALIGNED(& tst->arch.vex_shadow2.guest_VSR1));
 #  endif
 
 #  if defined(VGA_arm)
--- valgrind-3.6.0/coregrind/m_dispatch/dispatch-ppc64-linux.S	(revision 11696)
+++ valgrind-3.6.0/coregrind/m_dispatch/dispatch-ppc64-linux.S	(revision 11700)
@@ -310,7 +310,7 @@ VG_(run_innerloop__dispatch_unprofiled):
 	/* start over */
 	b	.VG_(run_innerloop__dispatch_unprofiled)
 	/*NOTREACHED*/
-        .size VG_(run_innerloop), .-VG_(run_innerloop)
+        .size .VG_(run_innerloop), .-.VG_(run_innerloop)
 
 
 /*----------------------------------------------------*/
@@ -385,7 +385,7 @@ VG_(run_innerloop__dispatch_profiled):
 	/* start over */
 	b	.VG_(run_innerloop__dispatch_profiled)
 	/*NOTREACHED*/
-        .size VG_(run_a_noredir_translation), .-VG_(run_a_noredir_translation)
+        .size .VG_(run_a_noredir_translation), .-.VG_(run_a_noredir_translation)
 
 
 /*----------------------------------------------------*/
--- valgrind-3.6.0/VEX/priv/guest_ppc_helpers.c	(revision 2126)
+++ valgrind-3.6.0/VEX/priv/guest_ppc_helpers.c	(revision 2127)
@@ -385,74 +385,74 @@ void LibVEX_GuestPPC32_initialise ( /*OU
    vex_state->guest_GPR30 = 0;
    vex_state->guest_GPR31 = 0;
 
-   vex_state->guest_FPR0  = 0;
-   vex_state->guest_FPR1  = 0;
-   vex_state->guest_FPR2  = 0;
-   vex_state->guest_FPR3  = 0;
-   vex_state->guest_FPR4  = 0;
-   vex_state->guest_FPR5  = 0;
-   vex_state->guest_FPR6  = 0;
-   vex_state->guest_FPR7  = 0;
-   vex_state->guest_FPR8  = 0;
-   vex_state->guest_FPR9  = 0;
-   vex_state->guest_FPR10 = 0;
-   vex_state->guest_FPR11 = 0;
-   vex_state->guest_FPR12 = 0;
-   vex_state->guest_FPR13 = 0;
-   vex_state->guest_FPR14 = 0;
-   vex_state->guest_FPR15 = 0;
-   vex_state->guest_FPR16 = 0;
-   vex_state->guest_FPR17 = 0;
-   vex_state->guest_FPR18 = 0;
-   vex_state->guest_FPR19 = 0;
-   vex_state->guest_FPR20 = 0;
-   vex_state->guest_FPR21 = 0;
-   vex_state->guest_FPR22 = 0;
-   vex_state->guest_FPR23 = 0;
-   vex_state->guest_FPR24 = 0;
-   vex_state->guest_FPR25 = 0;
-   vex_state->guest_FPR26 = 0;
-   vex_state->guest_FPR27 = 0;
-   vex_state->guest_FPR28 = 0;
-   vex_state->guest_FPR29 = 0;
-   vex_state->guest_FPR30 = 0;
-   vex_state->guest_FPR31 = 0;
 
    /* Initialise the vector state. */
 #  define VECZERO(_vr) _vr[0]=_vr[1]=_vr[2]=_vr[3] = 0;
 
-   VECZERO(vex_state->guest_VR0 );
-   VECZERO(vex_state->guest_VR1 );
-   VECZERO(vex_state->guest_VR2 );
-   VECZERO(vex_state->guest_VR3 );
-   VECZERO(vex_state->guest_VR4 );
-   VECZERO(vex_state->guest_VR5 );
-   VECZERO(vex_state->guest_VR6 );
-   VECZERO(vex_state->guest_VR7 );
-   VECZERO(vex_state->guest_VR8 );
-   VECZERO(vex_state->guest_VR9 );
-   VECZERO(vex_state->guest_VR10);
-   VECZERO(vex_state->guest_VR11);
-   VECZERO(vex_state->guest_VR12);
-   VECZERO(vex_state->guest_VR13);
-   VECZERO(vex_state->guest_VR14);
-   VECZERO(vex_state->guest_VR15);
-   VECZERO(vex_state->guest_VR16);
-   VECZERO(vex_state->guest_VR17);
-   VECZERO(vex_state->guest_VR18);
-   VECZERO(vex_state->guest_VR19);
-   VECZERO(vex_state->guest_VR20);
-   VECZERO(vex_state->guest_VR21);
-   VECZERO(vex_state->guest_VR22);
-   VECZERO(vex_state->guest_VR23);
-   VECZERO(vex_state->guest_VR24);
-   VECZERO(vex_state->guest_VR25);
-   VECZERO(vex_state->guest_VR26);
-   VECZERO(vex_state->guest_VR27);
-   VECZERO(vex_state->guest_VR28);
-   VECZERO(vex_state->guest_VR29);
-   VECZERO(vex_state->guest_VR30);
-   VECZERO(vex_state->guest_VR31);
+   VECZERO(vex_state->guest_VSR0 );
+   VECZERO(vex_state->guest_VSR1 );
+   VECZERO(vex_state->guest_VSR2 );
+   VECZERO(vex_state->guest_VSR3 );
+   VECZERO(vex_state->guest_VSR4 );
+   VECZERO(vex_state->guest_VSR5 );
+   VECZERO(vex_state->guest_VSR6 );
+   VECZERO(vex_state->guest_VSR7 );
+   VECZERO(vex_state->guest_VSR8 );
+   VECZERO(vex_state->guest_VSR9 );
+   VECZERO(vex_state->guest_VSR10);
+   VECZERO(vex_state->guest_VSR11);
+   VECZERO(vex_state->guest_VSR12);
+   VECZERO(vex_state->guest_VSR13);
+   VECZERO(vex_state->guest_VSR14);
+   VECZERO(vex_state->guest_VSR15);
+   VECZERO(vex_state->guest_VSR16);
+   VECZERO(vex_state->guest_VSR17);
+   VECZERO(vex_state->guest_VSR18);
+   VECZERO(vex_state->guest_VSR19);
+   VECZERO(vex_state->guest_VSR20);
+   VECZERO(vex_state->guest_VSR21);
+   VECZERO(vex_state->guest_VSR22);
+   VECZERO(vex_state->guest_VSR23);
+   VECZERO(vex_state->guest_VSR24);
+   VECZERO(vex_state->guest_VSR25);
+   VECZERO(vex_state->guest_VSR26);
+   VECZERO(vex_state->guest_VSR27);
+   VECZERO(vex_state->guest_VSR28);
+   VECZERO(vex_state->guest_VSR29);
+   VECZERO(vex_state->guest_VSR30);
+   VECZERO(vex_state->guest_VSR31);
+   VECZERO(vex_state->guest_VSR32);
+   VECZERO(vex_state->guest_VSR33);
+   VECZERO(vex_state->guest_VSR34);
+   VECZERO(vex_state->guest_VSR35);
+   VECZERO(vex_state->guest_VSR36);
+   VECZERO(vex_state->guest_VSR37);
+   VECZERO(vex_state->guest_VSR38);
+   VECZERO(vex_state->guest_VSR39);
+   VECZERO(vex_state->guest_VSR40);
+   VECZERO(vex_state->guest_VSR41);
+   VECZERO(vex_state->guest_VSR42);
+   VECZERO(vex_state->guest_VSR43);
+   VECZERO(vex_state->guest_VSR44);
+   VECZERO(vex_state->guest_VSR45);
+   VECZERO(vex_state->guest_VSR46);
+   VECZERO(vex_state->guest_VSR47);
+   VECZERO(vex_state->guest_VSR48);
+   VECZERO(vex_state->guest_VSR49);
+   VECZERO(vex_state->guest_VSR50);
+   VECZERO(vex_state->guest_VSR51);
+   VECZERO(vex_state->guest_VSR52);
+   VECZERO(vex_state->guest_VSR53);
+   VECZERO(vex_state->guest_VSR54);
+   VECZERO(vex_state->guest_VSR55);
+   VECZERO(vex_state->guest_VSR56);
+   VECZERO(vex_state->guest_VSR57);
+   VECZERO(vex_state->guest_VSR58);
+   VECZERO(vex_state->guest_VSR59);
+   VECZERO(vex_state->guest_VSR60);
+   VECZERO(vex_state->guest_VSR61);
+   VECZERO(vex_state->guest_VSR62);
+   VECZERO(vex_state->guest_VSR63);
 
 #  undef VECZERO
 
@@ -542,74 +542,73 @@ void LibVEX_GuestPPC64_initialise ( /*OU
    vex_state->guest_GPR30 = 0;
    vex_state->guest_GPR31 = 0;
 
-   vex_state->guest_FPR0  = 0;
-   vex_state->guest_FPR1  = 0;
-   vex_state->guest_FPR2  = 0;
-   vex_state->guest_FPR3  = 0;
-   vex_state->guest_FPR4  = 0;
-   vex_state->guest_FPR5  = 0;
-   vex_state->guest_FPR6  = 0;
-   vex_state->guest_FPR7  = 0;
-   vex_state->guest_FPR8  = 0;
-   vex_state->guest_FPR9  = 0;
-   vex_state->guest_FPR10 = 0;
-   vex_state->guest_FPR11 = 0;
-   vex_state->guest_FPR12 = 0;
-   vex_state->guest_FPR13 = 0;
-   vex_state->guest_FPR14 = 0;
-   vex_state->guest_FPR15 = 0;
-   vex_state->guest_FPR16 = 0;
-   vex_state->guest_FPR17 = 0;
-   vex_state->guest_FPR18 = 0;
-   vex_state->guest_FPR19 = 0;
-   vex_state->guest_FPR20 = 0;
-   vex_state->guest_FPR21 = 0;
-   vex_state->guest_FPR22 = 0;
-   vex_state->guest_FPR23 = 0;
-   vex_state->guest_FPR24 = 0;
-   vex_state->guest_FPR25 = 0;
-   vex_state->guest_FPR26 = 0;
-   vex_state->guest_FPR27 = 0;
-   vex_state->guest_FPR28 = 0;
-   vex_state->guest_FPR29 = 0;
-   vex_state->guest_FPR30 = 0;
-   vex_state->guest_FPR31 = 0;
-
    /* Initialise the vector state. */
 #  define VECZERO(_vr) _vr[0]=_vr[1]=_vr[2]=_vr[3] = 0;
 
-   VECZERO(vex_state->guest_VR0 );
-   VECZERO(vex_state->guest_VR1 );
-   VECZERO(vex_state->guest_VR2 );
-   VECZERO(vex_state->guest_VR3 );
-   VECZERO(vex_state->guest_VR4 );
-   VECZERO(vex_state->guest_VR5 );
-   VECZERO(vex_state->guest_VR6 );
-   VECZERO(vex_state->guest_VR7 );
-   VECZERO(vex_state->guest_VR8 );
-   VECZERO(vex_state->guest_VR9 );
-   VECZERO(vex_state->guest_VR10);
-   VECZERO(vex_state->guest_VR11);
-   VECZERO(vex_state->guest_VR12);
-   VECZERO(vex_state->guest_VR13);
-   VECZERO(vex_state->guest_VR14);
-   VECZERO(vex_state->guest_VR15);
-   VECZERO(vex_state->guest_VR16);
-   VECZERO(vex_state->guest_VR17);
-   VECZERO(vex_state->guest_VR18);
-   VECZERO(vex_state->guest_VR19);
-   VECZERO(vex_state->guest_VR20);
-   VECZERO(vex_state->guest_VR21);
-   VECZERO(vex_state->guest_VR22);
-   VECZERO(vex_state->guest_VR23);
-   VECZERO(vex_state->guest_VR24);
-   VECZERO(vex_state->guest_VR25);
-   VECZERO(vex_state->guest_VR26);
-   VECZERO(vex_state->guest_VR27);
-   VECZERO(vex_state->guest_VR28);
-   VECZERO(vex_state->guest_VR29);
-   VECZERO(vex_state->guest_VR30);
-   VECZERO(vex_state->guest_VR31);
+   VECZERO(vex_state->guest_VSR0 );
+   VECZERO(vex_state->guest_VSR1 );
+   VECZERO(vex_state->guest_VSR2 );
+   VECZERO(vex_state->guest_VSR3 );
+   VECZERO(vex_state->guest_VSR4 );
+   VECZERO(vex_state->guest_VSR5 );
+   VECZERO(vex_state->guest_VSR6 );
+   VECZERO(vex_state->guest_VSR7 );
+   VECZERO(vex_state->guest_VSR8 );
+   VECZERO(vex_state->guest_VSR9 );
+   VECZERO(vex_state->guest_VSR10);
+   VECZERO(vex_state->guest_VSR11);
+   VECZERO(vex_state->guest_VSR12);
+   VECZERO(vex_state->guest_VSR13);
+   VECZERO(vex_state->guest_VSR14);
+   VECZERO(vex_state->guest_VSR15);
+   VECZERO(vex_state->guest_VSR16);
+   VECZERO(vex_state->guest_VSR17);
+   VECZERO(vex_state->guest_VSR18);
+   VECZERO(vex_state->guest_VSR19);
+   VECZERO(vex_state->guest_VSR20);
+   VECZERO(vex_state->guest_VSR21);
+   VECZERO(vex_state->guest_VSR22);
+   VECZERO(vex_state->guest_VSR23);
+   VECZERO(vex_state->guest_VSR24);
+   VECZERO(vex_state->guest_VSR25);
+   VECZERO(vex_state->guest_VSR26);
+   VECZERO(vex_state->guest_VSR27);
+   VECZERO(vex_state->guest_VSR28);
+   VECZERO(vex_state->guest_VSR29);
+   VECZERO(vex_state->guest_VSR30);
+   VECZERO(vex_state->guest_VSR31);
+   VECZERO(vex_state->guest_VSR32);
+   VECZERO(vex_state->guest_VSR33);
+   VECZERO(vex_state->guest_VSR34);
+   VECZERO(vex_state->guest_VSR35);
+   VECZERO(vex_state->guest_VSR36);
+   VECZERO(vex_state->guest_VSR37);
+   VECZERO(vex_state->guest_VSR38);
+   VECZERO(vex_state->guest_VSR39);
+   VECZERO(vex_state->guest_VSR40);
+   VECZERO(vex_state->guest_VSR41);
+   VECZERO(vex_state->guest_VSR42);
+   VECZERO(vex_state->guest_VSR43);
+   VECZERO(vex_state->guest_VSR44);
+   VECZERO(vex_state->guest_VSR45);
+   VECZERO(vex_state->guest_VSR46);
+   VECZERO(vex_state->guest_VSR47);
+   VECZERO(vex_state->guest_VSR48);
+   VECZERO(vex_state->guest_VSR49);
+   VECZERO(vex_state->guest_VSR50);
+   VECZERO(vex_state->guest_VSR51);
+   VECZERO(vex_state->guest_VSR52);
+   VECZERO(vex_state->guest_VSR53);
+   VECZERO(vex_state->guest_VSR54);
+   VECZERO(vex_state->guest_VSR55);
+   VECZERO(vex_state->guest_VSR56);
+   VECZERO(vex_state->guest_VSR57);
+   VECZERO(vex_state->guest_VSR58);
+   VECZERO(vex_state->guest_VSR59);
+   VECZERO(vex_state->guest_VSR60);
+   VECZERO(vex_state->guest_VSR61);
+   VECZERO(vex_state->guest_VSR62);
+   VECZERO(vex_state->guest_VSR63);
 
 #  undef VECZERO
 
--- valgrind-3.6.0/VEX/priv/main_main.c	(revision 2126)
+++ valgrind-3.6.0/VEX/priv/main_main.c	(revision 2127)
@@ -855,6 +855,7 @@ static HChar* show_hwcaps_ppc32 ( UInt h
    const UInt V  = VEX_HWCAPS_PPC32_V;
    const UInt FX = VEX_HWCAPS_PPC32_FX;
    const UInt GX = VEX_HWCAPS_PPC32_GX;
+   const UInt VX = VEX_HWCAPS_PPC32_VX;
          UInt c  = hwcaps;
    if (c == 0)           return "ppc32-int";
    if (c == F)           return "ppc32-int-flt";
@@ -865,6 +866,7 @@ static HChar* show_hwcaps_ppc32 ( UInt h
    if (c == (F|V|FX))    return "ppc32-int-flt-vmx-FX";
    if (c == (F|V|GX))    return "ppc32-int-flt-vmx-GX";
    if (c == (F|V|FX|GX)) return "ppc32-int-flt-vmx-FX-GX";
+   if (c == (F|V|FX|GX|VX)) return "ppc32-int-flt-vmx-FX-GX-VX";
    return NULL;
 }
 
@@ -875,6 +877,7 @@ static HChar* show_hwcaps_ppc64 ( UInt h
    const UInt V  = VEX_HWCAPS_PPC64_V;
    const UInt FX = VEX_HWCAPS_PPC64_FX;
    const UInt GX = VEX_HWCAPS_PPC64_GX;
+   const UInt VX = VEX_HWCAPS_PPC64_VX;
          UInt c  = hwcaps;
    if (c == 0)         return "ppc64-int-flt";
    if (c == FX)        return "ppc64-int-flt-FX";
@@ -884,6 +887,7 @@ static HChar* show_hwcaps_ppc64 ( UInt h
    if (c == (V|FX))    return "ppc64-int-flt-vmx-FX";
    if (c == (V|GX))    return "ppc64-int-flt-vmx-GX";
    if (c == (V|FX|GX)) return "ppc64-int-flt-vmx-FX-GX";
+   if (c == (V|FX|GX|VX)) return "ppc64-int-flt-vmx-FX-GX-VX";
    return NULL;
 }
 
--- valgrind-3.6.0/VEX/priv/ir_defs.c	(revision 2126)	(revision 2129)
+++ valgrind-3.6.0/VEX/priv/ir_defs.c	(revision 2127)	(revision 2130)
@@ -362,6 +362,8 @@ void ppIROp ( IROp op )
       case Iop_I16StoF64: vex_printf("I16StoF64"); return;
       case Iop_I32StoF64: vex_printf("I32StoF64"); return;
       case Iop_I64StoF64: vex_printf("I64StoF64"); return;
+      case Iop_I64UtoF64: vex_printf("I64UtoF64"); return;
+      case Iop_I64UtoF32: vex_printf("I64UtoF32"); return;
 
       case Iop_I32UtoF64: vex_printf("I32UtoF64"); return;
 
@@ -2262,6 +2264,8 @@ void typeOfPrimop ( IROp op, 
       case Iop_I16StoF64: UNARY(Ity_I16, Ity_F64);
       case Iop_I32StoF64: UNARY(Ity_I32, Ity_F64);
       case Iop_I64StoF64: BINARY(ity_RMode,Ity_I64, Ity_F64);
+      case Iop_I64UtoF64: BINARY(ity_RMode,Ity_I64, Ity_F64);
+      case Iop_I64UtoF32: BINARY(ity_RMode,Ity_I64, Ity_F32);
 
       case Iop_I32UtoF64: UNARY(Ity_I32, Ity_F64);
 
--- valgrind-3.6.0/VEX/priv/host_ppc_defs.c	(revision 2126)	(revision 2147)
+++ valgrind-3.6.0/VEX/priv/host_ppc_defs.c	(revision 2127)	(revision 2148)
@@ -962,15 +962,65 @@ PPCInstr* PPCInstr_FpRSP ( HReg dst, HRe
    i->Pin.FpRSP.src = src;
    return i;
 }
-PPCInstr* PPCInstr_FpCftI ( Bool fromI, Bool int32, 
-                            HReg dst, HReg src ) {
+
+/*
+Valid combo | fromI | int32 | syned | flt64 |
+--------------------------------------------
+            |  n       n       n       n    |
+--------------------------------------------
+ F64->I64U  |  n       n       n       y    |
+--------------------------------------------
+            |  n       n       y       n    |
+--------------------------------------------
+ F64->I64S  |  n       n       y       y    |
+--------------------------------------------
+            |  n       y       n       n    |
+--------------------------------------------
+ F64->I32U  |  n       y       n       y    |
+--------------------------------------------
+            |  n       y       y       n    |
+--------------------------------------------
+ F64->I32S  |  n       y       y       y    |
+--------------------------------------------
+ I64U->F32  |  y       n       n       n    |
+--------------------------------------------
+ I64U->F64  |  y       n       n       y    |
+--------------------------------------------
+            |  y       n       y       n    |
+--------------------------------------------
+ I64S->F64  |  y       n       y       y    |
+--------------------------------------------
+            |  y       y       n       n    |
+--------------------------------------------
+            |  y       y       n       y    |
+--------------------------------------------
+            |  y       y       y       n    |
+--------------------------------------------
+            |  y       y       y       y    |
+--------------------------------------------
+*/
+PPCInstr* PPCInstr_FpCftI ( Bool fromI, Bool int32, Bool syned,
+                            Bool flt64, HReg dst, HReg src ) {
+   Bool tmp = fromI | int32 | syned | flt64;
+   vassert(tmp == True || tmp == False); // iow, no high bits set
+   UShort conversion = 0;
+   conversion = (fromI << 3) | (int32 << 2) | (syned << 1) | flt64;
+   switch (conversion) {
+      // Supported conversion operations
+      case 1: case 3: case 5: case 7:
+      case 8: case 9: case 11:
+         break;
+      default:
+         vpanic("PPCInstr_FpCftI(ppc_host)");
+   }
    PPCInstr* i         = LibVEX_Alloc(sizeof(PPCInstr));
    i->tag              = Pin_FpCftI;
    i->Pin.FpCftI.fromI = fromI;
    i->Pin.FpCftI.int32 = int32;
+   i->Pin.FpCftI.syned = syned;
+   i->Pin.FpCftI.flt64 = flt64;
    i->Pin.FpCftI.dst   = dst;
    i->Pin.FpCftI.src   = src;
-   vassert(!(int32 && fromI)); /* no such insn ("fcfiw"). */
    return i;
 }
 PPCInstr* PPCInstr_FpCMov ( PPCCondCode cond, HReg dst, HReg src ) {
@@ -1433,15 +1483,21 @@ void ppPPCInstr ( PPCInstr* i, Bool mode
       ppHRegPPC(i->Pin.FpRSP.src);
       return;
    case Pin_FpCftI: {
-      HChar* str = "fc???";
+      HChar* str = "fc?????";
       if (i->Pin.FpCftI.fromI == False && i->Pin.FpCftI.int32 == False)
          str = "fctid";
       else
       if (i->Pin.FpCftI.fromI == False && i->Pin.FpCftI.int32 == True)
          str = "fctiw";
       else
-      if (i->Pin.FpCftI.fromI == True && i->Pin.FpCftI.int32 == False)
-         str = "fcfid";
+      if (i->Pin.FpCftI.fromI == True && i->Pin.FpCftI.int32 == False) {
+         if (i->Pin.FpCftI.syned == True)
+            str = "fcfid";
+         else if (i->Pin.FpCftI.flt64 == True)
+            str = "fcfidu";
+         else
+            str = "fcfidus";
+      }
       vex_printf("%s ", str);
       ppHRegPPC(i->Pin.FpCftI.dst);
       vex_printf(",");
@@ -3385,9 +3441,19 @@ Int emit_PPCInstr ( UChar* buf, Int nbuf
          goto done;
       }
       if (i->Pin.FpCftI.fromI == True && i->Pin.FpCftI.int32 == False) {
-         // fcfid (conv i64 to f64), PPC64 p434
-         p = mkFormX(p, 63, fr_dst, 0, fr_src, 846, 0);
-         goto done;
+         if (i->Pin.FpCftI.syned == True) {
+            // fcfid (conv i64 to f64), PPC64 p434
+            p = mkFormX(p, 63, fr_dst, 0, fr_src, 846, 0);
+            goto done;
+         } else if (i->Pin.FpCftI.flt64 == True) {
+            // fcfidu (conv u64 to f64)
+            p = mkFormX(p, 63, fr_dst, 0, fr_src, 974, 0);
+            goto done;
+         } else {
+            // fcfidus (conv u64 to f32)
+            p = mkFormX(p, 59, fr_dst, 0, fr_src, 974, 0);
+            goto done;
+         }
       }
       goto bad;
    }
--- valgrind-3.6.0/VEX/priv/host_ppc_defs.h	(revision 2126)	(revision 2147)
+++ valgrind-3.6.0/VEX/priv/host_ppc_defs.h	(revision 2127)	(revision 2148)
@@ -461,7 +461,7 @@ typedef
       Pin_FpLdSt,     /* FP load/store */
       Pin_FpSTFIW,    /* stfiwx */
       Pin_FpRSP,      /* FP round IEEE754 double to IEEE754 single */
-      Pin_FpCftI,     /* fcfid/fctid/fctiw */
+      Pin_FpCftI,     /* fcfid[u,s,us]/fctid[u]/fctiw[u] */
       Pin_FpCMov,     /* FP floating point conditional move */
       Pin_FpLdFPSCR,  /* mtfsf */
       Pin_FpCmp,      /* FP compare, generating value into int reg */
@@ -662,11 +662,15 @@ typedef
             HReg src;
             HReg dst;
          } FpRSP;
-         /* fcfid/fctid/fctiw.  Note there's no fcfiw so fromI==True
-            && int32==True is not allowed. */
+         /* fcfid[u,s,us]/fctid[u]/fctiw[u].  Only some combinations
+            of the various fields are allowed.  This is asserted for
+            and documented in the code for the constructor,
+            PPCInstr_FpCftI, in host_ppc_defs.c.  */
          struct {
-            Bool fromI; /* False==F->I, True==I->F */
-            Bool int32; /* True== I is 32, False==I is 64 */
+            Bool fromI; /* True== I->F,    False== F->I */
+            Bool int32; /* True== I is 32, False== I is 64 */
+            Bool syned;
+            Bool flt64; /* True== F is 64, False== F is 32 */
             HReg src;
             HReg dst;
          } FpCftI;
@@ -811,8 +815,8 @@ extern PPCInstr* PPCInstr_FpMulAcc   ( P
 extern PPCInstr* PPCInstr_FpLdSt     ( Bool isLoad, UChar sz, HReg, PPCAMode* );
 extern PPCInstr* PPCInstr_FpSTFIW    ( HReg addr, HReg data );
 extern PPCInstr* PPCInstr_FpRSP      ( HReg dst, HReg src );
-extern PPCInstr* PPCInstr_FpCftI     ( Bool fromI, Bool int32, 
-                                       HReg dst, HReg src );
+extern PPCInstr* PPCInstr_FpCftI     ( Bool fromI, Bool int32, Bool syned,
+                                       Bool dst64, HReg dst, HReg src );
 extern PPCInstr* PPCInstr_FpCMov     ( PPCCondCode, HReg dst, HReg src );
 extern PPCInstr* PPCInstr_FpLdFPSCR  ( HReg src );
 extern PPCInstr* PPCInstr_FpCmp      ( HReg dst, HReg srcL, HReg srcR );
--- valgrind-3.6.0/VEX/priv/guest_ppc_toIR.c	(revision 2126)	(revision 2129)
+++ valgrind-3.6.0/VEX/priv/guest_ppc_toIR.c	(revision 2127)	(revision 2130)
@@ -1,4 +1,5 @@
 
+
 /*--------------------------------------------------------------------*/
 /*--- begin                                       guest_ppc_toIR.c ---*/
 /*--------------------------------------------------------------------*/
@@ -257,22 +258,52 @@ static UChar ifieldRegDS( UInt instr ) {
    return toUChar( IFIELD( instr, 21, 5 ) );
 }
 
+/* Extract XT (destination register) field, instr[0,25:21] */
+static UChar ifieldRegXT ( UInt instr )
+{
+  UChar upper_bit = toUChar (IFIELD (instr, 0, 1));
+  UChar lower_bits = toUChar (IFIELD (instr, 21, 5));
+  return (upper_bit << 5) | lower_bits;
+}
+
+/* Extract XS (store source register) field, instr[0,25:21] */
+static inline UChar ifieldRegXS ( UInt instr )
+{
+  return ifieldRegXT ( instr );
+}
+
 /* Extract RA (1st source register) field, instr[20:16] */
 static UChar ifieldRegA ( UInt instr ) {
    return toUChar( IFIELD( instr, 16, 5 ) );
 }
 
+/* Extract XA (1st source register) field, instr[2,20:16] */
+static UChar ifieldRegXA ( UInt instr )
+{
+  UChar upper_bit = toUChar (IFIELD (instr, 2, 1));
+  UChar lower_bits = toUChar (IFIELD (instr, 16, 5));
+  return (upper_bit << 5) | lower_bits;
+}
+
 /* Extract RB (2nd source register) field, instr[15:11] */
 static UChar ifieldRegB ( UInt instr ) {
    return toUChar( IFIELD( instr, 11, 5 ) );
 }
 
+/* Extract XB (2nd source register) field, instr[1,15:11] */
+static UChar ifieldRegXB ( UInt instr )
+{
+  UChar upper_bit = toUChar (IFIELD (instr, 1, 1));
+  UChar lower_bits = toUChar (IFIELD (instr, 11, 5));
+  return (upper_bit << 5) | lower_bits;
+}
+
 /* Extract RC (3rd source register) field, instr[10:6] */
 static UChar ifieldRegC ( UInt instr ) {
    return toUChar( IFIELD( instr, 6, 5 ) );
 }
 
-/* Extract 2nd lowest bit, instr[1] */
+/* Extract bit 10, instr[10] */
 static UChar ifieldBIT10 ( UInt instr ) {
    return toUChar( IFIELD( instr, 10, 1 ) );
 }
@@ -297,6 +328,16 @@ static UInt ifieldUIMM26 ( UInt instr ) 
    return instr & 0x3FFFFFF;
 }
 
+/* Extract DM field, instr[9:8] */
+static UChar ifieldDM ( UInt instr ) {
+   return toUChar( IFIELD( instr, 8, 2 ) );
+}
+
+/* Extract SHW field, instr[9:8] */
+static inline UChar ifieldSHW ( UInt instr )
+{
+  return ifieldDM ( instr );
+}
 
 /*------------------------------------------------------------*/
 /*--- Guest-state identifiers                              ---*/
@@ -506,6 +547,12 @@ static IRExpr* mkU64 ( ULong i )
    return IRExpr_Const(IRConst_U64(i));
 }
 
+static IRExpr* mkV128 ( UShort i )
+{
+   vassert(i == 0 || i == 0xffff);
+   return IRExpr_Const(IRConst_V128(i));
+}
+
 /* This generates a normal (non load-linked) load. */
 static IRExpr* loadBE ( IRType ty, IRExpr* addr )
 {
@@ -932,43 +979,44 @@ static void putIReg ( UInt archreg, IREx
 }
 
 
+/* Floating point egisters are mapped to VSX registers[0..31]. */
 static Int floatGuestRegOffset ( UInt archreg )
 {
    vassert(archreg < 32);
    
    switch (archreg) {
-   case  0: return offsetofPPCGuestState(guest_FPR0);
-   case  1: return offsetofPPCGuestState(guest_FPR1);
-   case  2: return offsetofPPCGuestState(guest_FPR2);
-   case  3: return offsetofPPCGuestState(guest_FPR3);
-   case  4: return offsetofPPCGuestState(guest_FPR4);
-   case  5: return offsetofPPCGuestState(guest_FPR5);
-   case  6: return offsetofPPCGuestState(guest_FPR6);
-   case  7: return offsetofPPCGuestState(guest_FPR7);
-   case  8: return offsetofPPCGuestState(guest_FPR8);
-   case  9: return offsetofPPCGuestState(guest_FPR9);
-   case 10: return offsetofPPCGuestState(guest_FPR10);
-   case 11: return offsetofPPCGuestState(guest_FPR11);
-   case 12: return offsetofPPCGuestState(guest_FPR12);
-   case 13: return offsetofPPCGuestState(guest_FPR13);
-   case 14: return offsetofPPCGuestState(guest_FPR14);
-   case 15: return offsetofPPCGuestState(guest_FPR15);
-   case 16: return offsetofPPCGuestState(guest_FPR16);
-   case 17: return offsetofPPCGuestState(guest_FPR17);
-   case 18: return offsetofPPCGuestState(guest_FPR18);
-   case 19: return offsetofPPCGuestState(guest_FPR19);
-   case 20: return offsetofPPCGuestState(guest_FPR20);
-   case 21: return offsetofPPCGuestState(guest_FPR21);
-   case 22: return offsetofPPCGuestState(guest_FPR22);
-   case 23: return offsetofPPCGuestState(guest_FPR23);
-   case 24: return offsetofPPCGuestState(guest_FPR24);
-   case 25: return offsetofPPCGuestState(guest_FPR25);
-   case 26: return offsetofPPCGuestState(guest_FPR26);
-   case 27: return offsetofPPCGuestState(guest_FPR27);
-   case 28: return offsetofPPCGuestState(guest_FPR28);
-   case 29: return offsetofPPCGuestState(guest_FPR29);
-   case 30: return offsetofPPCGuestState(guest_FPR30);
-   case 31: return offsetofPPCGuestState(guest_FPR31);
+   case  0: return offsetofPPCGuestState(guest_VSR0);
+   case  1: return offsetofPPCGuestState(guest_VSR1);
+   case  2: return offsetofPPCGuestState(guest_VSR2);
+   case  3: return offsetofPPCGuestState(guest_VSR3);
+   case  4: return offsetofPPCGuestState(guest_VSR4);
+   case  5: return offsetofPPCGuestState(guest_VSR5);
+   case  6: return offsetofPPCGuestState(guest_VSR6);
+   case  7: return offsetofPPCGuestState(guest_VSR7);
+   case  8: return offsetofPPCGuestState(guest_VSR8);
+   case  9: return offsetofPPCGuestState(guest_VSR9);
+   case 10: return offsetofPPCGuestState(guest_VSR10);
+   case 11: return offsetofPPCGuestState(guest_VSR11);
+   case 12: return offsetofPPCGuestState(guest_VSR12);
+   case 13: return offsetofPPCGuestState(guest_VSR13);
+   case 14: return offsetofPPCGuestState(guest_VSR14);
+   case 15: return offsetofPPCGuestState(guest_VSR15);
+   case 16: return offsetofPPCGuestState(guest_VSR16);
+   case 17: return offsetofPPCGuestState(guest_VSR17);
+   case 18: return offsetofPPCGuestState(guest_VSR18);
+   case 19: return offsetofPPCGuestState(guest_VSR19);
+   case 20: return offsetofPPCGuestState(guest_VSR20);
+   case 21: return offsetofPPCGuestState(guest_VSR21);
+   case 22: return offsetofPPCGuestState(guest_VSR22);
+   case 23: return offsetofPPCGuestState(guest_VSR23);
+   case 24: return offsetofPPCGuestState(guest_VSR24);
+   case 25: return offsetofPPCGuestState(guest_VSR25);
+   case 26: return offsetofPPCGuestState(guest_VSR26);
+   case 27: return offsetofPPCGuestState(guest_VSR27);
+   case 28: return offsetofPPCGuestState(guest_VSR28);
+   case 29: return offsetofPPCGuestState(guest_VSR29);
+   case 30: return offsetofPPCGuestState(guest_VSR30);
+   case 31: return offsetofPPCGuestState(guest_VSR31);
    default: break;
    }
    vpanic("floatGuestRegOffset(ppc)"); /*notreached*/
@@ -988,44 +1036,117 @@ static void putFReg ( UInt archreg, IREx
    stmt( IRStmt_Put(floatGuestRegOffset(archreg), e) );
 }
 
+static Int vsxGuestRegOffset ( UInt archreg )
+{
+   vassert(archreg < 64);
+   switch (archreg) {
+   case  0: return offsetofPPCGuestState(guest_VSR0);
+   case  1: return offsetofPPCGuestState(guest_VSR1);
+   case  2: return offsetofPPCGuestState(guest_VSR2);
+   case  3: return offsetofPPCGuestState(guest_VSR3);
+   case  4: return offsetofPPCGuestState(guest_VSR4);
+   case  5: return offsetofPPCGuestState(guest_VSR5);
+   case  6: return offsetofPPCGuestState(guest_VSR6);
+   case  7: return offsetofPPCGuestState(guest_VSR7);
+   case  8: return offsetofPPCGuestState(guest_VSR8);
+   case  9: return offsetofPPCGuestState(guest_VSR9);
+   case 10: return offsetofPPCGuestState(guest_VSR10);
+   case 11: return offsetofPPCGuestState(guest_VSR11);
+   case 12: return offsetofPPCGuestState(guest_VSR12);
+   case 13: return offsetofPPCGuestState(guest_VSR13);
+   case 14: return offsetofPPCGuestState(guest_VSR14);
+   case 15: return offsetofPPCGuestState(guest_VSR15);
+   case 16: return offsetofPPCGuestState(guest_VSR16);
+   case 17: return offsetofPPCGuestState(guest_VSR17);
+   case 18: return offsetofPPCGuestState(guest_VSR18);
+   case 19: return offsetofPPCGuestState(guest_VSR19);
+   case 20: return offsetofPPCGuestState(guest_VSR20);
+   case 21: return offsetofPPCGuestState(guest_VSR21);
+   case 22: return offsetofPPCGuestState(guest_VSR22);
+   case 23: return offsetofPPCGuestState(guest_VSR23);
+   case 24: return offsetofPPCGuestState(guest_VSR24);
+   case 25: return offsetofPPCGuestState(guest_VSR25);
+   case 26: return offsetofPPCGuestState(guest_VSR26);
+   case 27: return offsetofPPCGuestState(guest_VSR27);
+   case 28: return offsetofPPCGuestState(guest_VSR28);
+   case 29: return offsetofPPCGuestState(guest_VSR29);
+   case 30: return offsetofPPCGuestState(guest_VSR30);
+   case 31: return offsetofPPCGuestState(guest_VSR31);
+   case 32: return offsetofPPCGuestState(guest_VSR32);
+   case 33: return offsetofPPCGuestState(guest_VSR33);
+   case 34: return offsetofPPCGuestState(guest_VSR34);
+   case 35: return offsetofPPCGuestState(guest_VSR35);
+   case 36: return offsetofPPCGuestState(guest_VSR36);
+   case 37: return offsetofPPCGuestState(guest_VSR37);
+   case 38: return offsetofPPCGuestState(guest_VSR38);
+   case 39: return offsetofPPCGuestState(guest_VSR39);
+   case 40: return offsetofPPCGuestState(guest_VSR40);
+   case 41: return offsetofPPCGuestState(guest_VSR41);
+   case 42: return offsetofPPCGuestState(guest_VSR42);
+   case 43: return offsetofPPCGuestState(guest_VSR43);
+   case 44: return offsetofPPCGuestState(guest_VSR44);
+   case 45: return offsetofPPCGuestState(guest_VSR45);
+   case 46: return offsetofPPCGuestState(guest_VSR46);
+   case 47: return offsetofPPCGuestState(guest_VSR47);
+   case 48: return offsetofPPCGuestState(guest_VSR48);
+   case 49: return offsetofPPCGuestState(guest_VSR49);
+   case 50: return offsetofPPCGuestState(guest_VSR50);
+   case 51: return offsetofPPCGuestState(guest_VSR51);
+   case 52: return offsetofPPCGuestState(guest_VSR52);
+   case 53: return offsetofPPCGuestState(guest_VSR53);
+   case 54: return offsetofPPCGuestState(guest_VSR54);
+   case 55: return offsetofPPCGuestState(guest_VSR55);
+   case 56: return offsetofPPCGuestState(guest_VSR56);
+   case 57: return offsetofPPCGuestState(guest_VSR57);
+   case 58: return offsetofPPCGuestState(guest_VSR58);
+   case 59: return offsetofPPCGuestState(guest_VSR59);
+   case 60: return offsetofPPCGuestState(guest_VSR60);
+   case 61: return offsetofPPCGuestState(guest_VSR61);
+   case 62: return offsetofPPCGuestState(guest_VSR62);
+   case 63: return offsetofPPCGuestState(guest_VSR63);
+   default: break;
+   }
+   vpanic("vsxGuestRegOffset(ppc)"); /*notreached*/
+}
 
+/* Vector registers are mapped to VSX registers[32..63]. */
 static Int vectorGuestRegOffset ( UInt archreg )
 {
    vassert(archreg < 32);
    
    switch (archreg) {
-   case  0: return offsetofPPCGuestState(guest_VR0);
-   case  1: return offsetofPPCGuestState(guest_VR1);
-   case  2: return offsetofPPCGuestState(guest_VR2);
-   case  3: return offsetofPPCGuestState(guest_VR3);
-   case  4: return offsetofPPCGuestState(guest_VR4);
-   case  5: return offsetofPPCGuestState(guest_VR5);
-   case  6: return offsetofPPCGuestState(guest_VR6);
-   case  7: return offsetofPPCGuestState(guest_VR7);
-   case  8: return offsetofPPCGuestState(guest_VR8);
-   case  9: return offsetofPPCGuestState(guest_VR9);
-   case 10: return offsetofPPCGuestState(guest_VR10);
-   case 11: return offsetofPPCGuestState(guest_VR11);
-   case 12: return offsetofPPCGuestState(guest_VR12);
-   case 13: return offsetofPPCGuestState(guest_VR13);
-   case 14: return offsetofPPCGuestState(guest_VR14);
-   case 15: return offsetofPPCGuestState(guest_VR15);
-   case 16: return offsetofPPCGuestState(guest_VR16);
-   case 17: return offsetofPPCGuestState(guest_VR17);
-   case 18: return offsetofPPCGuestState(guest_VR18);
-   case 19: return offsetofPPCGuestState(guest_VR19);
-   case 20: return offsetofPPCGuestState(guest_VR20);
-   case 21: return offsetofPPCGuestState(guest_VR21);
-   case 22: return offsetofPPCGuestState(guest_VR22);
-   case 23: return offsetofPPCGuestState(guest_VR23);
-   case 24: return offsetofPPCGuestState(guest_VR24);
-   case 25: return offsetofPPCGuestState(guest_VR25);
-   case 26: return offsetofPPCGuestState(guest_VR26);
-   case 27: return offsetofPPCGuestState(guest_VR27);
-   case 28: return offsetofPPCGuestState(guest_VR28);
-   case 29: return offsetofPPCGuestState(guest_VR29);
-   case 30: return offsetofPPCGuestState(guest_VR30);
-   case 31: return offsetofPPCGuestState(guest_VR31);
+   case  0: return offsetofPPCGuestState(guest_VSR32);
+   case  1: return offsetofPPCGuestState(guest_VSR33);
+   case  2: return offsetofPPCGuestState(guest_VSR34);
+   case  3: return offsetofPPCGuestState(guest_VSR35);
+   case  4: return offsetofPPCGuestState(guest_VSR36);
+   case  5: return offsetofPPCGuestState(guest_VSR37);
+   case  6: return offsetofPPCGuestState(guest_VSR38);
+   case  7: return offsetofPPCGuestState(guest_VSR39);
+   case  8: return offsetofPPCGuestState(guest_VSR40);
+   case  9: return offsetofPPCGuestState(guest_VSR41);
+   case 10: return offsetofPPCGuestState(guest_VSR42);
+   case 11: return offsetofPPCGuestState(guest_VSR43);
+   case 12: return offsetofPPCGuestState(guest_VSR44);
+   case 13: return offsetofPPCGuestState(guest_VSR45);
+   case 14: return offsetofPPCGuestState(guest_VSR46);
+   case 15: return offsetofPPCGuestState(guest_VSR47);
+   case 16: return offsetofPPCGuestState(guest_VSR48);
+   case 17: return offsetofPPCGuestState(guest_VSR49);
+   case 18: return offsetofPPCGuestState(guest_VSR50);
+   case 19: return offsetofPPCGuestState(guest_VSR51);
+   case 20: return offsetofPPCGuestState(guest_VSR52);
+   case 21: return offsetofPPCGuestState(guest_VSR53);
+   case 22: return offsetofPPCGuestState(guest_VSR54);
+   case 23: return offsetofPPCGuestState(guest_VSR55);
+   case 24: return offsetofPPCGuestState(guest_VSR56);
+   case 25: return offsetofPPCGuestState(guest_VSR57);
+   case 26: return offsetofPPCGuestState(guest_VSR58);
+   case 27: return offsetofPPCGuestState(guest_VSR59);
+   case 28: return offsetofPPCGuestState(guest_VSR60);
+   case 29: return offsetofPPCGuestState(guest_VSR61);
+   case 30: return offsetofPPCGuestState(guest_VSR62);
+   case 31: return offsetofPPCGuestState(guest_VSR63);
    default: break;
    }
    vpanic("vextorGuestRegOffset(ppc)"); /*notreached*/
@@ -1045,6 +1166,22 @@ static void putVReg ( UInt archreg, IREx
    stmt( IRStmt_Put(vectorGuestRegOffset(archreg), e) );
 }
 
+/* Get contents of VSX guest register */
+static IRExpr* getVSReg ( UInt archreg )
+{
+   vassert(archreg < 64);
+   return IRExpr_Get( vsxGuestRegOffset(archreg), Ity_V128 );
+}
+
+/* Ditto, but write to a VSX reg instead. */
+static void putVSReg ( UInt archreg, IRExpr* e )
+{
+   vassert(archreg < 64);
+   vassert(typeOfIRExpr(irsb->tyenv, e) == Ity_V128);
+   stmt( IRStmt_Put(vsxGuestRegOffset(archreg), e) );
+}
+
+
 static Int guestCR321offset ( UInt cr )
 {
    switch (cr) {
@@ -1075,6 +1212,42 @@ static Int guestCR0offset ( UInt cr )
    }
 }
 
+/* Generate an IR sequence to do a popcount operation on the supplied
+ * IRTemp, and return an IRTemp holding the result.
+ */
+static IRTemp gen_POPCOUNT ( IRTemp src )
+{
+   Int i, shift[6];
+   IRTemp old = IRTemp_INVALID;
+   IRTemp nyu = IRTemp_INVALID;
+   IRTemp mask[6];
+
+   vassert(typeOfIRExpr(irsb->tyenv,mkexpr(src)) == Ity_I64);
+   for (i = 0; i < 6; i++) {
+      mask[i] = newTemp( Ity_I64 );
+      shift[i] = 1 << i;
+   }
+   assign( mask[0], mkU64( 0x5555555555555555ULL ) );
+   assign( mask[1], mkU64( 0x3333333333333333ULL ) );
+   assign( mask[2], mkU64( 0x0F0F0F0F0F0F0F0FULL ) );
+   assign( mask[3], mkU64( 0x00FF00FF00FF00FFULL ) );
+   assign( mask[4], mkU64( 0x0000FFFF0000FFFFULL ) );
+   assign( mask[5], mkU64( 0x00000000FFFFFFFFULL ) );
+   old = src;
+   for (i = 0; i < 6; i++) {
+      nyu = newTemp( Ity_I64 );
+      assign( nyu,
+              binop( Iop_Add64,
+                     binop( Iop_And64, mkexpr( old ), mkexpr( mask[i] ) ),
+                     binop( Iop_And64,
+                            binop( Iop_Shr64, mkexpr( old ), mkU8( shift[i] ) ),
+                            mkexpr( mask[i] ) ) ) );
+      old = nyu;
+   }
+   return nyu;
+}
+
+
 // ROTL(src32/64, rot_amt5/6)
 static IRExpr* /* :: Ity_I32/64 */ ROTL ( IRExpr* src,
                                           IRExpr* rot_amt )
@@ -2345,6 +2518,80 @@ static void putGST_field ( PPC_GST reg, 
    }
 }
 
+/*------------------------------------------------------------*/
+/* Helpers for VSX instructions that do floating point
+ * operations and need to determine if a src contains a
+ * special FP value.
+ *
+ *------------------------------------------------------------*/
+
+#define NONZERO_FRAC_MASK 0x000fffffffffffffULL
+#define FP_FRAC_PART(x) binop( Iop_And64, \
+                               mkexpr( x ), \
+                               mkU64( NONZERO_FRAC_MASK ) )
+
+// Returns exponent part of floating point as I32
+static IRExpr * fp_exp_part(IRTemp src)
+{
+   IRExpr * exp;
+   if (!mode64)
+      exp = binop( Iop_And32, binop( Iop_Shr32, unop( Iop_64HIto32,
+                                                      mkexpr( src ) ),
+                                     mkU8( 20 ) ), mkU32( 0x7ff ) );
+   else
+      exp = unop( Iop_64to32,
+                  binop( Iop_And64,
+                         binop( Iop_Shr64, mkexpr( src ), mkU8( 52 ) ),
+                         mkU64( 0x7ff ) ) );
+   return exp;
+}
+
+
+// Infinity: exp = 7ff and fraction is zero; s = 0/1
+static IRExpr * is_Inf(IRTemp src)
+{
+   IRExpr * Inf_exp, * hi32, * low32;
+   IRTemp frac_part = newTemp(Ity_I64);
+
+   assign( frac_part, FP_FRAC_PART(src) );
+   Inf_exp = binop( Iop_CmpEQ32, fp_exp_part( src ), mkU32( 0x7ff ) );
+   hi32 = unop( Iop_64HIto32, mkexpr( frac_part ) );
+   low32 = unop( Iop_64to32, mkexpr( frac_part ) );
+   return mkAND1( Inf_exp, binop( Iop_CmpEQ32, binop( Iop_Or32, low32, hi32 ),
+                                  mkU32( 0 ) ) );
+}
+
+// Zero: exp is zero and fraction is zero; s = 0/1
+static IRExpr * is_Zero(IRTemp src)
+{
+#define SIGN_MASK 0x7fffffffffffffffULL
+   IRExpr * hi32, * low32;
+   IRTemp sign_less_part = newTemp(Ity_I64);
+
+   assign( sign_less_part, binop( Iop_And64, mkexpr( src ), mkU64( SIGN_MASK ) ) );
+   hi32 = unop( Iop_64HIto32, mkexpr( sign_less_part ) );
+   low32 = unop( Iop_64to32, mkexpr( sign_less_part ) );
+   return binop( Iop_CmpEQ32, binop( Iop_Or32, low32, hi32 ),
+                              mkU32( 0 ) );
+}
+
+/*  SNAN: s = 1/0; exp = 0x7ff; fraction is nonzero, with highest bit '1'
+ *  QNAN: s = 1/0; exp = 0x7ff; fraction is nonzero, with highest bit '0'
+ *  This function returns an IRExpr value of '1' for any type of NaN.
+ */
+static IRExpr * is_NaN(IRTemp src)
+{
+   IRExpr * NaN_exp, * hi32, * low32;
+   IRTemp frac_part = newTemp(Ity_I64);
+
+   assign( frac_part, FP_FRAC_PART(src) );
+   hi32 = unop( Iop_64HIto32, mkexpr( frac_part ) );
+   low32 = unop( Iop_64to32, mkexpr( frac_part ) );
+   NaN_exp = binop( Iop_CmpEQ32, fp_exp_part( src ), mkU32( 0x7ffULL ) );
+
+   return mkAND1( NaN_exp, binop( Iop_CmpNE32, binop( Iop_Or32, low32, hi32 ),
+                                               mkU32( 0 ) ) );
+}
 
 
 /*------------------------------------------------------------*/
@@ -3264,6 +3511,13 @@ static Bool dis_int_logic ( UInt theInst
          putFReg( rS_addr, mkexpr(frA));
          return True;
       }
+      case 0x1FA: // popcntd (population count doubleword
+      {
+    	  DIP("popcntd r%u,r%u\n", rA_addr, rS_addr);
+        IRTemp result = gen_POPCOUNT(rS);
+    	  putIReg( rA_addr, mkexpr(result) );
+    	  return True;
+      }
 
       default:
          vex_printf("dis_int_logic(ppc)(opc2)\n");
@@ -5485,7 +5739,23 @@ static Bool dis_int_ldst_rev ( UInt theI
          putIReg( rD_addr, mkWidenFrom32(ty, mkexpr(w2),
                                          /* Signed */False) );
          break;
-      
+
+      case 0x214: // ldbrx (Load Doubleword Byte-Reverse Indexed)
+      {
+         IRExpr * nextAddr;
+         IRTemp w3 = newTemp( Ity_I32 );
+         IRTemp w4 = newTemp( Ity_I32 );
+         DIP("ldbrx r%u,r%u,r%u\n", rD_addr, rA_addr, rB_addr);
+         assign( w1, loadBE( Ity_I32, mkexpr( EA ) ) );
+         assign( w2, gen_byterev32( w1 ) );
+         nextAddr = binop( mkSzOp( ty, Iop_Add8 ), mkexpr( EA ),
+                           ty == Ity_I64 ? mkU64( 4 ) : mkU32( 4 ) );
+         assign( w3, loadBE( Ity_I32, nextAddr ) );
+         assign( w4, gen_byterev32( w3 ) );
+         putIReg( rD_addr, binop( Iop_32HLto64, mkexpr( w4 ), mkexpr( w2 ) ) );
+         break;
+      }
+
       case 0x396: // sthbrx (Store Half Word Byte-Reverse Indexed, PPC32 p523)
          DIP("sthbrx r%u,r%u,r%u\n", rS_addr, rA_addr, rB_addr);
          assign( w1, mkNarrowTo32(ty, getIReg(rS_addr)) );
@@ -6059,6 +6329,17 @@ static Bool dis_fp_load ( UInt theInstr 
                                  binop(Iop_32HLto64, mkexpr(iHi), mkexpr(iLo))) );
          break;
 
+      case 0x377: // lfiwzx (Load floating-point as integer word, zero indexed
+      {
+         IRTemp dw = newTemp( Ity_I64 );
+         DIP("lfiwzx fr%u,r%u,r%u\n", frD_addr, rA_addr, rB_addr);
+         assign( EA, ea_rAor0_idxd( rA_addr, rB_addr ) );
+         assign( iLo, loadBE(Ity_I32, mkexpr(EA)) );
+         assign( dw, binop( Iop_32HLto64, mkU32( 0 ), mkexpr( iLo ) ) );
+         putFReg( frD_addr, unop( Iop_ReinterpI64asF64, mkexpr( dw ) ) );
+         break;
+      }
+
       default:
          vex_printf("dis_fp_load(ppc)(opc2)\n");
          return False;
@@ -6591,7 +6872,238 @@ static Bool dis_fp_multadd ( UInt theIns
    return True;
 }
 
+/*
+ * fe_flag is set to 1 if any of the following conditions occurs:
+ *  - The double-precision floating-point operand in register FRA is a NaN or an
+ *    Infinity.
+ *  - The double-precision floating-point operand in register FRB is a Zero, a
+ *    NaN, or an Infinity.
+ *  - e_b is less than or equal to -1022.
+ *  - e_b is greater than or equal to 1021.
+ *  - The double-precision floating-point operand in register FRA is not a zero
+ *    and the difference, e_a - e_b, is greater than or equal to 1023.
+ *  - The double-precision floating-point operand in register FRA is not a zero
+ *    and the difference, e_a - e_b, is less than or equal to -1021.
+ *  - The double-precision floating-point operand in register FRA is not a zero
+ *    and e_a is less than or equal to -970
+ *  Otherwise fe_flag is set to 0.
+ *
+ * fg_flag is set to 1 if either of the following conditions occurs.
+ *   - The double-precision floating-point operand in register FRA is an Infinity.
+ *   - The double-precision floating-point operand in register FRB is a Zero, an
+ *     Infinity, or a denormalized value.
+ *  Otherwise fg_flag is set to 0.
+ *
+ */
+static Bool dis_fp_ftdiv ( UInt theInstr )
+{
+   UChar opc1     = ifieldOPC(theInstr);
+   UChar crfD     = toUChar( IFIELD( theInstr, 23, 3 ) );
+   UChar b21to22  = toUChar( IFIELD( theInstr, 21, 2 ) );
+   UChar frA_addr = ifieldRegA(theInstr);
+   UChar frB_addr = ifieldRegB(theInstr);
+   UChar b0       = ifieldBIT0(theInstr);
+
+   // The following temps are for holding intermediate results
+   IRTemp frA_I64     = newTemp(Ity_I64);
+   IRTemp frB_I64     = newTemp(Ity_I64);
+   IRTemp e_a = newTemp(Ity_I32);
+   IRTemp e_b = newTemp(Ity_I32);
+   IRTemp frA_exp_shR = newTemp(Ity_I32);
+   IRTemp frB_exp_shR = newTemp(Ity_I32);
+
+   UInt bias = 1023;
+
+   /* The following variables hold boolean results from tests
+    * that are OR'ed together for setting the fe_ and fg_ flags.
+    * For some cases, the booleans are used more than once, so
+    * I make those IRTemp's instead of IRExpr's.
+    */
+   IRExpr * fraNaN, * frbNaN, * frbDenorm;
+   IRExpr * eb_LTE, * eb_GTE, * ea_eb_GTE, * ea_eb_LTE, * ea_LTE;
+   IRTemp  fraInf_tmp = newTemp(Ity_I1);
+   IRTemp  frbZero_tmp = newTemp(Ity_I1);
+   IRTemp  frbInf_tmp = newTemp(Ity_I1);
+   IRTemp  fraNotZero_tmp = newTemp(Ity_I1);
+
+/* The following are the flags that are set by OR'ing the results of
+ * all the tests done for ftdiv.  These flags are the input to the specified CR.
+ */
+   IRExpr * fe_flag, * fl_flag, * fg_flag;
+
+
+   if (opc1 != 0x3F || b21to22 != 0 || b0 != 0) {
+      vex_printf("dis_fp_ftdiv(ppc)(instr)\n");
+      return False;
+   }
 
+   // Create temps that will be used throughout the following tests.
+   assign( frA_I64, unop( Iop_ReinterpF64asI64, getFReg( frA_addr ) ) );
+   assign( frB_I64, unop( Iop_ReinterpF64asI64, getFReg( frB_addr ) ) );
+   assign( frA_exp_shR, fp_exp_part( frA_I64 ) );
+   assign( frB_exp_shR, fp_exp_part( frB_I64 ) );
+   /* Let e_[a|b] be the unbiased exponent: i.e. exp - 1023. */
+   assign(e_a, binop( Iop_Sub32, mkexpr(frA_exp_shR), mkU32( bias ) ));
+   assign(e_b, binop( Iop_Sub32, mkexpr(frB_exp_shR), mkU32( bias ) ));
+
+
+   //////////////////  fe_flag tests BEGIN //////////////////////
+   /* We first do all tests that may result in setting fe_flag to '1'. */
+
+   /*
+    * Test if the double-precision floating-point operand in register FRA is
+    * a NaN:
+    *    exp = 7ff and fraction is non-zero; s = 0/1
+    */
+   fraNaN = is_NaN(frA_I64);
+   /*
+    * Test if the double-precision floating-point operand in register FRA is
+    * an Infinity.
+    *    exp = 7ff and fraction is zero; s = 0/1
+    */
+   assign(fraInf_tmp, is_Inf(frA_I64));
+
+   /*
+    * Test if the double-precision floating-point operand in register FRB is
+    * a NaN:
+    *    exp = 7ff and fraction is non-zero; s = 0/1
+    */
+   frbNaN = is_NaN(frB_I64);
+   /*
+    * Test if the double-precision floating-point operand in register FRB is
+    * an Infinity.
+    *    exp = 7ff and fraction is zero; s = 0/1
+    */
+   assign( frbInf_tmp, is_Inf(frB_I64) );
+   /*
+    * Test if the double-precision floating-point operand in register FRB is
+    * a Zero.
+    *    exp is zero and fraction is zero; s = 0/1
+    */
+   assign( frbZero_tmp, is_Zero(frB_I64) );
+
+   /*
+    * Test if e_b <= -1022
+    */
+   {
+      UInt test_value = 0xfffffc02;  //Int test_value = -1022;
+      eb_LTE = binop(Iop_CmpLE32S, mkexpr(e_b), mkU32(test_value));
+   }
+
+   /*
+    * Test if e_b >= 1021
+    *   ==> 1021 < e_b
+    */
+   {
+      Int test_value = 1021;
+      eb_GTE = binop(Iop_CmpLT32S, mkU32(test_value), mkexpr(e_b));
+   }
+
+   /*
+    * Test if FRA != Zero and (e_a - e_b) >= 1023
+    *   ==> FRA != Zero && (1023 < (e_a - e_b)
+    */
+   assign( fraNotZero_tmp, unop( Iop_Not1, is_Zero( frA_I64 ) ) );
+   ea_eb_GTE = mkAND1( mkexpr( fraNotZero_tmp ),
+                       binop( Iop_CmpLT32S, mkU32( bias ),
+                              binop( Iop_Sub32, mkexpr( e_a ),
+                                     mkexpr( e_b ) ) ) );
+
+   /*
+    * Test if FRA != Zero and (e_a - e_b) <= -1021
+    */
+   {
+      UInt test_value = 0xfffffc03;  //Int test_value = -1021;
+
+      ea_eb_LTE = mkAND1( mkexpr( fraNotZero_tmp ),
+                          binop( Iop_CmpLE32S,
+                                 binop( Iop_Sub32,
+                                        mkexpr( e_a ),
+                                        mkexpr( e_b ) ),
+                                        mkU32( test_value ) ) );
+   }
+
+   /*
+    * Test if FRA != Zero and e_a <= -970
+    */
+   {
+      UInt test_value = 0xfffffc36;  //Int test_value = -970;
+
+      ea_LTE = mkAND1( mkexpr( fraNotZero_tmp ), binop( Iop_CmpLE32S,
+                                                        mkexpr( e_a ),
+                                                        mkU32( test_value ) ) );
+   }
+   //////////////////  fe_flag tests END //////////////////////
+
+   //////////////////  fg_flag tests BEGIN //////////////////////
+   /*
+    * The following tests were already performed above in the fe_flag
+    * tests.  So these conditions will result in both fe_ and fg_ flags
+    * being set.
+    *   - Test if FRA is an Infinity
+    *   - Test if FRB ix Zero
+    *   - Test if FRB is an Infinity
+    */
+
+   /*
+    * Test if FRB holds a denormalized value.  A denormalized value is one where
+    * the exp is 0 and the fraction is non-zero.
+    */
+   {
+      IRExpr * hi32, * low32, * fraction_is_nonzero;
+      IRTemp frac_part = newTemp(Ity_I64);
+
+      assign( frac_part, FP_FRAC_PART(frB_I64) );
+      hi32 = unop( Iop_64HIto32, mkexpr( frac_part ) );
+      low32 = unop( Iop_64to32, mkexpr( frac_part ) );
+      fraction_is_nonzero = binop( Iop_CmpNE32, binop( Iop_Or32, low32, hi32 ),
+                                                mkU32( 0 ) );
+      frbDenorm = mkAND1( binop( Iop_CmpEQ32, mkexpr( frB_exp_shR ),
+                                 mkU32( 0x0ULL ) ), fraction_is_nonzero );
+
+   }
+   //////////////////  fg_flag tests END //////////////////////
+
+   /////////////////////////
+   /* The CR field consists of fl_flag || fg_flag || fe_flag || 0b0
+    * where fl_flag == 1 on ppc64.
+    */
+   fl_flag = unop(Iop_Not32, mkU32(0xFFFFFE));
+
+
+   fe_flag
+   = mkOR1(
+            fraNaN,
+            mkOR1(
+                   mkexpr( fraInf_tmp ),
+                   mkOR1(
+                          mkexpr( frbZero_tmp ),
+                          mkOR1(
+                                 frbNaN,
+                                 mkOR1(
+                                        mkexpr( frbInf_tmp ),
+                                        mkOR1( eb_LTE,
+                                               mkOR1( eb_GTE,
+                                                      mkOR1( ea_eb_GTE,
+                                                             mkOR1( ea_eb_LTE,
+                                                                    ea_LTE ) ) ) ) ) ) ) ) );
+
+   fe_flag = unop(Iop_1Uto32, fe_flag);
+
+   fg_flag = mkOR1( mkexpr( fraInf_tmp ), mkOR1( mkexpr( frbZero_tmp ),
+                                                 mkOR1( mkexpr( frbInf_tmp ),
+                                                        frbDenorm ) ) );
+   fg_flag = unop(Iop_1Uto32, fg_flag);
+
+   putGST_field( PPC_GST_CR, binop( Iop_Or32,
+                           binop( Iop_Or32,
+                                  binop( Iop_Shl32, fl_flag, mkU8( 3 ) ),
+                                  binop( Iop_Shl32, fg_flag, mkU8( 2 ) ) ),
+                           binop( Iop_Shl32, fe_flag, mkU8( 1 ) ) ), crfD );
+
+   DIP("ftdiv crf%d,fr%u,fr%u\n", crfD, frA_addr, frB_addr);
+   return True;
+}
 
 /*
   Floating Point Compare Instructions
@@ -6721,13 +7233,34 @@ static Bool dis_fp_round ( UInt theInstr
       simulating exceptions, the exception status will appear to be
       zero.  Hence cr1 should be cleared if this is a . form insn. */
    Bool clear_CR1 = True;
-   
-   if (opc1 != 0x3F || b16to20 != 0) {
+   if ((!(opc1 == 0x3F || opc1 == 0x3B)) || b16to20 != 0) {
       vex_printf("dis_fp_round(ppc)(instr)\n");
       return False;
    }
 
    assign( frB, getFReg(frB_addr));
+   // TODO : add support here for fcfdus
+   if (opc1 == 0x3B) {
+      /* The fcfid[u]s instructions (from ISA 2.06) are a bit odd because
+       * they're very similar to the other instructions handled here, but have
+       * a different primary opcode.
+       */
+      switch (opc2) {
+         case 0x34E: // fcfids (Float convert from signed DWord to single precision)
+            DIP("fcfids%s fr%u,fr%u\n", flag_rC ? ".":"", frD_addr, frB_addr);
+            assign( r_tmp64, unop( Iop_ReinterpF64asI64, mkexpr(frB)) );
+            assign( frD, binop( Iop_RoundF64toF32, rm, binop( Iop_I64StoF64, rm,
+                                                              mkexpr( r_tmp64 ) ) ) );
+            goto putFR;
+
+         case 0x3Ce: // fcfidus (Float convert from unsigned DWord to single precision)
+            DIP("fcfidus%s fr%u,fr%u\n", flag_rC ? ".":"", frD_addr, frB_addr);
+            assign( r_tmp64, unop( Iop_ReinterpF64asI64, mkexpr(frB)) );
+            assign( frD, unop( Iop_F32toF64, binop( Iop_I64UtoF32, rm, mkexpr( r_tmp64 ) ) ) );
+            goto putFR;
+      }
+   }
+
 
    switch (opc2) {
    case 0x00C: // frsp (Float Round to Single, PPC32 p423)
@@ -6780,6 +7313,12 @@ static Bool dis_fp_round ( UInt theInstr
               binop(Iop_I64StoF64, rm, mkexpr(r_tmp64)) );
       break;
 
+   case 0x3CE: // fcfidu (Float convert from unsigned DWord)
+      DIP("fcfidu%s fr%u,fr%u\n", flag_rC ? ".":"", frD_addr, frB_addr);
+      assign( r_tmp64, unop( Iop_ReinterpF64asI64, mkexpr(frB)) );
+      assign( frD, binop( Iop_I64UtoF64, rm, mkexpr( r_tmp64 ) ) );
+      break;
+
    case 0x188: case 0x1A8: case 0x1C8: case 0x1E8: // frin, friz, frip, frim
       switch(opc2) {
       case 0x188: // frin (Floating Round to Integer Nearest)
@@ -6830,7 +7369,7 @@ static Bool dis_fp_round ( UInt theInstr
       vex_printf("dis_fp_round(ppc)(opc2)\n");
       return False;
    }
-
+putFR:
    putFReg( frD_addr, mkexpr(frD) );
 
    if (set_FPRF) {
@@ -7271,6 +7810,722 @@ static Bool dis_av_procctl ( UInt theIns
 }
 
 /*
+ *
+ */
+static Bool
+dis_vx_conv ( UInt theInstr, UInt opc2 )
+{
+   /* XX2-Form */
+   UChar opc1 = ifieldOPC( theInstr );
+   UChar XT = ifieldRegXT( theInstr );
+   UChar XB = ifieldRegXB( theInstr );
+   IRTemp frB = newTemp(Ity_F64);
+   IRTemp r_tmp64 = newTemp(Ity_I64);
+   IRExpr* rm = get_IR_roundingmode();
+
+   if (opc1 != 0x3C) {
+      vex_printf( "dis_vx_conv(ppc)(instr)\n" );
+      return False;
+   }
+
+   assign(frB, unop(Iop_ReinterpI64asF64, unop(Iop_V128HIto64, getVSReg( XB ))));
+   /* For all the VSX convert instructions, the contents of doubleword element 1
+    * of VSX[XT] are undefined after the operation; therefore, we can simply
+    * move the entire array element where it makes sense to do so.
+    */
+
+   switch (opc2) {
+   case 0x2B0:
+      // xscvdpsxds (VSX Scalar truncate Double-Precision to integer and Convert
+      //             to Signed Integer Doubleword format with Saturate)
+      DIP("xscvdpsxds fr%u,fr%u\n",  (UInt)XT, (UInt)XB);
+      putVSReg( XT,
+                   binop( Iop_64HLtoV128, binop( Iop_F64toI64S,
+                                                 mkU32( Irrm_ZERO ),
+                                                 mkexpr( frB ) ), mkU64( 0 ) ) );
+      break;
+   case 0x2F0:
+      // xscvsxddp (VSX Scalar Convert and round Signed Integer Doubleword to
+      //            Double-Precision format)
+      DIP("xscvsxddp v%u,v%u\n",  (UInt)XT, (UInt)XB);
+
+      assign( r_tmp64, unop( Iop_ReinterpF64asI64, mkexpr(frB)) );
+      putVSReg( XT,
+                   binop( Iop_64HLtoV128, unop( Iop_ReinterpF64asI64,
+                                                binop( Iop_I64StoF64, rm,
+                                                       mkexpr( r_tmp64 ) ) ),
+                          mkU64( 0 ) ) );
+      break;
+   case 0x2D0:
+      // xscvuxddp (VSX Scalar Convert and round Unsigned Integer Doubleword to
+      //            Double-Precision format)
+      DIP("xscvuxddp v%u,v%u\n",  (UInt)XT, (UInt)XB);
+
+      assign( r_tmp64, unop( Iop_ReinterpF64asI64, mkexpr(frB)) );
+      putVSReg( XT,
+                   binop( Iop_64HLtoV128, unop( Iop_ReinterpF64asI64,
+                                                binop( Iop_I64UtoF64, rm,
+                                                       mkexpr( r_tmp64 ) ) ),
+                          mkU64( 0 ) ) );
+      break;
+
+   default:
+      vex_printf( "dis_vx_conv(ppc)(opc2)\n" );
+      return False;
+   }
+   return True;
+}
+
+/*
+ * VSX Scalar Floating Point Arithmetic Instructions
+ */
+static Bool
+dis_vx_arith ( UInt theInstr, UInt opc2 )
+{
+   /* XX3-Form */
+   UChar opc1 = ifieldOPC( theInstr );
+   UChar XT = ifieldRegXT( theInstr );
+   UChar XA = ifieldRegXA( theInstr );
+   UChar XB = ifieldRegXB( theInstr );
+   IRExpr* rm = get_IR_roundingmode();
+   IRTemp frA = newTemp(Ity_F64);
+   IRTemp frB = newTemp(Ity_F64);
+
+   if (opc1 != 0x3C) {
+      vex_printf( "dis_vx_arith(ppc)(instr)\n" );
+      return False;
+   }
+
+   assign(frA, unop(Iop_ReinterpI64asF64, unop(Iop_V128HIto64, getVSReg( XA ))));
+   assign(frB, unop(Iop_ReinterpI64asF64, unop(Iop_V128HIto64, getVSReg( XB ))));
+
+   /* For all the VSX sclar arithmetic instructions, the contents of doubleword element 1
+    * of VSX[XT] are undefined after the operation; therefore, we can simply set
+    * element to zero where it makes sense to do so.
+    */
+   switch (opc2) {
+      case 0x080: // xsadddp (VSX scalar add double-precision)
+         DIP("xsadddp v%d,v%d,v%d\n", (UInt)XT, (UInt)XA, (UInt)XB);
+         putVSReg( XT, binop( Iop_64HLtoV128, unop( Iop_ReinterpF64asI64,
+                                                    triop( Iop_AddF64, rm,
+                                                           mkexpr( frA ),
+                                                           mkexpr( frB ) ) ),
+                              mkU64( 0 ) ) );
+         break;
+      case 0x0E0: // xsdivdp (VSX scalar divide double-precision)
+         DIP("xsdivdp v%d,v%d,v%d\n", (UInt)XT, (UInt)XA, (UInt)XB);
+         putVSReg( XT, binop( Iop_64HLtoV128, unop( Iop_ReinterpF64asI64,
+                                                    triop( Iop_DivF64, rm,
+                                                           mkexpr( frA ),
+                                                           mkexpr( frB ) ) ),
+                              mkU64( 0 ) ) );
+         break;
+      case 0x084: case 0x0A4: // xsmaddadp, xsmaddmdp (VSX scalar multiply-add double-precision)
+      {
+         IRTemp frT = newTemp(Ity_F64);
+         Bool mdp = opc2 == 0x0A4;
+         DIP("xsmadd%sdp v%d,v%d,v%d\n", mdp ? "m" : "a", (UInt)XT, (UInt)XA, (UInt)XB);
+         assign( frT, unop( Iop_ReinterpI64asF64, unop( Iop_V128HIto64,
+                                                        getVSReg( XT ) ) ) );
+         putVSReg( XT, binop( Iop_64HLtoV128, unop( Iop_ReinterpF64asI64,
+                                                    qop( Iop_MAddF64, rm,
+                                                         mkexpr( frA ),
+                                                         mkexpr( mdp ? frT : frB ),
+                                                         mkexpr( mdp ? frB : frT ) ) ),
+                              mkU64( 0 ) ) );
+         break;
+      }
+      case 0x0C4: case 0x0E4: // xsmsubadp, xsmsubmdp (VSX scalar multiply-subtract double-precision)
+      {
+         IRTemp frT = newTemp(Ity_F64);
+         Bool mdp = opc2 == 0x0E4;
+         DIP("xsmsub%sdp v%d,v%d,v%d\n", mdp ? "m" : "a", (UInt)XT, (UInt)XA, (UInt)XB);
+         assign( frT, unop( Iop_ReinterpI64asF64, unop( Iop_V128HIto64,
+                                                        getVSReg( XT ) ) ) );
+         putVSReg( XT, binop( Iop_64HLtoV128, unop( Iop_ReinterpF64asI64,
+                                                    qop( Iop_MSubF64, rm,
+                                                         mkexpr( frA ),
+                                                         mkexpr( mdp ? frT : frB ),
+                                                         mkexpr( mdp ? frB : frT ) ) ),
+                              mkU64( 0 ) ) );
+         break;
+      }
+      case 0x284: case 0x2A4: // xsnmaddadp, xsnmaddmdp (VSX scalar multiply-add double-precision)
+      {
+         /* TODO: mpj -- Naturally, I expected to be able to leverage the implementation
+          * of fnmadd and use pretty much the same code. However, that code has a bug in the
+          * way it blindly negates the signbit, even if the floating point result is a NaN.
+          * So, the TODO is to fix fnmadd (which I'll do in a different patch).
+          */
+         ULong signbit_mask = 0x8000000000000000ULL;
+         Bool mdp = opc2 == 0x2A4;
+         IRTemp frT = newTemp(Ity_F64);
+         IRTemp maddResult = newTemp(Ity_I64);
+         IRTemp negatedResult = newTemp(Ity_I64);
+         IRTemp signbit_32 = newTemp(Ity_I32);
+         IRTemp resultantSignbit = newTemp(Ity_I1);
+
+         DIP("xsnmadd%sdp v%d,v%d,v%d\n", mdp ? "m" : "a", (UInt)XT, (UInt)XA, (UInt)XB);
+         assign( frT, unop( Iop_ReinterpI64asF64, unop( Iop_V128HIto64,
+                                                        getVSReg( XT ) ) ) );
+         assign( maddResult, unop( Iop_ReinterpF64asI64, qop( Iop_MAddF64, rm,
+                                                              mkexpr( frA ),
+                                                              mkexpr( mdp ? frT : frB ),
+                                                              mkexpr( mdp ? frB : frT ) ) ) );
+         assign( signbit_32, binop( Iop_Shr32,
+                                unop( Iop_64HIto32,
+                                       binop( Iop_And64, mkexpr( maddResult ),
+                                              mkU64( signbit_mask ) ) ),
+                                       mkU8( 31 ) ) );
+         /* We negate the signbit if and only if the intermediate result from the
+          * multiply-add was NOT a NaN.  This is an XNOR predicate.
+          */
+         assign( resultantSignbit,
+                 unop( Iop_Not1,
+                       binop( Iop_CmpEQ32,
+                                     binop( Iop_Xor32, mkexpr( signbit_32 ),
+                                            unop( Iop_1Uto32,
+                                                  is_NaN( maddResult ) ) ),
+                                     mkU32( 1 ) ) ) );
+
+         assign( negatedResult,
+                 binop( Iop_Or64, binop( Iop_And64, mkexpr( maddResult ),
+                                         mkU64( ~signbit_mask ) ),
+                        binop( Iop_32HLto64,
+                               binop( Iop_Shl32,
+                                      unop( Iop_1Uto32,
+                                            mkexpr( resultantSignbit ) ),
+                                      mkU8( 31 ) ), mkU32( 0 ) ) ) );
+
+         putVSReg( XT, binop( Iop_64HLtoV128, mkexpr( negatedResult ),
+                              mkU64( 0 ) ) );
+         break;
+      }
+      case 0x0C0: // xsmuldp (VSX Scalar Multiply Double-Precision)
+         DIP("xsmuldp v%d,v%d,v%d\n", (UInt)XT, (UInt)XA, (UInt)XB);
+         putVSReg( XT, binop( Iop_64HLtoV128, unop( Iop_ReinterpF64asI64,
+                                                    triop( Iop_MulF64, rm,
+                                                           mkexpr( frA ),
+                                                           mkexpr( frB ) ) ),
+                              mkU64( 0 ) ) );
+         break;
+      case 0x0A0: // xssubdp (VSX Scalar Subtract Double-Precision)
+         DIP("xssubdp v%d,v%d,v%d\n", (UInt)XT, (UInt)XA, (UInt)XB);
+         putVSReg( XT, binop( Iop_64HLtoV128, unop( Iop_ReinterpF64asI64,
+                                                    triop( Iop_SubF64, rm,
+                                                           mkexpr( frA ),
+                                                           mkexpr( frB ) ) ),
+                              mkU64( 0 ) ) );
+         break;
+
+      default:
+         vex_printf( "dis_vx_arith(ppc)(opc2)\n" );
+         return False;
+   }
+   return True;
+}
+
+/*
+ * VSX Floating Point Compare Instructions
+ */
+static Bool
+dis_vx_cmp( UInt theInstr, UInt opc2 )
+{
+   /* XX3-Form and XX2-Form */
+   UChar opc1 = ifieldOPC( theInstr );
+   UChar crfD     = toUChar( IFIELD( theInstr, 23, 3 ) );
+   IRTemp ccPPC32 = newTemp(Ity_I32);
+   IRTemp ccIR    = newTemp(Ity_I32);
+   UChar XA       = ifieldRegXA ( theInstr );
+   UChar XB       = ifieldRegXB ( theInstr );
+   IRTemp frA     = newTemp(Ity_F64);
+   IRTemp frB     = newTemp(Ity_F64);
+
+   if (opc1 != 0x3C) {
+      vex_printf( "dis_vx_cmp(ppc)(instr)\n" );
+      return False;
+   }
+
+   assign(frA, unop(Iop_ReinterpI64asF64, unop(Iop_V128HIto64, getVSReg( XA ))));
+   assign(frB, unop(Iop_ReinterpI64asF64, unop(Iop_V128HIto64, getVSReg( XB ))));
+   switch (opc2) {
+      case 0x08C: case 0x0AC: // xscmpudp, xscmpodp
+         /* Note: Differences between xscmpudp and xscmpodp are only in
+          * exception flag settings, which aren't supported anyway. */
+         DIP("xscmp%sdp crf%d,fr%u,fr%u\n", opc2 == 0x08c ? "u" : "o",
+                                           crfD, (UInt)XA, (UInt)XB);
+         assign( ccIR, binop(Iop_CmpF64, mkexpr(frA), mkexpr(frB)) );
+
+         /* Map compare result from IR to PPC32 */
+         /*
+           FP cmp result | PPC | IR
+           --------------------------
+           UN            | 0x1 | 0x45
+           EQ            | 0x2 | 0x40
+           GT            | 0x4 | 0x00
+           LT            | 0x8 | 0x01
+         */
+
+         // ccPPC32 = Shl(1, (~(ccIR>>5) & 2)
+         //                    | ((ccIR ^ (ccIR>>6)) & 1)
+         assign(
+            ccPPC32,
+            binop(
+               Iop_Shl32,
+               mkU32(1),
+               unop(
+                  Iop_32to8,
+                  binop(
+                     Iop_Or32,
+                     binop(
+                        Iop_And32,
+                        unop(
+                           Iop_Not32,
+                           binop(Iop_Shr32, mkexpr(ccIR), mkU8(5))
+                        ),
+                        mkU32(2)
+                     ),
+                     binop(
+                        Iop_And32,
+                        binop(
+                           Iop_Xor32,
+                           mkexpr(ccIR),
+                           binop(Iop_Shr32, mkexpr(ccIR), mkU8(6))
+                        ),
+                        mkU32(1)
+                     )
+                  )
+               )
+            )
+         );
+
+         putGST_field( PPC_GST_CR, mkexpr(ccPPC32), crfD );
+
+         break;
+      default:
+         vex_printf( "dis_vx_cmp(ppc)(opc2)\n" );
+         return False;
+   }
+   return True;
+}
+/*
+ * VSX Move Instructions
+ */
+static Bool
+dis_vx_move( UInt theInstr, UInt opc2 )
+{
+   /* XX3-Form and XX2-Form */
+   UChar opc1 = ifieldOPC( theInstr );
+   UChar XT = ifieldRegXT ( theInstr );
+   UChar XA = ifieldRegXA ( theInstr );
+   UChar XB = ifieldRegXB ( theInstr );
+   IRTemp vA = newTemp( Ity_V128 );
+   IRTemp vB = newTemp( Ity_V128 );
+
+   if (opc1 != 0x3C) {
+      vex_printf( "dis_vx_move(ppc)(instr)\n" );
+      return False;
+   }
+
+   assign( vA, getVSReg( XA ) );
+   assign( vB, getVSReg( XB ) );
+
+   /* For all the VSX move instructions, the contents of doubleword element 1
+    * of VSX[XT] are undefined after the operation; therefore, we can simply
+    * move the entire array element where it makes sense to do so.
+    */
+
+   switch (opc2) {
+      case 0x2B2: // xsabsdp (VSX scalar absolute value double-precision
+      {
+         /* Move abs val of dw 0 of VSX[XB] to dw 0 of VSX[XT]. */
+         IRTemp absVal = newTemp(Ity_V128);
+         assign(absVal, binop(Iop_ShrV128, binop(Iop_ShlV128, mkexpr(vB), mkU8(1)), mkU8(1)));
+         DIP("xsabsdp v%d,v%d\n", (UInt)XT, (UInt)XB);
+         putVSReg(XT, mkexpr(absVal));
+         break;
+      }
+      case 0x2C0: // xscpsgndp
+      {
+         /* Scalar copy sign double-precision */
+         IRTemp vecA_signbit = newTemp(Ity_V128);
+         IRTemp vecB_no_signbit = newTemp(Ity_V128);
+         IRTemp vec_result = newTemp(Ity_V128);
+         DIP("xscpsgndp v%d,v%d v%d\n", (UInt)XT, (UInt)XA, (UInt)XB);
+         assign( vecB_no_signbit, binop( Iop_ShrV128, binop( Iop_ShlV128,
+                                                             mkexpr( vB ),
+                                                             mkU8( 1 ) ),
+                                         mkU8( 1 ) ) );
+         assign( vecA_signbit, binop( Iop_ShlV128, binop( Iop_ShrV128,
+                                                          mkexpr( vA ),
+                                                          mkU8( 127 ) ),
+                                      mkU8( 127 ) ) );
+         assign( vec_result, binop( Iop_OrV128, mkexpr(vecA_signbit), mkexpr( vecB_no_signbit ) ) );
+         putVSReg(XT, mkexpr(vec_result));
+         break;
+      }
+      case 0x2D2: // xsnabsdp
+      {
+         /* Scalar negative absolute value double-precision */
+         IRTemp vec_neg_signbit = newTemp(Ity_V128);
+         DIP("xsnabsdp v%d,v%d\n", (UInt)XT, (UInt)XB);
+         assign( vec_neg_signbit, unop( Iop_NotV128, binop( Iop_ShrV128,
+                                                            mkV128( 0xffff ),
+                                                            mkU8( 1 ) ) ) );
+         putVSReg(XT, binop(Iop_OrV128, mkexpr(vec_neg_signbit), mkexpr(vB)));
+         break;
+      }
+      case 0x2F2: // xsnegdp
+      {
+         /* Scalar negate double-precision */
+         IRTemp vecB_no_signbit = newTemp(Ity_V128);
+         IRTemp vecB_signbit_comp = newTemp(Ity_V128);
+         DIP("xsnabsdp v%d,v%d\n", (UInt)XT, (UInt)XB);
+         assign( vecB_no_signbit, binop( Iop_ShrV128, binop( Iop_ShlV128,
+                                                             mkexpr( vB ),
+                                                             mkU8( 1 ) ),
+                                         mkU8( 1 ) ) );
+         assign( vecB_signbit_comp, binop( Iop_ShlV128,
+                                           unop( Iop_NotV128,
+                                                 binop( Iop_ShrV128,
+                                                        mkexpr( vB ),
+                                                        mkU8( 127 ) ) ),
+                                           mkU8( 127 ) ) );
+         putVSReg( XT, binop( Iop_OrV128, mkexpr( vecB_no_signbit ),
+                              mkexpr( vecB_signbit_comp ) ) );
+         break;
+      }
+
+      default:
+         vex_printf( "dis_vx_move(ppc)(opc2)\n" );
+         return False;
+   }
+   return True;
+}
+
+/*
+ * VSX Logical Instructions
+ */
+static Bool
+dis_vx_logic ( UInt theInstr, UInt opc2 )
+{
+   /* XX3-Form */
+   UChar opc1 = ifieldOPC( theInstr );
+   UChar XT = ifieldRegXT ( theInstr );
+   UChar XA = ifieldRegXA ( theInstr );
+   UChar XB = ifieldRegXB ( theInstr );
+   IRTemp vA = newTemp( Ity_V128 );
+   IRTemp vB = newTemp( Ity_V128 );
+
+   if (opc1 != 0x3C) {
+      vex_printf( "dis_vx_logic(ppc)(instr)\n" );
+      return False;
+   }
+
+   assign( vA, getVSReg( XA ) );
+   assign( vB, getVSReg( XB ) );
+
+   switch (opc2) {
+      case 0x268: // xxlxor
+         DIP("xxlxor v%d,v%d,v%d\n", (UInt)XT, (UInt)XA, (UInt)XB);
+         putVSReg( XT, binop( Iop_XorV128, mkexpr( vA ), mkexpr( vB ) ) );
+         break;
+      case 0x248: // xxlor
+         DIP("xxlor v%d,v%d,v%d\n", (UInt)XT, (UInt)XA, (UInt)XB);
+         putVSReg( XT, binop( Iop_OrV128, mkexpr( vA ), mkexpr( vB ) ) );
+         break;
+      case 0x288: // xxlnor
+         DIP("xxlnor v%d,v%d,v%d\n", (UInt)XT, (UInt)XA, (UInt)XB);
+         putVSReg( XT, unop( Iop_NotV128, binop( Iop_OrV128, mkexpr( vA ),
+                                                 mkexpr( vB ) ) ) );
+         break;
+      case 0x208: // xxland
+         DIP("xxland v%d,v%d,v%d\n", (UInt)XT, (UInt)XA, (UInt)XB);
+         putVSReg( XT, binop( Iop_AndV128, mkexpr( vA ), mkexpr( vB ) ) );
+         break;
+      case 0x228: //xxlandc
+         DIP("xxlandc v%d,v%d,v%d\n", (UInt)XT, (UInt)XA, (UInt)XB);
+         putVSReg( XT, binop( Iop_AndV128, mkexpr( vA ), unop( Iop_NotV128,
+                                                               mkexpr( vB ) ) ) );
+         break;
+      default:
+         vex_printf( "dis_vx_logic(ppc)(opc2)\n" );
+         return False;
+   }
+   return True;
+}
+
+/*
+ * VSX Load Instructions
+ * NOTE: VSX supports word-aligned storage access.
+ */
+static Bool
+dis_vx_load ( UInt theInstr )
+{
+   /* XX1-Form */
+   UChar opc1 = ifieldOPC( theInstr );
+   UChar XT = ifieldRegXT ( theInstr );
+   UChar rA_addr = ifieldRegA( theInstr );
+   UChar rB_addr = ifieldRegB( theInstr );
+   UInt opc2 = ifieldOPClo10( theInstr );
+
+   IRType ty = mode64 ? Ity_I64 : Ity_I32;
+   IRTemp EA = newTemp( ty );
+
+   if (opc1 != 0x1F) {
+      vex_printf( "dis_vx_load(ppc)(instr)\n" );
+      return False;
+   }
+
+   assign( EA, ea_rAor0_idxd( rA_addr, rB_addr ) );
+
+   switch (opc2) {
+   case 0x24C: // lxsdx
+   {
+      IRExpr * exp;
+      DIP("lxsdx %d,r%u,r%u\n", (UInt)XT, rA_addr, rB_addr);
+      exp = loadBE( Ity_I64, mkexpr( EA ) );
+      // We need to pass an expression of type Ity_V128 with putVSReg, but the load
+      // we just performed is only a DW.  But since the contents of VSR[XT] element 1
+      // are undefined after this operation, we can just do a splat op.
+      putVSReg( XT, binop( Iop_64HLtoV128, exp, exp ) );
+      break;
+   }
+   case 0x34C: // lxvd2x
+   {
+      IROp addOp = ty == Ity_I64 ? Iop_Add64 : Iop_Add32;
+      IRExpr * high, *low;
+      ULong ea_off = 8;
+      IRExpr* high_addr;
+      DIP("lxvd2x %d,r%u,r%u\n", (UInt)XT, rA_addr, rB_addr);
+      high = loadBE( Ity_I64, mkexpr( EA ) );
+      high_addr = binop( addOp, mkexpr( EA ), ty == Ity_I64 ? mkU64( ea_off )
+            : mkU32( ea_off ) );
+      low = loadBE( Ity_I64, high_addr );
+      putVSReg( XT, binop( Iop_64HLtoV128, high, low ) );
+      break;
+   }
+   case 0x14C: // lxvdsx
+   {
+      IRTemp data = newTemp(Ity_I64);
+      DIP("lxvdsx %d,r%u,r%u\n", (UInt)XT, rA_addr, rB_addr);
+      assign( data, loadBE( Ity_I64, mkexpr( EA ) ) );
+      putVSReg( XT, binop( Iop_64HLtoV128, mkexpr( data ), mkexpr( data ) ) );
+      break;
+   }
+   case 0x30C:
+   {
+      IRExpr * t3, *t2, *t1, *t0;
+      UInt ea_off = 0;
+      IRExpr* irx_addr;
+
+      DIP("lxvw4x %d,r%u,r%u\n", (UInt)XT, rA_addr, rB_addr);
+      t3 = loadBE( Ity_I32,  mkexpr( EA ) );
+      ea_off += 4;
+      irx_addr = binop( mkSzOp( ty, Iop_Add8 ), mkexpr( EA ),
+                        ty == Ity_I64 ? mkU64( ea_off ) : mkU32( ea_off ) );
+      t2 = loadBE( Ity_I32, irx_addr );
+      ea_off += 4;
+      irx_addr = binop( mkSzOp( ty, Iop_Add8 ), mkexpr( EA ),
+                        ty == Ity_I64 ? mkU64( ea_off ) : mkU32( ea_off ) );
+      t1 = loadBE( Ity_I32, irx_addr );
+      ea_off += 4;
+      irx_addr = binop( mkSzOp( ty, Iop_Add8 ), mkexpr( EA ),
+                        ty == Ity_I64 ? mkU64( ea_off ) : mkU32( ea_off ) );
+      t0 = loadBE( Ity_I32, irx_addr );
+      putVSReg( XT, binop( Iop_64HLtoV128, binop( Iop_32HLto64, t3, t2 ),
+                           binop( Iop_32HLto64, t1, t0 ) ) );
+      break;
+   }
+   default:
+      vex_printf( "dis_vx_load(ppc)(opc2)\n" );
+      return False;
+   }
+   return True;
+}
+
+/*
+ * VSX Store Instructions
+ * NOTE: VSX supports word-aligned storage access.
+ */
+static Bool
+dis_vx_store ( UInt theInstr )
+{
+   /* XX1-Form */
+   UChar opc1 = ifieldOPC( theInstr );
+   UChar XS = ifieldRegXS( theInstr );
+   UChar rA_addr = ifieldRegA( theInstr );
+   UChar rB_addr = ifieldRegB( theInstr );
+   IRTemp vS = newTemp( Ity_V128 );
+   UInt opc2 = ifieldOPClo10( theInstr );
+
+   IRType ty = mode64 ? Ity_I64 : Ity_I32;
+   IRTemp EA = newTemp( ty );
+
+   if (opc1 != 0x1F) {
+      vex_printf( "dis_vx_store(ppc)(instr)\n" );
+      return False;
+   }
+
+   assign( EA, ea_rAor0_idxd( rA_addr, rB_addr ) );
+   assign( vS, getVSReg( XS ) );
+
+   switch (opc2) {
+   case 0x2CC:
+   {
+      IRExpr * high64;
+      DIP("stxsdx %d,r%u,r%u\n", (UInt)XS, rA_addr, rB_addr);
+      high64 = unop( Iop_V128HIto64, mkexpr( vS ) );
+      storeBE( mkexpr( EA ), high64 );
+      break;
+   }
+   case 0x3CC:
+   {
+      IRExpr * high64, *low64;
+      DIP("stxvd2x %d,r%u,r%u\n", (UInt)XS, rA_addr, rB_addr);
+      high64 = unop( Iop_V128HIto64, mkexpr( vS ) );
+      low64 = unop( Iop_V128to64, mkexpr( vS ) );
+      storeBE( mkexpr( EA ), high64 );
+      storeBE( binop( mkSzOp( ty, Iop_Add8 ), mkexpr( EA ), ty == Ity_I64 ? mkU64( 8 )
+            : mkU32( 8 ) ), low64 );
+      break;
+   }
+   case 0x38C:
+   {
+      UInt ea_off = 0;
+      IRExpr* irx_addr;
+      IRTemp hi64 = newTemp( Ity_I64 );
+      IRTemp lo64 = newTemp( Ity_I64 );
+
+      DIP("stxvw4x %d,r%u,r%u\n", (UInt)XS, rA_addr, rB_addr);
+
+      // This instruction supports word-aligned stores, so EA may not be
+      // quad-word aligned.  Therefore, do 4 individual word-size stores.
+      assign( hi64, unop( Iop_V128HIto64, mkexpr( vS ) ) );
+      assign( lo64, unop( Iop_V128to64, mkexpr( vS ) ) );
+
+      storeBE( mkexpr( EA ), unop( Iop_64HIto32, mkexpr( hi64 ) ) );
+      ea_off += 4;
+      irx_addr = binop( mkSzOp( ty, Iop_Add8 ), mkexpr( EA ),
+                        ty == Ity_I64 ? mkU64( ea_off ) : mkU32( ea_off ) );
+      storeBE( irx_addr, unop( Iop_64to32, mkexpr( hi64 ) ) );
+      ea_off += 4;
+      irx_addr = binop( mkSzOp( ty, Iop_Add8 ), mkexpr( EA ),
+                        ty == Ity_I64 ? mkU64( ea_off ) : mkU32( ea_off ) );
+      storeBE( irx_addr, unop( Iop_64HIto32, mkexpr( lo64 ) ) );
+      ea_off += 4;
+      irx_addr = binop( mkSzOp( ty, Iop_Add8 ), mkexpr( EA ),
+                        ty == Ity_I64 ? mkU64( ea_off ) : mkU32( ea_off ) );
+      storeBE( irx_addr, unop( Iop_64to32, mkexpr( lo64 ) ) );
+
+      break;
+   }
+   default:
+      vex_printf( "dis_vx_store(ppc)(opc2)\n" );
+      return False;
+   }
+   return True;
+}
+
+/*
+ * VSX Permute Instructions
+ */
+static Bool
+dis_vx_permute( UInt theInstr, UInt opc2 )
+{
+   /* XX3-Form */
+   UChar opc1 = ifieldOPC( theInstr );
+   UChar XT = ifieldRegXT ( theInstr );
+   UChar XA = ifieldRegXA ( theInstr );
+   UChar XB = ifieldRegXB ( theInstr );
+   IRTemp vT = newTemp( Ity_V128 );
+   IRTemp vA = newTemp( Ity_V128 );
+   IRTemp vB = newTemp( Ity_V128 );
+
+   if (opc1 != 0x3C) {
+      vex_printf( "dis_vx_permute(ppc)(instr)\n" );
+      return False;
+   }
+
+   assign( vA, getVSReg( XA ) );
+   assign( vB, getVSReg( XB ) );
+
+   switch (opc2) {
+      case 0x8: // xxsldwi (VSX Shift Left Double by Word Immediate)
+      {
+         UChar SHW = ifieldSHW ( theInstr );
+         IRTemp result = newTemp(Ity_V128);
+         if ( SHW != 0 ) {
+             IRTemp hi = newTemp(Ity_V128);
+             IRTemp lo = newTemp(Ity_V128);
+             assign( hi, binop(Iop_ShlV128, mkexpr(vA), mkU8(SHW*32)) );
+             assign( lo, binop(Iop_ShrV128, mkexpr(vB), mkU8(128-SHW*32)) );
+             assign ( result, binop(Iop_OrV128, mkexpr(hi), mkexpr(lo)) );
+         } else
+             assign ( result, mkexpr(vA) );
+         DIP("xxsldwi v%d,v%d,v%d,%d\n", (UInt)XT, (UInt)XA, (UInt)XB, (UInt)SHW);
+         putVSReg( XT, mkexpr(result) );
+         break;
+      }
+      case 0x28: // xpermdi (VSX Permute Doubleword Immediate)
+      {
+         UChar DM = ifieldDM ( theInstr );
+         IRTemp hi = newTemp(Ity_I64);
+         IRTemp lo = newTemp(Ity_I64);
+
+         if (DM & 0x2)
+           assign( hi, unop(Iop_V128to64, mkexpr(vA)) );
+         else
+           assign( hi, unop(Iop_V128HIto64, mkexpr(vA)) );
+
+         if (DM & 0x1)
+           assign( lo, unop(Iop_V128to64, mkexpr(vB)) );
+         else
+           assign( lo, unop(Iop_V128HIto64, mkexpr(vB)) );
+
+         assign( vT, binop(Iop_64HLtoV128, mkexpr(hi), mkexpr(lo)) );
+
+         DIP("xxpermdi v%d,v%d,v%d,0x%x\n", (UInt)XT, (UInt)XA, (UInt)XB, (UInt)DM);
+         putVSReg( XT, mkexpr( vT ) );
+         break;
+      }
+      case 0x48: // xxmrghw (VSX Merge High Word)
+      case 0xc8: // xxmrglw (VSX Merge Low Word)
+      {
+         char type = (opc2 == 0x48) ? 'h' : 'l';
+         IROp word_op = (opc2 == 0x48) ? Iop_V128HIto64 : Iop_V128to64;
+         IRTemp a64 = newTemp(Ity_I64);
+         IRTemp ahi32 = newTemp(Ity_I32);
+         IRTemp alo32 = newTemp(Ity_I32);
+         IRTemp b64 = newTemp(Ity_I64);
+         IRTemp bhi32 = newTemp(Ity_I32);
+         IRTemp blo32 = newTemp(Ity_I32);
+
+         assign( a64, unop(word_op, mkexpr(vA)) );
+         assign( ahi32, unop(Iop_64HIto32, mkexpr(a64)) );
+         assign( alo32, unop(Iop_64to32, mkexpr(a64)) );
+
+         assign( b64, unop(word_op, mkexpr(vB)) );
+         assign( bhi32, unop(Iop_64HIto32, mkexpr(b64)) );
+         assign( blo32, unop(Iop_64to32, mkexpr(b64)) );
+
+         assign( vT, binop(Iop_64HLtoV128,
+                           binop(Iop_32HLto64, mkexpr(ahi32), mkexpr(bhi32)),
+                           binop(Iop_32HLto64, mkexpr(alo32), mkexpr(blo32))) );
+
+         DIP("xxmrg%cw v%d,v%d,v%d\n", type, (UInt)XT, (UInt)XA, (UInt)XB);
+         putVSReg( XT, mkexpr( vT ) );
+         break;
+      }
+
+      default:
+         vex_printf( "dis_vx_permute(ppc)(opc2)\n" );
+         return False;
+   }
+   return True;
+}
+
+/*
   AltiVec Load Instructions
 */
 static Bool dis_av_load ( VexAbiInfo* vbi, UInt theInstr )
@@ -7400,7 +8655,6 @@ static Bool dis_av_load ( VexAbiInfo* vb
    return True;
 }
 
-
 /*
   AltiVec Store Instructions
 */
@@ -9238,8 +10492,221 @@ static Bool dis_av_fp_convert ( UInt the
 }
 
 
+/* The 0x3C primary opcode (VSX category) uses several different forms of
+ * extended opcodes:
+ *   o XX2-form:
+ *      - [10:2] (IBM notation [21:29])
+ *   o XX3-form variants:
+ *       - variant 1: [10:3] (IBM notation [21:28])
+ *       - variant 2: [9:3] (IBM notation [22:28])
+ *       - variant 3: [7:3] (IBM notation [24:28])
+ *   o XX-4 form:
+ *      - [10:6] (IBM notation [21:25])
+ *
+ * The XX2-form needs bit 0 masked from the standard extended opcode
+ * as returned by ifieldOPClo10; the XX3-form needs bits 0 and 1 masked;
+ * and the XX4-form needs bits 0, 1, and 2 masked.  Additionally, the
+ * XX4 and XX3 (variants 2 and 3) forms need certain bits masked on the
+ * front end since their encoding does not begin at bit 21 like the standard
+ * format.
+ *
+ * The get_VSX60_opc2() function uses the vsx_insn array below to obtain the
+ * secondary opcode for such VSX instructions.
+ *
+*/
+
+
+struct vsx_insn {
+   UInt opcode;
+   Char * name;
+};
+
+//  ATTENTION:  Keep this array sorted on the opcocde!!!
+static struct vsx_insn vsx_all[] = {
+      { 0x8, "xxsldwi" },
+      { 0x18, "xxsel" },
+      { 0x28, "xxpermdi" },
+      { 0x48, "xxmrghw" },
+      { 0x80, "xsadddp" },
+      { 0x84, "xsmaddadp" },
+      { 0x8c, "xscmpudp" },
+      { 0x90, "xscvdpuxws" },
+      { 0x92, "xsrdpi" },
+      { 0x94, "xsrsqrtedp" },
+      { 0x96, "xssqrtdp" },
+      { 0xa0, "xssubdp" },
+      { 0xa4, "xsmaddmdp" },
+      { 0xac, "xscmpodp" },
+      { 0xb0, "xscvdpsxws" },
+      { 0xb2, "xsrdpiz" },
+      { 0xb4, "xsredp" },
+      { 0xc0, "xsmuldp" },
+      { 0xc4, "xsmsubadp" },
+      { 0xc8, "xxmrglw" },
+      { 0xd2, "xsrdpip" },
+      { 0xd4, "xstsqrtdp" },
+      { 0xd6, "xsrdpic" },
+      { 0xe0, "xsdivdp" },
+      { 0xe4, "xsmsubmdp" },
+      { 0xf2, "xsrdpim" },
+      { 0xf4, "xstdivdp" },
+      { 0x100, "xvaddsp" },
+      { 0x104, "xvmaddasp" },
+      { 0x10c, "xvcmpeqsp" },
+      { 0x110, "xvcvspuxws" },
+      { 0x112, "xvrspi" },
+      { 0x114, "xvrsqrtesp" },
+      { 0x116, "xvsqrtsp" },
+      { 0x120, "xvsubsp" },
+      { 0x124, "xvmaddmsp" },
+      { 0x12c, "xvcmpgtsp" },
+      { 0x130, "xvcvspsxws" },
+      { 0x132, "xvrspiz" },
+      { 0x134, "xvresp" },
+      { 0x140, "xvmulsp" },
+      { 0x144, "xvmsubasp" },
+      { 0x148, "xxspltw" },
+      { 0x14c, "xvcmpgesp" },
+      { 0x150, "xvcvuxwsp" },
+      { 0x152, "xvrspip" },
+      { 0x154, "xvtsqrtsp" },
+      { 0x156, "xvrspic" },
+      { 0x160, "xvdivsp" },
+      { 0x164, "xvmsubmsp" },
+      { 0x170, "xvcvsxwsp" },
+      { 0x172, "xvrspim" },
+      { 0x174, "xvtdivsp" },
+      { 0x180, "xvadddp" },
+      { 0x184, "xvmaddadp" },
+      { 0x18c, "xvcmpeqdp" },
+      { 0x190, "xvcvdpuxws" },
+      { 0x192, "xvrdpi" },
+      { 0x194, "xvrsqrtedp" },
+      { 0x196, "xvsqrtdp" },
+      { 0x1a0, "xvsubdp" },
+      { 0x1a4, "xvmaddmdp" },
+      { 0x1ac, "xvcmpgtdp" },
+      { 0x1b0, "xvcvdpsxws" },
+      { 0x1b2, "xvrdpiz" },
+      { 0x1b4, "xvredp" },
+      { 0x1c0, "xvmuldp" },
+      { 0x1c4, "xvmsubadp" },
+      { 0x1cc, "xvcmpgedp" },
+      { 0x1d0, "xvcvuxwdp" },
+      { 0x1d2, "xvrdpip" },
+      { 0x1d4, "xvtsqrtdp" },
+      { 0x1d6, "xvrdpic" },
+      { 0x1e0, "xvdivdp" },
+      { 0x1e4, "xvmsubmdp" },
+      { 0x1f0, "xvcvsxwdp" },
+      { 0x1f2, "xvrdpim" },
+      { 0x1f4, "xvtdivdp" },
+      { 0x208, "xxland" },
+      { 0x212, "xscvdpsp" },
+      { 0x228, "xxlandc" },
+      { 0x248 , "xxlor" },
+      { 0x268, "xxlxor" },
+      { 0x280, "xsmaxdp" },
+      { 0x284, "xsnmaddadp" },
+      { 0x288, "xxlnor" },
+      { 0x290, "xscvdpuxds" },
+      { 0x292, "xscvspdp" },
+      { 0x2a0, "xsmindp" },
+      { 0x2a4, "xsnmaddmdp" },
+      { 0x2b0, "xscvdpsxds" },
+      { 0x2b2, "xsabsdp" },
+      { 0x2c0, "xscpsgndp" },
+      { 0x2c4, "xsnmsubadp" },
+      { 0x2d0, "xscvuxddp" },
+      { 0x2d2, "xsnabsdp" },
+      { 0x2e4, "xsnmsubmdp" },
+      { 0x2f0, "xscvsxddp" },
+      { 0x2f2, "xsnegdp" },
+      { 0x300, "xvmaxsp" },
+      { 0x304, "xvnmaddasp" },
+      { 0x30c, "xvcmpeqsp." },
+      { 0x310, "xvcvspuxds" },
+      { 0x312, "xvcvdpsp" },
+      { 0x320, "xvminsp" },
+      { 0x324, "xvnmaddmsp" },
+      { 0x32c, "xvcmpgtsp." },
+      { 0x330, "xvcvspsxds" },
+      { 0x332, "xvabssp" },
+      { 0x340, "xvcpsgnsp" },
+      { 0x344, "xvnmsubasp" },
+      { 0x34c, "xvcmpgesp." },
+      { 0x350, "xvcvuxdsp" },
+      { 0x352, "xvnabssp" },
+      { 0x364, "xvnmsubmsp" },
+      { 0x370, "xvcvsxdsp" },
+      { 0x372, "xvnegsp" },
+      { 0x380, "xvmaxdp" },
+      { 0x384, "xvnmaddadp" },
+      { 0x38c, "xvcmpeqdp." },
+      { 0x390, "xvcvdpuxds" },
+      { 0x392, "xvcvspdp" },
+      { 0x3a0, "xvmindp" },
+      { 0x3a4, "xvnmaddmdp" },
+      { 0x3ac, "xvcmpgtdp." },
+      { 0x3b0, "xvcvdpsxds" },
+      { 0x3b2, "xvabsdp" },
+      { 0x3c0, "xvcpsgndp" },
+      { 0x3c4, "xvnmsubadp" },
+      { 0x3cc, "xvcmpgedp." },
+      { 0x3d0, "xvcvuxddp" },
+      { 0x3d2, "xvnabsdp" },
+      { 0x3e4, "xvnmsubmdp" },
+      { 0x3f0, "xvcvsxddp" },
+      { 0x3f2, "xvnegdp" }
+};
+#define VSX_ALL_LEN 135
+
+// ATTENTION: This search function assumes vsx_all array is sorted.
+static Int findVSXextOpCode(UInt opcode)
+{
+   Int low, mid, high;
+   low = 0;
+   high = VSX_ALL_LEN - 1;
+   while (low <= high) {
+      mid = (low + high)/2;
+      if (opcode < vsx_all[mid].opcode)
+         high = mid - 1;
+      else if (opcode > vsx_all[mid].opcode)
+         low = mid + 1;
+      else
+         return mid;
+   }
+   return -1;
+}
 
 
+/* The full 10-bit extended opcode retrieved via ifieldOPClo10 is
+ * passed, and we then try to match it up with one of the above
+ * VSX forms.
+ */
+static UInt get_VSX60_opc2(UInt opc2_full)
+{
+#define XX2_MASK 0x000003FE
+#define XX3_1_MASK 0x000003FC
+#define XX3_2_MASK 0x000001FC
+#define XX3_3_MASK 0x0000007C
+#define XX4_MASK 0x000003E0
+   Int ret;
+   UInt vsxExtOpcode = 0;
+
+   if (( ret = findVSXextOpCode(opc2_full & XX2_MASK)) >= 0)
+      vsxExtOpcode = vsx_all[ret].opcode;
+   else if (( ret = findVSXextOpCode(opc2_full & XX3_1_MASK)) >= 0)
+      vsxExtOpcode = vsx_all[ret].opcode;
+   else if (( ret = findVSXextOpCode(opc2_full & XX3_2_MASK)) >= 0)
+      vsxExtOpcode = vsx_all[ret].opcode;
+   else if (( ret = findVSXextOpCode(opc2_full & XX3_3_MASK)) >= 0)
+      vsxExtOpcode = vsx_all[ret].opcode;
+   else if (( ret = findVSXextOpCode(opc2_full & XX4_MASK)) >= 0)
+      vsxExtOpcode = vsx_all[ret].opcode;
+
+   return vsxExtOpcode;
+}
 
 /*------------------------------------------------------------*/
 /*--- Disassemble a single instruction                     ---*/
@@ -9268,6 +10735,7 @@ DisResult disInstr_PPC_WRK ( 
    Bool      allow_V  = False;
    Bool      allow_FX = False;
    Bool      allow_GX = False;
+   Bool      allow_VX = False;
    UInt      hwcaps = archinfo->hwcaps;
    Long      delta;
 
@@ -9277,11 +10745,13 @@ DisResult disInstr_PPC_WRK ( 
       allow_V  = (0 != (hwcaps & VEX_HWCAPS_PPC64_V));
       allow_FX = (0 != (hwcaps & VEX_HWCAPS_PPC64_FX));
       allow_GX = (0 != (hwcaps & VEX_HWCAPS_PPC64_GX));
+      allow_VX = (0 != (hwcaps & VEX_HWCAPS_PPC64_VX));
    } else {
       allow_F  = (0 != (hwcaps & VEX_HWCAPS_PPC32_F));
       allow_V  = (0 != (hwcaps & VEX_HWCAPS_PPC32_V));
       allow_FX = (0 != (hwcaps & VEX_HWCAPS_PPC32_FX));
       allow_GX = (0 != (hwcaps & VEX_HWCAPS_PPC32_GX));
+      allow_VX = (0 != (hwcaps & VEX_HWCAPS_PPC32_VX));
    }
 
    /* The running delta */
@@ -9473,6 +10943,20 @@ DisResult disInstr_PPC_WRK ( 
 
    case 0x3B:
       if (!allow_F) goto decode_noF;
+      opc2 = ifieldOPClo10(theInstr);
+      switch (opc2) {
+         case 0x3CE: // fcfidus (implemented as native insn
+            if (!allow_VX)
+               goto decode_noVX;
+            if (dis_fp_round( theInstr ))
+               goto decode_success;
+            goto decode_failure;
+         case 0x34E: // fcfids
+            if (dis_fp_round( theInstr ))
+               goto decode_success;
+            goto decode_failure;
+      }
+
       opc2 = IFIELD(theInstr, 1, 5);
       switch (opc2) {
       /* Floating Point Arith Instructions */
@@ -9499,12 +10983,64 @@ DisResult disInstr_PPC_WRK ( 
          if (!allow_GX) goto decode_noGX;
          if (dis_fp_arith(theInstr)) goto decode_success;
          goto decode_failure;
-         
+
       default:
          goto decode_failure;
       }
       break;
 
+   case 0x3C: // VSX instructions (except load/store)
+   {
+      UInt vsxOpc2 = get_VSX60_opc2(opc2);
+      /* The vsxOpc2 returned is the "normalized" value, representing the
+       * instructions secondary opcode as taken from the standard secondary
+       * opcode field [21:30] (IBM notatition), even if the actual field
+       * is non-standard.  These normalized values are given in the opcode
+       * appendices of the ISA 2.06 document.
+       */
+      if (vsxOpc2 == 0)
+         goto decode_failure;
+
+      switch (vsxOpc2) {
+         case 0x8: case 0x28: case 0x48: case 0xc8: // xxsldwi, xxpermdi, xxmrghw, xxmrglw
+            if (dis_vx_permute(theInstr, vsxOpc2)) goto decode_success;
+            goto decode_failure;
+         case 0x268: case 0x248: case 0x288: case 0x208: case 0x228: // xxlxor, xxlor, xxlnor, xxland, xxlandc
+            if (dis_vx_logic(theInstr, vsxOpc2)) goto decode_success;
+            goto decode_failure;
+         case 0x2B2: // xsabsdp
+            if (dis_vx_move(theInstr, vsxOpc2)) goto decode_success;
+            goto decode_failure;
+         case 0x2C0: // xscpsgndp
+            if (dis_vx_move(theInstr, vsxOpc2)) goto decode_success;
+            goto decode_failure;
+         case 0x2D2: // xsnabsdp
+            if (dis_vx_move(theInstr, vsxOpc2)) goto decode_success;
+            goto decode_failure;
+         case 0x2F2: // xsnegdp
+            if (dis_vx_move(theInstr, vsxOpc2)) goto decode_success;
+            goto decode_failure;
+         case 0x08C: case 0x0AC: // xscmpudp, xscmpodp
+            if (dis_vx_cmp(theInstr, vsxOpc2)) goto decode_success;
+            goto decode_failure;
+         case 0x080: case 0x0E0: // xsadddp, xsdivdp
+         case 0x084: case 0x0A4: // xsmaddadp, xsmaddmdp
+         case 0x0C4: case 0x0E4: // xsmsubadp, xsmsubmdp
+         case 0x284: case 0x2A4: // xsnmaddadp, xsnmaddmdp
+         case 0x0C0: // xsmuldp
+         case 0x0A0: // xssubdp
+            if (dis_vx_arith(theInstr, vsxOpc2)) goto decode_success;
+            goto decode_failure;
+         case 0x2B0: case 0x2F0: case 0x2D0: // xscvdpsxds, xscvsxddp, xscvuxddp
+            if (dis_vx_conv(theInstr, vsxOpc2)) goto decode_success;
+            goto decode_failure;
+
+         default:
+            goto decode_failure;
+      }
+      break;
+   }
+
    /* 64bit Integer Stores */
    case 0x3E:  // std, stdu
       if (!mode64) goto decode_failure;
@@ -9555,6 +11091,10 @@ DisResult disInstr_PPC_WRK ( 
          if (dis_fp_cmp(theInstr)) goto decode_success;
          goto decode_failure;
          
+      case 0x080: // ftdiv
+         if (dis_fp_ftdiv(theInstr)) goto decode_success;
+         goto decode_failure;
+
       /* Floating Point Rounding/Conversion Instructions */         
       case 0x00C: // frsp
       case 0x00E: // fctiw
@@ -9564,6 +11104,11 @@ DisResult disInstr_PPC_WRK ( 
       case 0x34E: // fcfid
          if (dis_fp_round(theInstr)) goto decode_success;
          goto decode_failure;
+      case 0x3CE: // fcfidu (implemented as native insn)
+         if (!allow_VX) goto decode_noVX;
+         if (dis_fp_round(theInstr)) goto decode_success;
+         goto decode_failure;
+
 
       /* Power6 rounding stuff */
       case 0x1E8: // frim
@@ -9730,7 +11275,7 @@ DisResult disInstr_PPC_WRK ( 
 
       /* Integer Load and Store with Byte Reverse Instructions */
       case 0x316: case 0x216: case 0x396: // lhbrx, lwbrx, sthbrx
-      case 0x296:                         // stwbrx
+      case 0x296: case 0x214:             // stwbrx, ldbrx
          if (dis_int_ldst_rev( theInstr )) goto decode_success;
          goto decode_failure;
          
@@ -9815,6 +11360,11 @@ DisResult disInstr_PPC_WRK ( 
          if (dis_fp_load( theInstr )) goto decode_success;
          goto decode_failure;
 
+      case 0x377:                         // lfiwzx
+         if (!allow_F) goto decode_noF;
+         if (dis_fp_load( theInstr )) goto decode_success;
+         goto decode_failure;
+
       /* AltiVec instructions */
 
       /* AV Cache Control - Data streams */
@@ -9838,6 +11388,26 @@ DisResult disInstr_PPC_WRK ( 
          if (dis_av_store( theInstr )) goto decode_success;
          goto decode_failure;
 
+      /* VSX Load */
+      case 0x24C: // lxsdx
+      case 0x34C: // lxvd2x
+      case 0x14C: // lxvdsx
+      case 0x30C: // lxvw4x
+    	  if (dis_vx_load( theInstr )) goto decode_success;
+          goto decode_failure;
+
+      /* VSX Store */
+      case 0x2CC: // stxsdx
+      case 0x3CC: // stxvd2x
+      case 0x38C: // stxvw4x
+    	  if (dis_vx_store( theInstr )) goto decode_success;
+    	  goto decode_failure;
+
+      /* Miscellaneous ISA 2.06 instructions */
+      case 0x1FA: // popcntd
+    	  if (dis_int_logic( theInstr )) goto decode_success;
+    	  goto decode_failure;
+
       default:
          /* Deal with some other cases that we would otherwise have
             punted on. */
@@ -10023,6 +11593,10 @@ DisResult disInstr_PPC_WRK ( 
       vassert(!allow_V);
       vex_printf("disInstr(ppc): declined to decode an AltiVec insn.\n");
       goto decode_failure;
+   decode_noVX:
+      vassert(!allow_VX);
+      vex_printf("disInstr(ppc): declined to decode a VSX insn.\n");
+      goto decode_failure;
    decode_noFX:
       vassert(!allow_FX);
       vex_printf("disInstr(ppc): "
@@ -10105,10 +11679,10 @@ DisResult disInstr_PPC ( IRSB*        ir
 
    /* do some sanity checks */
    mask32 = VEX_HWCAPS_PPC32_F | VEX_HWCAPS_PPC32_V
-            | VEX_HWCAPS_PPC32_FX | VEX_HWCAPS_PPC32_GX;
+            | VEX_HWCAPS_PPC32_FX | VEX_HWCAPS_PPC32_GX | VEX_HWCAPS_PPC32_VX;
 
-   mask64 = VEX_HWCAPS_PPC64_V
-            | VEX_HWCAPS_PPC64_FX | VEX_HWCAPS_PPC64_GX;
+   mask64 = VEX_HWCAPS_PPC64_V | VEX_HWCAPS_PPC64_FX
+		   | VEX_HWCAPS_PPC64_GX | VEX_HWCAPS_PPC64_VX;
 
    if (mode64) {
       vassert((hwcaps_guest & mask32) == 0);
--- valgrind-3.6.0/VEX/priv/host_ppc_isel.c	(revision 2087)	(revision 2126)	(revision 2129)	(revision 2135)	(revision 2147)
+++ valgrind-3.6.0/VEX/priv/host_ppc_isel.c	(revision 2088)	(revision 2127)	(revision 2130)	(revision 2136)	(revision 2148)
@@ -126,7 +126,10 @@ fnabs[.]                 if .           
 
 fadd[.]                  if .             y             y
 fadds[.]                 if .             y             y
-fcfid[.] (i64->dbl)      if .             y             y
+fcfid[.] (Si64->dbl)     if .             y             y
+fcfidU[.] (Ui64->dbl)    if .             y             y
+fcfids[.] (Si64->sngl)   if .             Y             Y
+fcfidus[.] (Ui64->sngl)  if .             Y             Y
 fcmpo (cmp, result       n                n             n
 fcmpu  to crfD)          n                n             n
 fctid[.]  (dbl->i64)     if .       ->undef             y
@@ -559,7 +562,7 @@ PPCAMode* genGuestArrayOffset ( ISelEnv*
 
    if (bias < -100 || bias > 100) /* somewhat arbitrarily */
       vpanic("genGuestArrayOffset(ppc host)(3)");
-   if (descr->base < 0 || descr->base > 4000) /* somewhat arbitrarily */
+   if (descr->base < 0 || descr->base > 5000) /* somewhat arbitrarily */
       vpanic("genGuestArrayOffset(ppc host)(4)");
 
    /* Compute off into a reg, %off.  Then return:
@@ -994,6 +997,16 @@ static HReg generate_zeroes_V128 ( ISelE
    return dst;
 }
 
+/* Generate all-ones into a new vector register.
+*/
+static HReg generate_ones_V128 ( ISelEnv* env )
+{
+   HReg dst = newVRegV(env);
+   PPCVI5s * src = PPCVI5s_Imm(-1);
+   addInstr(env, PPCInstr_AvSplat(8, dst, src));
+   return dst;
+}
+
 
 /*
   Generates code for AvSplat
@@ -1458,7 +1471,8 @@ static HReg iselWordExpr_R_wrk ( ISelEnv
          set_FPU_rounding_mode( env, e->Iex.Binop.arg1 );
 
          sub_from_sp( env, 16 );
-         addInstr(env, PPCInstr_FpCftI(False/*F->I*/, True/*int32*/, 
+         addInstr(env, PPCInstr_FpCftI(False/*F->I*/, True/*int32*/,
+                                       True/*syned*/, True/*flt64*/,
                                        ftmp, fsrc));
          addInstr(env, PPCInstr_FpSTFIW(r1, ftmp));
          addInstr(env, PPCInstr_Load(4, idst, zero_r1, mode64));
@@ -1486,8 +1500,8 @@ static HReg iselWordExpr_R_wrk ( ISelEnv
             set_FPU_rounding_mode( env, e->Iex.Binop.arg1 );
 
             sub_from_sp( env, 16 );
-            addInstr(env, PPCInstr_FpCftI(False/*F->I*/, False/*int64*/,
-                                          ftmp, fsrc));
+            addInstr(env, PPCInstr_FpCftI(False/*F->I*/, False/*int64*/, True,
+                                          True, ftmp, fsrc));
             addInstr(env, PPCInstr_FpLdSt(False/*store*/, 8, ftmp, zero_r1));
             addInstr(env, PPCInstr_Load(8, idst, zero_r1, True/*mode64*/));
             add_to_sp( env, 16 );
@@ -1602,6 +1616,7 @@ static HReg iselWordExpr_R_wrk ( ISelEnv
       case Iop_Not16:
       case Iop_Not32:
       case Iop_Not64: {
+         if (op_unop == Iop_Not64) vassert(mode64);
          HReg r_dst = newVRegI(env);
          HReg r_src = iselWordExpr_R(env, e->Iex.Unop.arg);
          addInstr(env, PPCInstr_Unary(Pun_NOT,r_dst,r_src));
@@ -2390,8 +2405,10 @@ static PPCCondCode iselCondCode_wrk ( IS
       switch (e->Iex.Binop.op) {
       case Iop_CmpEQ32:  return mk_PPCCondCode( Pct_TRUE,  Pcf_7EQ );
       case Iop_CmpNE32:  return mk_PPCCondCode( Pct_FALSE, Pcf_7EQ );
-      case Iop_CmpLT32U: return mk_PPCCondCode( Pct_TRUE,  Pcf_7LT );
-      case Iop_CmpLE32U: return mk_PPCCondCode( Pct_FALSE, Pcf_7GT );
+      case Iop_CmpLT32U: case Iop_CmpLT32S:
+         return mk_PPCCondCode( Pct_TRUE,  Pcf_7LT );
+      case Iop_CmpLE32U: case Iop_CmpLE32S:
+         return mk_PPCCondCode( Pct_FALSE, Pcf_7GT );
       default: vpanic("iselCondCode(ppc): CmpXX32");
       }
    }
@@ -2736,8 +2753,8 @@ static void iselInt64Expr_wrk ( HReg* rH
             set_FPU_rounding_mode( env, e->Iex.Binop.arg1 );
 
             sub_from_sp( env, 16 );
-            addInstr(env, PPCInstr_FpCftI(False/*F->I*/, False/*int64*/,
-                                          ftmp, fsrc));
+            addInstr(env, PPCInstr_FpCftI(False/*F->I*/, False/*int64*/, True,
+                                          True, ftmp, fsrc));
             addInstr(env, PPCInstr_FpLdSt(False/*store*/, 8, ftmp, zero_r1));
             addInstr(env, PPCInstr_Load(4, tHi, zero_r1, False/*mode32*/));
             addInstr(env, PPCInstr_Load(4, tLo, four_r1, False/*mode32*/));
@@ -2870,6 +2887,18 @@ static void iselInt64Expr_wrk ( HReg* rH
          return;
       }
 
+      case Iop_Not64: {
+         HReg xLo, xHi;
+         HReg tmpLo = newVRegI(env);
+         HReg tmpHi = newVRegI(env);
+         iselInt64Expr(&xHi, &xLo, env, e->Iex.Unop.arg);
+         addInstr(env, PPCInstr_Unary(Pun_NOT,tmpLo,xLo));
+         addInstr(env, PPCInstr_Unary(Pun_NOT,tmpHi,xHi));
+         *rHi = tmpHi;
+         *rLo = tmpLo;
+         return;
+      }
+
       /* ReinterpF64asI64(e) */
       /* Given an IEEE754 double, produce an I64 with the same bit
          pattern. */
@@ -2931,6 +2960,8 @@ static HReg iselFltExpr ( ISelEnv* env, 
 /* DO NOT CALL THIS DIRECTLY */
 static HReg iselFltExpr_wrk ( ISelEnv* env, IRExpr* e )
 {
+   Bool        mode64 = env->mode64;
+
    IRType ty = typeOfIRExpr(env->type_env,e);
    vassert(ty == Ity_F32);
 
@@ -2999,6 +3030,60 @@ static HReg iselFltExpr_wrk ( ISelEnv* e
       return fdst;
    }
 
+   if (e->tag == Iex_Binop && e->Iex.Binop.op == Iop_I64UtoF32) {
+      if (mode64) {
+         HReg fdst = newVRegF(env);
+         HReg isrc = iselWordExpr_R(env, e->Iex.Binop.arg2);
+         HReg r1   = StackFramePtr(env->mode64);
+         PPCAMode* zero_r1 = PPCAMode_IR( 0, r1 );
+
+         /* Set host rounding mode */
+         set_FPU_rounding_mode( env, e->Iex.Binop.arg1 );
+
+         sub_from_sp( env, 16 );
+
+         addInstr(env, PPCInstr_Store(8, zero_r1, isrc, True/*mode64*/));
+         addInstr(env, PPCInstr_FpLdSt(True/*load*/, 8, fdst, zero_r1));
+         addInstr(env, PPCInstr_FpCftI(True/*I->F*/, False/*int64*/, 
+                                       False, False,
+                                       fdst, fdst));
+
+         add_to_sp( env, 16 );
+
+         ///* Restore default FPU rounding. */
+         //set_FPU_rounding_default( env );
+         return fdst;
+      } else {
+         /* 32-bit mode */
+         HReg fdst = newVRegF(env);
+         HReg isrcHi, isrcLo;
+         HReg r1   = StackFramePtr(env->mode64);
+         PPCAMode* zero_r1 = PPCAMode_IR( 0, r1 );
+         PPCAMode* four_r1 = PPCAMode_IR( 4, r1 );
+
+         iselInt64Expr(&isrcHi, &isrcLo, env, e->Iex.Binop.arg2);
+
+         /* Set host rounding mode */
+         set_FPU_rounding_mode( env, e->Iex.Binop.arg1 );
+
+         sub_from_sp( env, 16 );
+
+         addInstr(env, PPCInstr_Store(4, zero_r1, isrcHi, False/*mode32*/));
+         addInstr(env, PPCInstr_Store(4, four_r1, isrcLo, False/*mode32*/));
+         addInstr(env, PPCInstr_FpLdSt(True/*load*/, 8, fdst, zero_r1));
+         addInstr(env, PPCInstr_FpCftI(True/*I->F*/, False/*int64*/, 
+                                       False, False,
+                                       fdst, fdst));
+
+         add_to_sp( env, 16 );
+
+         ///* Restore default FPU rounding. */
+         //set_FPU_rounding_default( env );
+         return fdst;
+      }
+
+   }
+
    vex_printf("iselFltExpr(ppc): No such tag(%u)\n", e->tag);
    ppIRExpr(e);
    vpanic("iselFltExpr_wrk(ppc)");
@@ -3175,7 +3260,7 @@ static HReg iselDblExpr_wrk ( ISelEnv* e
          return r_dst;
       }
 
-      if (e->Iex.Binop.op == Iop_I64StoF64) {
+      if (e->Iex.Binop.op == Iop_I64StoF64 || e->Iex.Binop.op == Iop_I64UtoF64) {
          if (mode64) {
             HReg fdst = newVRegF(env);
             HReg isrc = iselWordExpr_R(env, e->Iex.Binop.arg2);
@@ -3190,6 +3275,8 @@ static HReg iselDblExpr_wrk ( ISelEnv* e
             addInstr(env, PPCInstr_Store(8, zero_r1, isrc, True/*mode64*/));
             addInstr(env, PPCInstr_FpLdSt(True/*load*/, 8, fdst, zero_r1));
             addInstr(env, PPCInstr_FpCftI(True/*I->F*/, False/*int64*/, 
+                                          e->Iex.Binop.op == Iop_I64StoF64,
+                                          True/*fdst is 64 bit*/,
                                           fdst, fdst));
 
             add_to_sp( env, 16 );
@@ -3216,6 +3303,8 @@ static HReg iselDblExpr_wrk ( ISelEnv* e
             addInstr(env, PPCInstr_Store(4, four_r1, isrcLo, False/*mode32*/));
             addInstr(env, PPCInstr_FpLdSt(True/*load*/, 8, fdst, zero_r1));
             addInstr(env, PPCInstr_FpCftI(True/*I->F*/, False/*int64*/, 
+                                          e->Iex.Binop.op == Iop_I64StoF64,
+                                          True/*fdst is 64 bit*/,
                                           fdst, fdst));
 
             add_to_sp( env, 16 );
@@ -3710,6 +3799,9 @@ static HReg iselVecExpr_wrk ( ISelEnv* e
       vassert(e->Iex.Const.con->tag == Ico_V128);
       if (e->Iex.Const.con->Ico.V128 == 0x0000) {
          return generate_zeroes_V128(env);
+      } 
+      else if (e->Iex.Const.con->Ico.V128 == 0xffff) {
+         return generate_ones_V128(env);
       }
    }
 
@@ -4116,10 +4208,10 @@ HInstrArray* iselSB_PPC ( IRSB* bb, VexA
 
    /* do some sanity checks */
    mask32 = VEX_HWCAPS_PPC32_F | VEX_HWCAPS_PPC32_V
-            | VEX_HWCAPS_PPC32_FX | VEX_HWCAPS_PPC32_GX;
+            | VEX_HWCAPS_PPC32_FX | VEX_HWCAPS_PPC32_GX | VEX_HWCAPS_PPC32_VX;
 
-   mask64 = VEX_HWCAPS_PPC64_V
-            | VEX_HWCAPS_PPC64_FX | VEX_HWCAPS_PPC64_GX;
+   mask64 = VEX_HWCAPS_PPC64_V | VEX_HWCAPS_PPC64_FX
+	   | VEX_HWCAPS_PPC64_GX | VEX_HWCAPS_PPC64_VX;
 
    if (mode64) {
       vassert((hwcaps_host & mask32) == 0);
--- valgrind-3.6.0/VEX/pub/libvex.h	(revision 2126)
+++ valgrind-3.6.0/VEX/pub/libvex.h	(revision 2127)
@@ -87,12 +87,14 @@ typedef 
 #define VEX_HWCAPS_PPC32_FX    (1<<10) /* FP extns (fsqrt, fsqrts) */
 #define VEX_HWCAPS_PPC32_GX    (1<<11) /* Graphics extns
                                           (fres,frsqrte,fsel,stfiwx) */
+#define VEX_HWCAPS_PPC32_VX    (1<<12) /* Vector-scalar floating-point (VSX); implies ISA 2.06 or higher  */
 
 /* ppc64: baseline capability is integer and basic FP insns */
-#define VEX_HWCAPS_PPC64_V     (1<<12) /* Altivec (VMX) */
-#define VEX_HWCAPS_PPC64_FX    (1<<13) /* FP extns (fsqrt, fsqrts) */
-#define VEX_HWCAPS_PPC64_GX    (1<<14) /* Graphics extns
+#define VEX_HWCAPS_PPC64_V     (1<<13) /* Altivec (VMX) */
+#define VEX_HWCAPS_PPC64_FX    (1<<14) /* FP extns (fsqrt, fsqrts) */
+#define VEX_HWCAPS_PPC64_GX    (1<<15) /* Graphics extns
                                           (fres,frsqrte,fsel,stfiwx) */
+#define VEX_HWCAPS_PPC64_VX    (1<<16) /* Vector-scalar floating-point (VSX); implies ISA 2.06 or higher  */
 
 /* s390x: baseline capability is z/Architecture with long displacement */
 #define VEX_HWCAPS_S390X_LDISP (1<<13)  /* Long-displacement facility */
--- valgrind-3.6.0/VEX/pub/libvex_guest_ppc64.h	(revision 2126)
+++ valgrind-3.6.0/VEX/pub/libvex_guest_ppc64.h	(revision 2127)
@@ -120,123 +120,131 @@ typedef
       /* 240 */ ULong guest_GPR30;
       /* 248 */ ULong guest_GPR31;
 
-      // Floating Point Registers
-      /* 256 */ ULong guest_FPR0;
-      /* 264 */ ULong guest_FPR1;
-      /* 272 */ ULong guest_FPR2;
-      /* 280 */ ULong guest_FPR3;
-      /* 288 */ ULong guest_FPR4;
-      /* 296 */ ULong guest_FPR5;
-      /* 304 */ ULong guest_FPR6;
-      /* 312 */ ULong guest_FPR7;
-      /* 320 */ ULong guest_FPR8;
-      /* 328 */ ULong guest_FPR9;
-      /* 336 */ ULong guest_FPR10;
-      /* 344 */ ULong guest_FPR11;
-      /* 352 */ ULong guest_FPR12;
-      /* 360 */ ULong guest_FPR13;
-      /* 368 */ ULong guest_FPR14;
-      /* 376 */ ULong guest_FPR15;
-      /* 384 */ ULong guest_FPR16;
-      /* 392 */ ULong guest_FPR17;
-      /* 400 */ ULong guest_FPR18;
-      /* 408 */ ULong guest_FPR19;
-      /* 416 */ ULong guest_FPR20;
-      /* 424 */ ULong guest_FPR21;
-      /* 432 */ ULong guest_FPR22;
-      /* 440 */ ULong guest_FPR23;
-      /* 448 */ ULong guest_FPR24;
-      /* 456 */ ULong guest_FPR25;
-      /* 464 */ ULong guest_FPR26;
-      /* 472 */ ULong guest_FPR27;
-      /* 480 */ ULong guest_FPR28;
-      /* 488 */ ULong guest_FPR29;
-      /* 496 */ ULong guest_FPR30;
-      /* 504 */ ULong guest_FPR31;
+      // Vector Registers, Floating Point Registers, and VSX Registers
+      // With ISA 2.06, the "Vector-Scalar Floating-point" category
+      // provides facilities to support vector and scalar binary floating-
+      // point operations.  A unified register file is an integral part
+      // of this new facility, combining floating point and vector registers
+      // using a 64x128-bit vector.  These are referred to as VSR[0..63].
+      // The floating point registers are now mapped into double word element 0
+      // of VSR[0..31]. The 32x128-bit vector registers defined by the "Vector
+      // Facility [Category: Vector]" are now mapped to VSR[32..63].
 
-      // Vector Registers
       // IMPORTANT: the user of libvex must place the guest state so as
-      // to ensure that guest_VR{0..31}, and any shadows thereof, are
+      // to ensure that guest_VSR{0..63}, and any shadows thereof, are
       // 16-aligned.
-      /*  512 */ U128 guest_VR0;
-      /*  528 */ U128 guest_VR1;
-      /*  544 */ U128 guest_VR2;
-      /*  560 */ U128 guest_VR3;
-      /*  576 */ U128 guest_VR4;
-      /*  592 */ U128 guest_VR5;
-      /*  608 */ U128 guest_VR6;
-      /*  624 */ U128 guest_VR7;
-      /*  640 */ U128 guest_VR8;
-      /*  656 */ U128 guest_VR9;
-      /*  672 */ U128 guest_VR10;
-      /*  688 */ U128 guest_VR11;
-      /*  704 */ U128 guest_VR12;
-      /*  720 */ U128 guest_VR13;
-      /*  736 */ U128 guest_VR14;
-      /*  752 */ U128 guest_VR15;
-      /*  768 */ U128 guest_VR16;
-      /*  784 */ U128 guest_VR17;
-      /*  800 */ U128 guest_VR18;
-      /*  816 */ U128 guest_VR19;
-      /*  832 */ U128 guest_VR20;
-      /*  848 */ U128 guest_VR21;
-      /*  864 */ U128 guest_VR22;
-      /*  880 */ U128 guest_VR23;
-      /*  896 */ U128 guest_VR24;
-      /*  912 */ U128 guest_VR25;
-      /*  928 */ U128 guest_VR26;
-      /*  944 */ U128 guest_VR27;
-      /*  960 */ U128 guest_VR28;
-      /*  976 */ U128 guest_VR29;
-      /*  992 */ U128 guest_VR30;
-      /* 1008 */ U128 guest_VR31;
-
-      /* 1024 */ ULong guest_CIA;    // IP (no arch visible register)
-      /* 1032 */ ULong guest_LR;     // Link Register
-      /* 1040 */ ULong guest_CTR;    // Count Register
+
+      /*  256 */ U128 guest_VSR0;
+      /*  272 */ U128 guest_VSR1;
+      /*  288 */ U128 guest_VSR2;
+      /*  304 */ U128 guest_VSR3;
+      /*  320 */ U128 guest_VSR4;
+      /*  336 */ U128 guest_VSR5;
+      /*  352 */ U128 guest_VSR6;
+      /*  368 */ U128 guest_VSR7;
+      /*  384 */ U128 guest_VSR8;
+      /*  400 */ U128 guest_VSR9;
+      /*  416 */ U128 guest_VSR10;
+      /*  432 */ U128 guest_VSR11;
+      /*  448 */ U128 guest_VSR12;
+      /*  464 */ U128 guest_VSR13;
+      /*  480 */ U128 guest_VSR14;
+      /*  496 */ U128 guest_VSR15;
+      /*  512 */ U128 guest_VSR16;
+      /*  528 */ U128 guest_VSR17;
+      /*  544 */ U128 guest_VSR18;
+      /*  560 */ U128 guest_VSR19;
+      /*  576 */ U128 guest_VSR20;
+      /*  592 */ U128 guest_VSR21;
+      /*  608 */ U128 guest_VSR22;
+      /*  624 */ U128 guest_VSR23;
+      /*  640 */ U128 guest_VSR24;
+      /*  656 */ U128 guest_VSR25;
+      /*  672 */ U128 guest_VSR26;
+      /*  688 */ U128 guest_VSR27;
+      /*  704 */ U128 guest_VSR28;
+      /*  720 */ U128 guest_VSR29;
+      /*  736 */ U128 guest_VSR30;
+      /*  752 */ U128 guest_VSR31;
+      /*  768 */ U128 guest_VSR32;
+      /*  784 */ U128 guest_VSR33;
+      /*  800 */ U128 guest_VSR34;
+      /*  816 */ U128 guest_VSR35;
+      /*  832 */ U128 guest_VSR36;
+      /*  848 */ U128 guest_VSR37;
+      /*  864 */ U128 guest_VSR38;
+      /*  880 */ U128 guest_VSR39;
+      /*  896 */ U128 guest_VSR40;
+      /*  912 */ U128 guest_VSR41;
+      /*  928 */ U128 guest_VSR42;
+      /*  944 */ U128 guest_VSR43;
+      /*  960 */ U128 guest_VSR44;
+      /*  976 */ U128 guest_VSR45;
+      /*  992 */ U128 guest_VSR46;
+      /* 1008 */ U128 guest_VSR47;
+      /* 1024 */ U128 guest_VSR48;
+      /* 1040 */ U128 guest_VSR49;
+      /* 1056 */ U128 guest_VSR50;
+      /* 1072 */ U128 guest_VSR51;
+      /* 1088 */ U128 guest_VSR52;
+      /* 1104 */ U128 guest_VSR53;
+      /* 1120 */ U128 guest_VSR54;
+      /* 1136 */ U128 guest_VSR55;
+      /* 1152 */ U128 guest_VSR56;
+      /* 1168 */ U128 guest_VSR57;
+      /* 1184 */ U128 guest_VSR58;
+      /* 1200 */ U128 guest_VSR59;
+      /* 1216 */ U128 guest_VSR60;
+      /* 1232 */ U128 guest_VSR61;
+      /* 1248 */ U128 guest_VSR62;
+      /* 1264 */ U128 guest_VSR63;
+
+      /* 1280 */ ULong guest_CIA;    // IP (no arch visible register)
+      /* 1288 */ ULong guest_LR;     // Link Register
+      /* 1296 */ ULong guest_CTR;    // Count Register
 
       /* XER pieces */
-      /* 1048 */ UChar guest_XER_SO; /* in lsb */
-      /* 1049 */ UChar guest_XER_OV; /* in lsb */
-      /* 1050 */ UChar guest_XER_CA; /* in lsb */
-      /* 1051 */ UChar guest_XER_BC; /* all bits */
+      /* 1304 */ UChar guest_XER_SO; /* in lsb */
+      /* 1305 */ UChar guest_XER_OV; /* in lsb */
+      /* 1306 */ UChar guest_XER_CA; /* in lsb */
+      /* 1307 */ UChar guest_XER_BC; /* all bits */
 
       /* CR pieces */
-      /* 1052 */ UChar guest_CR0_321; /* in [3:1] */
-      /* 1053 */ UChar guest_CR0_0;   /* in lsb */
-      /* 1054 */ UChar guest_CR1_321; /* in [3:1] */
-      /* 1055 */ UChar guest_CR1_0;   /* in lsb */
-      /* 1056 */ UChar guest_CR2_321; /* in [3:1] */
-      /* 1057 */ UChar guest_CR2_0;   /* in lsb */
-      /* 1058 */ UChar guest_CR3_321; /* in [3:1] */
-      /* 1059 */ UChar guest_CR3_0;   /* in lsb */
-      /* 1060 */ UChar guest_CR4_321; /* in [3:1] */
-      /* 1061 */ UChar guest_CR4_0;   /* in lsb */
-      /* 1062 */ UChar guest_CR5_321; /* in [3:1] */
-      /* 1063 */ UChar guest_CR5_0;   /* in lsb */
-      /* 1064 */ UChar guest_CR6_321; /* in [3:1] */
-      /* 1065 */ UChar guest_CR6_0;   /* in lsb */
-      /* 1066 */ UChar guest_CR7_321; /* in [3:1] */
-      /* 1067 */ UChar guest_CR7_0;   /* in lsb */
+      /* 1308 */ UChar guest_CR0_321; /* in [3:1] */
+      /* 1309 */ UChar guest_CR0_0;   /* in lsb */
+      /* 1310 */ UChar guest_CR1_321; /* in [3:1] */
+      /* 1311 */ UChar guest_CR1_0;   /* in lsb */
+      /* 1312 */ UChar guest_CR2_321; /* in [3:1] */
+      /* 1313 */ UChar guest_CR2_0;   /* in lsb */
+      /* 1314 */ UChar guest_CR3_321; /* in [3:1] */
+      /* 1315 */ UChar guest_CR3_0;   /* in lsb */
+      /* 1316 */ UChar guest_CR4_321; /* in [3:1] */
+      /* 1317 */ UChar guest_CR4_0;   /* in lsb */
+      /* 1318 */ UChar guest_CR5_321; /* in [3:1] */
+      /* 1319 */ UChar guest_CR5_0;   /* in lsb */
+      /* 1320 */ UChar guest_CR6_321; /* in [3:1] */
+      /* 1321 */ UChar guest_CR6_0;   /* in lsb */
+      /* 1322 */ UChar guest_CR7_321; /* in [3:1] */
+      /* 1323 */ UChar guest_CR7_0;   /* in lsb */
 
       /* FP Status & Control Register fields */
-      /* 1068 */ UInt guest_FPROUND; // FP Rounding Mode
+      /* 1324 */ UInt guest_FPROUND; // FP Rounding Mode
 
       /* Vector Save/Restore Register */
-      /* 1072 */ UInt guest_VRSAVE;
+      /* 1328 */ UInt guest_VRSAVE;
 
       /* Vector Status and Control Register */
-      /* 1076 */ UInt guest_VSCR;
+      /* 1332 */ UInt guest_VSCR;
 
       /* Emulation warnings */
-      /* 1080 */ UInt guest_EMWARN;
+      /* 1336 */ UInt guest_EMWARN;
 
       /* gcc adds 4 bytes padding here: pre-empt it. */
-      /* 1084 */ UInt  padding;
+      /* 1340 */ UInt  padding;
 
       /* For icbi: record start and length of area to invalidate */
-      /* 1088 */ ULong guest_TISTART;
-      /* 1096 */ ULong guest_TILEN;
+      /* 1344 */ ULong guest_TISTART;
+      /* 1352 */ ULong guest_TILEN;
 
       /* Used to record the unredirected guest address at the start of
          a translation whose start has been redirected.  By reading
@@ -244,26 +252,26 @@ typedef
          find out what the corresponding no-redirection address was.
          Note, this is only set for wrap-style redirects, not for
          replace-style ones. */
-      /* 1104 */ ULong guest_NRADDR;
-      /* 1112 */ ULong guest_NRADDR_GPR2;
+      /* 1360 */ ULong guest_NRADDR;
+      /* 1368 */ ULong guest_NRADDR_GPR2;
 
      /* A grows-upwards stack for hidden saves/restores of LR and R2
         needed for function interception and wrapping on ppc64-linux.
         A horrible hack.  REDIR_SP points to the highest live entry,
         and so starts at -1. */
-      /* 1120 */ ULong guest_REDIR_SP;
-      /* 1128 */ ULong guest_REDIR_STACK[VEX_GUEST_PPC64_REDIR_STACK_SIZE];
+      /* 1376 */ ULong guest_REDIR_SP;
+      /* 1384 */ ULong guest_REDIR_STACK[VEX_GUEST_PPC64_REDIR_STACK_SIZE];
 
       /* Needed for AIX: CIA at the last SC insn.  Used when backing up
          to restart a syscall that has been interrupted by a signal. */
-      /* 1384 */ ULong guest_IP_AT_SYSCALL; 
+      /* 1640 */ ULong guest_IP_AT_SYSCALL;
 
       /* SPRG3, which AIUI is readonly in user space.  Needed for
          threading on AIX. */
-      /* ???? */ ULong guest_SPRG3_RO;
+      /* 1648 */ ULong guest_SPRG3_RO;
 
-      /* Padding to make it have an 8-aligned size */
-      /* ???? */ ULong padding2;
+      /* Padding to make it have an 16-aligned size */
+      /* 1656 */ ULong padding2;
    }
    VexGuestPPC64State;
 
--- valgrind-3.6.0/VEX/pub/libvex_ir.h	(revision 2126)
+++ valgrind-3.6.0/VEX/pub/libvex_ir.h	(revision 2127)
@@ -617,6 +617,8 @@ typedef
       Iop_I16StoF64, /*                       signed I16 -> F64 */
       Iop_I32StoF64, /*                       signed I32 -> F64 */
       Iop_I64StoF64, /* IRRoundingMode(I32) x signed I64 -> F64 */
+      Iop_I64UtoF64, /* IRRoundingMode(I32) x unsigned I64 -> F64 */
+      Iop_I64UtoF32, /* IRRoundingMode(I32) x unsigned I64 -> F32 */
 
       Iop_I32UtoF64, /*                       unsigned I32 -> F64 */
 
--- valgrind-3.6.0/VEX/pub/libvex_guest_ppc32.h	(revision 2126)
+++ valgrind-3.6.0/VEX/pub/libvex_guest_ppc32.h	(revision 2127)
@@ -82,120 +82,128 @@ typedef
       /* 120 */ UInt guest_GPR30;
       /* 124 */ UInt guest_GPR31;
 
-      // Floating Point Registers
-      /* 128 */ ULong guest_FPR0;
-      /* 136 */ ULong guest_FPR1;
-      /* 144 */ ULong guest_FPR2;
-      /* 152 */ ULong guest_FPR3;
-      /* 160 */ ULong guest_FPR4;
-      /* 168 */ ULong guest_FPR5;
-      /* 176 */ ULong guest_FPR6;
-      /* 184 */ ULong guest_FPR7;
-      /* 192 */ ULong guest_FPR8;
-      /* 200 */ ULong guest_FPR9;
-      /* 208 */ ULong guest_FPR10;
-      /* 216 */ ULong guest_FPR11;
-      /* 224 */ ULong guest_FPR12;
-      /* 232 */ ULong guest_FPR13;
-      /* 240 */ ULong guest_FPR14;
-      /* 248 */ ULong guest_FPR15;
-      /* 256 */ ULong guest_FPR16;
-      /* 264 */ ULong guest_FPR17;
-      /* 272 */ ULong guest_FPR18;
-      /* 280 */ ULong guest_FPR19;
-      /* 288 */ ULong guest_FPR20;
-      /* 296 */ ULong guest_FPR21;
-      /* 304 */ ULong guest_FPR22;
-      /* 312 */ ULong guest_FPR23;
-      /* 320 */ ULong guest_FPR24;
-      /* 328 */ ULong guest_FPR25;
-      /* 336 */ ULong guest_FPR26;
-      /* 344 */ ULong guest_FPR27;
-      /* 352 */ ULong guest_FPR28;
-      /* 360 */ ULong guest_FPR29;
-      /* 368 */ ULong guest_FPR30;
-      /* 376 */ ULong guest_FPR31;
+      // Vector Registers, Floating Point Registers, and VSX Registers
+      // With ISA 2.06, the "Vector-Scalar Floating-point" category
+      // provides facilities to support vector and scalar binary floating-
+      // point operations.  A unified register file is an integral part
+      // of this new facility, combining floating point and vector registers
+      // using a 64x128-bit vector.  These are referred to as VSR[0..63].
+      // The floating point registers are now mapped into double word element 0
+      // of VSR[0..31]. The 32x128-bit vector registers defined by the "Vector
+      // Facility [Category: Vector]" are now mapped to VSR[32..63].
 
-      // Vector Registers
       // IMPORTANT: the user of libvex must place the guest state so as
-      // to ensure that guest_VR{0..31}, and any shadows thereof, are
+      // to ensure that guest_VSR{0..63}, and any shadows thereof, are
       // 16-aligned.
-      /* 384 */ U128 guest_VR0;
-      /* 400 */ U128 guest_VR1;
-      /* 416 */ U128 guest_VR2;
-      /* 432 */ U128 guest_VR3;
-      /* 448 */ U128 guest_VR4;
-      /* 464 */ U128 guest_VR5;
-      /* 480 */ U128 guest_VR6;
-      /* 496 */ U128 guest_VR7;
-      /* 512 */ U128 guest_VR8;
-      /* 528 */ U128 guest_VR9;
-      /* 544 */ U128 guest_VR10;
-      /* 560 */ U128 guest_VR11;
-      /* 576 */ U128 guest_VR12;
-      /* 592 */ U128 guest_VR13;
-      /* 608 */ U128 guest_VR14;
-      /* 624 */ U128 guest_VR15;
-      /* 640 */ U128 guest_VR16;
-      /* 656 */ U128 guest_VR17;
-      /* 672 */ U128 guest_VR18;
-      /* 688 */ U128 guest_VR19;
-      /* 704 */ U128 guest_VR20;
-      /* 720 */ U128 guest_VR21;
-      /* 736 */ U128 guest_VR22;
-      /* 752 */ U128 guest_VR23;
-      /* 768 */ U128 guest_VR24;
-      /* 784 */ U128 guest_VR25;
-      /* 800 */ U128 guest_VR26;
-      /* 816 */ U128 guest_VR27;
-      /* 832 */ U128 guest_VR28;
-      /* 848 */ U128 guest_VR29;
-      /* 864 */ U128 guest_VR30;
-      /* 880 */ U128 guest_VR31;
-
-      /* 896 */ UInt guest_CIA;    // IP (no arch visible register)
-      /* 900 */ UInt guest_LR;     // Link Register
-      /* 904 */ UInt guest_CTR;    // Count Register
+
+      /*  128 */ U128 guest_VSR0;
+      /*  144 */ U128 guest_VSR1;
+      /*  160 */ U128 guest_VSR2;
+      /*  176 */ U128 guest_VSR3;
+      /*  192 */ U128 guest_VSR4;
+      /*  208 */ U128 guest_VSR5;
+      /*  224 */ U128 guest_VSR6;
+      /*  240 */ U128 guest_VSR7;
+      /*  256 */ U128 guest_VSR8;
+      /*  272 */ U128 guest_VSR9;
+      /*  288 */ U128 guest_VSR10;
+      /*  304 */ U128 guest_VSR11;
+      /*  320 */ U128 guest_VSR12;
+      /*  336 */ U128 guest_VSR13;
+      /*  352 */ U128 guest_VSR14;
+      /*  368 */ U128 guest_VSR15;
+      /*  384 */ U128 guest_VSR16;
+      /*  400 */ U128 guest_VSR17;
+      /*  416 */ U128 guest_VSR18;
+      /*  432 */ U128 guest_VSR19;
+      /*  448 */ U128 guest_VSR20;
+      /*  464 */ U128 guest_VSR21;
+      /*  480 */ U128 guest_VSR22;
+      /*  496 */ U128 guest_VSR23;
+      /*  512 */ U128 guest_VSR24;
+      /*  528 */ U128 guest_VSR25;
+      /*  544 */ U128 guest_VSR26;
+      /*  560 */ U128 guest_VSR27;
+      /*  576 */ U128 guest_VSR28;
+      /*  592 */ U128 guest_VSR29;
+      /*  608 */ U128 guest_VSR30;
+      /*  624 */ U128 guest_VSR31;
+      /*  640 */ U128 guest_VSR32;
+      /*  656 */ U128 guest_VSR33;
+      /*  672 */ U128 guest_VSR34;
+      /*  688 */ U128 guest_VSR35;
+      /*  704 */ U128 guest_VSR36;
+      /*  720 */ U128 guest_VSR37;
+      /*  736 */ U128 guest_VSR38;
+      /*  752 */ U128 guest_VSR39;
+      /*  768 */ U128 guest_VSR40;
+      /*  784 */ U128 guest_VSR41;
+      /*  800 */ U128 guest_VSR42;
+      /*  816 */ U128 guest_VSR43;
+      /*  832 */ U128 guest_VSR44;
+      /*  848 */ U128 guest_VSR45;
+      /*  864 */ U128 guest_VSR46;
+      /*  880 */ U128 guest_VSR47;
+      /*  896 */ U128 guest_VSR48;
+      /*  912 */ U128 guest_VSR49;
+      /*  928 */ U128 guest_VSR50;
+      /*  944 */ U128 guest_VSR51;
+      /*  960 */ U128 guest_VSR52;
+      /*  976 */ U128 guest_VSR53;
+      /*  992 */ U128 guest_VSR54;
+      /* 1008 */ U128 guest_VSR55;
+      /* 1024 */ U128 guest_VSR56;
+      /* 1040 */ U128 guest_VSR57;
+      /* 1056 */ U128 guest_VSR58;
+      /* 1072 */ U128 guest_VSR59;
+      /* 1088 */ U128 guest_VSR60;
+      /* 1104 */ U128 guest_VSR61;
+      /* 1120 */ U128 guest_VSR62;
+      /* 1136 */ U128 guest_VSR63;
+
+      /* 1152 */ UInt guest_CIA;    // IP (no arch visible register)
+      /* 1156 */ UInt guest_LR;     // Link Register
+      /* 1160 */ UInt guest_CTR;    // Count Register
 
       /* XER pieces */
-      /* 908 */ UChar guest_XER_SO; /* in lsb */
-      /* 909 */ UChar guest_XER_OV; /* in lsb */
-      /* 910 */ UChar guest_XER_CA; /* in lsb */
-      /* 911 */ UChar guest_XER_BC; /* all bits */
+      /* 1164 */ UChar guest_XER_SO; /* in lsb */
+      /* 1165 */ UChar guest_XER_OV; /* in lsb */
+      /* 1166 */ UChar guest_XER_CA; /* in lsb */
+      /* 1167 */ UChar guest_XER_BC; /* all bits */
 
       /* CR pieces */
-      /* 912 */ UChar guest_CR0_321; /* in [3:1] */
-      /* 913 */ UChar guest_CR0_0;   /* in lsb */
-      /* 914 */ UChar guest_CR1_321; /* in [3:1] */
-      /* 915 */ UChar guest_CR1_0;   /* in lsb */
-      /* 916 */ UChar guest_CR2_321; /* in [3:1] */
-      /* 917 */ UChar guest_CR2_0;   /* in lsb */
-      /* 918 */ UChar guest_CR3_321; /* in [3:1] */
-      /* 919 */ UChar guest_CR3_0;   /* in lsb */
-      /* 920 */ UChar guest_CR4_321; /* in [3:1] */
-      /* 921 */ UChar guest_CR4_0;   /* in lsb */
-      /* 922 */ UChar guest_CR5_321; /* in [3:1] */
-      /* 923 */ UChar guest_CR5_0;   /* in lsb */
-      /* 924 */ UChar guest_CR6_321; /* in [3:1] */
-      /* 925 */ UChar guest_CR6_0;   /* in lsb */
-      /* 926 */ UChar guest_CR7_321; /* in [3:1] */
-      /* 927 */ UChar guest_CR7_0;   /* in lsb */
+      /* 1168 */ UChar guest_CR0_321; /* in [3:1] */
+      /* 1169 */ UChar guest_CR0_0;   /* in lsb */
+      /* 1170 */ UChar guest_CR1_321; /* in [3:1] */
+      /* 1171 */ UChar guest_CR1_0;   /* in lsb */
+      /* 1172 */ UChar guest_CR2_321; /* in [3:1] */
+      /* 1173 */ UChar guest_CR2_0;   /* in lsb */
+      /* 1174 */ UChar guest_CR3_321; /* in [3:1] */
+      /* 1175 */ UChar guest_CR3_0;   /* in lsb */
+      /* 1176 */ UChar guest_CR4_321; /* in [3:1] */
+      /* 1177 */ UChar guest_CR4_0;   /* in lsb */
+      /* 1178 */ UChar guest_CR5_321; /* in [3:1] */
+      /* 1179 */ UChar guest_CR5_0;   /* in lsb */
+      /* 1180 */ UChar guest_CR6_321; /* in [3:1] */
+      /* 1181 */ UChar guest_CR6_0;   /* in lsb */
+      /* 1182 */ UChar guest_CR7_321; /* in [3:1] */
+      /* 1183 */ UChar guest_CR7_0;   /* in lsb */
 
       /* FP Status & Control Register fields */
-      /* 928 */ UInt guest_FPROUND; // FP Rounding Mode
+      /* 1184 */ UInt guest_FPROUND; // FP Rounding Mode
 
       /* Vector Save/Restore Register */
-      /* 932 */ UInt guest_VRSAVE;
+      /* 1188 */ UInt guest_VRSAVE;
 
       /* Vector Status and Control Register */
-      /* 936 */ UInt guest_VSCR;
+      /* 1192 */ UInt guest_VSCR;
 
       /* Emulation warnings */
-      /* 940 */ UInt guest_EMWARN;
+      /* 1196 */ UInt guest_EMWARN;
 
       /* For icbi: record start and length of area to invalidate */
-      /* 944 */ UInt guest_TISTART;
-      /* 948 */ UInt guest_TILEN;
+      /* 1200 */ UInt guest_TISTART;
+      /* 1204 */ UInt guest_TILEN;
 
       /* Used to record the unredirected guest address at the start of
          a translation whose start has been redirected.  By reading
@@ -203,27 +211,27 @@ typedef
          find out what the corresponding no-redirection address was.
          Note, this is only set for wrap-style redirects, not for
          replace-style ones. */
-      /* 952 */ UInt guest_NRADDR;
-      /* 956 */ UInt guest_NRADDR_GPR2; /* needed by aix */
+      /* 1208 */ UInt guest_NRADDR;
+      /* 1212 */ UInt guest_NRADDR_GPR2; /* needed by aix */
 
      /* A grows-upwards stack for hidden saves/restores of LR and R2
         needed for function interception and wrapping on ppc32-aix5.
         A horrible hack.  REDIR_SP points to the highest live entry,
         and so starts at -1. */
-      /* 960 */ UInt guest_REDIR_SP;
-      /* 964 */ UInt guest_REDIR_STACK[VEX_GUEST_PPC32_REDIR_STACK_SIZE];
+      /* 1216 */ UInt guest_REDIR_SP;
+      /* 1220 */ UInt guest_REDIR_STACK[VEX_GUEST_PPC32_REDIR_STACK_SIZE];
 
       /* Needed for AIX (but mandated for all guest architectures):
          CIA at the last SC insn.  Used when backing up to restart a
          syscall that has been interrupted by a signal. */
-      /* ??? */ UInt guest_IP_AT_SYSCALL; 
+      /* 1348 */ UInt guest_IP_AT_SYSCALL;
 
       /* SPRG3, which AIUI is readonly in user space.  Needed for
          threading on AIX. */
-      /* ??? */ UInt guest_SPRG3_RO;
+      /* 1352 */ UInt guest_SPRG3_RO;
 
       /* Padding to make it have an 8-aligned size */
-      /* UInt  padding; */
+      /* 1356 */ UInt  padding;
    }
    VexGuestPPC32State;
 
--- valgrind-3.6.0/configure.jj	2011-08-01 15:45:51.000000000 +0200
+++ valgrind-3.6.0/configure	2011-08-01 18:44:21.184059000 +0200
@@ -649,6 +649,8 @@ FLAG_MAIX32
 FLAG_M32
 HAVE_PTHREAD_CREATE_GLIBC_2_0_FALSE
 HAVE_PTHREAD_CREATE_GLIBC_2_0_TRUE
+HAS_VSX_FALSE
+HAS_VSX_TRUE
 HAS_ALTIVEC_FALSE
 HAS_ALTIVEC_TRUE
 GLIBC_VERSION
@@ -6751,6 +6753,62 @@ fi
 
 
 
+# Check that both: the compiler supports -mvsx and that the assembler
+# understands VSX instructions.  If either of those doesn't work,
+# conclude that we can't do VSX.  NOTE: basically this is a kludge
+# in that it conflates two things that should be separate -- whether
+# the compiler understands the flag vs whether the assembler
+# understands the opcodes.  This really ought to be cleaned up
+# and done properly, like it is for x86/x86_64.
+
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for VSX" >&5
+$as_echo_n "checking for VSX... " >&6; }
+
+safe_CFLAGS=$CFLAGS
+CFLAGS="-mvsx"
+
+cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+
+#include <altivec.h>
+
+int
+main ()
+{
+
+  vector unsigned int v;
+  __asm__ __volatile__("xsmaddadp 32, 32, 33" ::: "memory","cc");
+
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_compile "$LINENO"; then :
+
+ac_have_vsx=yes
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: yes" >&5
+$as_echo "yes" >&6; }
+
+else
+
+ac_have_vsx=no
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+$as_echo "no" >&6; }
+
+fi
+rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+CFLAGS=$safe_CFLAGS
+
+ if test x$ac_have_vsx = xyes; then
+  HAS_VSX_TRUE=
+  HAS_VSX_FALSE='#'
+else
+  HAS_VSX_TRUE='#'
+  HAS_VSX_FALSE=
+fi
+
+
+
 # Check for pthread_create@GLIBC2.0
 { $as_echo "$as_me:${as_lineno-$LINENO}: checking for pthread_create@GLIBC2.0()" >&5
 $as_echo_n "checking for pthread_create@GLIBC2.0()... " >&6; }
@@ -9430,6 +9488,10 @@ if test -z "${HAS_ALTIVEC_TRUE}" && test
   as_fn_error "conditional \"HAS_ALTIVEC\" was never defined.
 Usually this means the macro was only invoked conditionally." "$LINENO" 5
 fi
+if test -z "${HAS_VSX_TRUE}" && test -z "${HAS_VSX_FALSE}"; then
+  as_fn_error "conditional \"HAS_VSX\" was never defined.
+Usually this means the macro was only invoked conditionally." "$LINENO" 5
+fi
 if test -z "${HAVE_PTHREAD_CREATE_GLIBC_2_0_TRUE}" && test -z "${HAVE_PTHREAD_CREATE_GLIBC_2_0_FALSE}"; then
   as_fn_error "conditional \"HAVE_PTHREAD_CREATE_GLIBC_2_0\" was never defined.
 Usually this means the macro was only invoked conditionally." "$LINENO" 5
--- valgrind-3.6.0/none/tests/ppc32/Makefile.in.jj	2011-08-01 15:45:52.195655000 +0200
+++ valgrind-3.6.0/none/tests/ppc32/Makefile.in	2011-08-01 18:46:16.570993000 +0200
@@ -51,7 +51,8 @@ check_PROGRAMS = bug129390-ppc32$(EXEEXT
 	mftocrf$(EXEEXT) mcrfs$(EXEEXT) round$(EXEEXT) \
 	test_fx$(EXEEXT) test_gx$(EXEEXT) testVMX$(EXEEXT) \
 	twi$(EXEEXT) tw$(EXEEXT) xlc_dbl_u32$(EXEEXT) \
-	power5+_round$(EXEEXT) power6_bcmp$(EXEEXT)
+	power5+_round$(EXEEXT) power6_bcmp$(EXEEXT) \
+	test_isa_2_06_part1$(EXEEXT)
 subdir = none/tests/ppc32
 ACLOCAL_M4 = $(top_srcdir)/aclocal.m4
 am__aclocal_m4_deps = $(top_srcdir)/configure.in
@@ -104,6 +105,12 @@ test_fx_LDADD = $(LDADD)
 test_gx_SOURCES = test_gx.c
 test_gx_OBJECTS = test_gx.$(OBJEXT)
 test_gx_LDADD = $(LDADD)
+test_isa_2_06_part1_SOURCES = test_isa_2_06_part1.c
+test_isa_2_06_part1_OBJECTS =  \
+	test_isa_2_06_part1-test_isa_2_06_part1.$(OBJEXT)
+test_isa_2_06_part1_LDADD = $(LDADD)
+test_isa_2_06_part1_LINK = $(CCLD) $(test_isa_2_06_part1_CFLAGS) \
+	$(CFLAGS) $(AM_LDFLAGS) $(LDFLAGS) -o $@
 tw_SOURCES = tw.c
 tw_OBJECTS = tw.$(OBJEXT)
 tw_LDADD = $(LDADD)
@@ -124,11 +131,12 @@ CCLD = $(CC)
 LINK = $(CCLD) $(AM_CFLAGS) $(CFLAGS) $(AM_LDFLAGS) $(LDFLAGS) -o $@
 SOURCES = bug129390-ppc32.c bug139050-ppc32.c jm-insns.c ldstrev.c \
 	lsw.c mcrfs.c mftocrf.c power5+_round.c power6_bcmp.c round.c \
-	testVMX.c test_fx.c test_gx.c tw.c twi.c xlc_dbl_u32.c
+	testVMX.c test_fx.c test_gx.c test_isa_2_06_part1.c tw.c twi.c \
+	xlc_dbl_u32.c
 DIST_SOURCES = bug129390-ppc32.c bug139050-ppc32.c jm-insns.c \
 	ldstrev.c lsw.c mcrfs.c mftocrf.c power5+_round.c \
-	power6_bcmp.c round.c testVMX.c test_fx.c test_gx.c tw.c twi.c \
-	xlc_dbl_u32.c
+	power6_bcmp.c round.c testVMX.c test_fx.c test_gx.c \
+	test_isa_2_06_part1.c tw.c twi.c xlc_dbl_u32.c
 ETAGS = etags
 CTAGS = ctags
 DISTFILES = $(DIST_COMMON) $(DIST_SOURCES) $(TEXINFOS) $(EXTRA_DIST)
@@ -437,16 +445,24 @@ EXTRA_DIST = \
 	tw.stderr.exp tw.stdout.exp tw.vgtest \
 	xlc_dbl_u32.stderr.exp xlc_dbl_u32.stdout.exp xlc_dbl_u32.vgtest \
 	power5+_round.stderr.exp power5+_round.stdout.exp power5+_round.vgtest \
-	power6_bcmp.stderr.exp power6_bcmp.stdout.exp power6_bcmp.vgtest
+	power6_bcmp.stderr.exp power6_bcmp.stdout.exp power6_bcmp.vgtest \
+	test_isa_2_06_part1.stderr.exp  test_isa_2_06_part1.stdout.exp  test_isa_2_06_part1.vgtest
 
 @HAS_ALTIVEC_FALSE@ALTIVEC_FLAG = 
 @HAS_ALTIVEC_TRUE@ALTIVEC_FLAG = -DHAS_ALTIVEC
+@HAS_VSX_FALSE@BUILD_FLAG_VSX = 
+@HAS_VSX_TRUE@BUILD_FLAG_VSX = -mvsx
+@HAS_VSX_FALSE@VSX_FLAG = 
+@HAS_VSX_TRUE@VSX_FLAG = -DHAS_VSX
 jm_insns_CFLAGS = $(AM_CFLAGS) -Winline -Wall -O -g -mregnames -maltivec \
 			@FLAG_M32@ $(ALTIVEC_FLAG)
 
 testVMX_CFLAGS = $(AM_CFLAGS) -O -g -Wall -maltivec -mabi=altivec -DALTIVEC \
 			-DGCC_COMPILER @FLAG_M32@
 
+test_isa_2_06_part1_CFLAGS = $(AM_CFLAGS) -Winline -Wall -O -g -mregnames $(VSX_FLAG) \
+			@FLAG_M32@ $(ALTIVEC_FLAG) $(BUILD_FLAG_VSX)
+
 all: all-am
 
 .SUFFIXES:
@@ -523,6 +539,9 @@ test_fx$(EXEEXT): $(test_fx_OBJECTS) $(t
 test_gx$(EXEEXT): $(test_gx_OBJECTS) $(test_gx_DEPENDENCIES) 
 	@rm -f test_gx$(EXEEXT)
 	$(LINK) $(test_gx_OBJECTS) $(test_gx_LDADD) $(LIBS)
+test_isa_2_06_part1$(EXEEXT): $(test_isa_2_06_part1_OBJECTS) $(test_isa_2_06_part1_DEPENDENCIES) 
+	@rm -f test_isa_2_06_part1$(EXEEXT)
+	$(test_isa_2_06_part1_LINK) $(test_isa_2_06_part1_OBJECTS) $(test_isa_2_06_part1_LDADD) $(LIBS)
 tw$(EXEEXT): $(tw_OBJECTS) $(tw_DEPENDENCIES) 
 	@rm -f tw$(EXEEXT)
 	$(LINK) $(tw_OBJECTS) $(tw_LDADD) $(LIBS)
@@ -552,6 +571,7 @@ distclean-compile:
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/testVMX-testVMX.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/test_fx.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/test_gx.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/test_isa_2_06_part1-test_isa_2_06_part1.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/tw.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/twi.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/xlc_dbl_u32.Po@am__quote@
@@ -598,6 +618,20 @@ testVMX-testVMX.obj: testVMX.c
 @AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
 @am__fastdepCC_FALSE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(testVMX_CFLAGS) $(CFLAGS) -c -o testVMX-testVMX.obj `if test -f 'testVMX.c'; then $(CYGPATH_W) 'testVMX.c'; else $(CYGPATH_W) '$(srcdir)/testVMX.c'; fi`
 
+test_isa_2_06_part1-test_isa_2_06_part1.o: test_isa_2_06_part1.c
+@am__fastdepCC_TRUE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(test_isa_2_06_part1_CFLAGS) $(CFLAGS) -MT test_isa_2_06_part1-test_isa_2_06_part1.o -MD -MP -MF $(DEPDIR)/test_isa_2_06_part1-test_isa_2_06_part1.Tpo -c -o test_isa_2_06_part1-test_isa_2_06_part1.o `test -f 'test_isa_2_06_part1.c' || echo '$(srcdir)/'`test_isa_2_06_part1.c
+@am__fastdepCC_TRUE@	$(am__mv) $(DEPDIR)/test_isa_2_06_part1-test_isa_2_06_part1.Tpo $(DEPDIR)/test_isa_2_06_part1-test_isa_2_06_part1.Po
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='test_isa_2_06_part1.c' object='test_isa_2_06_part1-test_isa_2_06_part1.o' libtool=no @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@am__fastdepCC_FALSE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(test_isa_2_06_part1_CFLAGS) $(CFLAGS) -c -o test_isa_2_06_part1-test_isa_2_06_part1.o `test -f 'test_isa_2_06_part1.c' || echo '$(srcdir)/'`test_isa_2_06_part1.c
+
+test_isa_2_06_part1-test_isa_2_06_part1.obj: test_isa_2_06_part1.c
+@am__fastdepCC_TRUE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(test_isa_2_06_part1_CFLAGS) $(CFLAGS) -MT test_isa_2_06_part1-test_isa_2_06_part1.obj -MD -MP -MF $(DEPDIR)/test_isa_2_06_part1-test_isa_2_06_part1.Tpo -c -o test_isa_2_06_part1-test_isa_2_06_part1.obj `if test -f 'test_isa_2_06_part1.c'; then $(CYGPATH_W) 'test_isa_2_06_part1.c'; else $(CYGPATH_W) '$(srcdir)/test_isa_2_06_part1.c'; fi`
+@am__fastdepCC_TRUE@	$(am__mv) $(DEPDIR)/test_isa_2_06_part1-test_isa_2_06_part1.Tpo $(DEPDIR)/test_isa_2_06_part1-test_isa_2_06_part1.Po
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='test_isa_2_06_part1.c' object='test_isa_2_06_part1-test_isa_2_06_part1.obj' libtool=no @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@am__fastdepCC_FALSE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(test_isa_2_06_part1_CFLAGS) $(CFLAGS) -c -o test_isa_2_06_part1-test_isa_2_06_part1.obj `if test -f 'test_isa_2_06_part1.c'; then $(CYGPATH_W) 'test_isa_2_06_part1.c'; else $(CYGPATH_W) '$(srcdir)/test_isa_2_06_part1.c'; fi`
+
 ID: $(HEADERS) $(SOURCES) $(LISP) $(TAGS_FILES)
 	list='$(SOURCES) $(HEADERS) $(LISP) $(TAGS_FILES)'; \
 	unique=`for i in $$list; do \
--- valgrind-3.6.0/none/tests/ppc64/Makefile.in.jj	2011-08-01 15:45:52.203651000 +0200
+++ valgrind-3.6.0/none/tests/ppc64/Makefile.in	2011-08-01 18:46:18.321731000 +0200
@@ -48,7 +48,8 @@ DIST_COMMON = $(dist_noinst_SCRIPTS) $(s
 	$(top_srcdir)/Makefile.tool-tests.am
 check_PROGRAMS = jm-insns$(EXEEXT) lsw$(EXEEXT) round$(EXEEXT) \
 	std_reg_imm$(EXEEXT) twi_tdi$(EXEEXT) tw_td$(EXEEXT) \
-	power6_bcmp$(EXEEXT) power6_mf_gpr$(EXEEXT)
+	power6_bcmp$(EXEEXT) power6_mf_gpr$(EXEEXT) \
+	test_isa_2_06_part1$(EXEEXT)
 subdir = none/tests/ppc64
 ACLOCAL_M4 = $(top_srcdir)/aclocal.m4
 am__aclocal_m4_deps = $(top_srcdir)/configure.in
@@ -78,6 +79,12 @@ round_LDADD = $(LDADD)
 std_reg_imm_SOURCES = std_reg_imm.c
 std_reg_imm_OBJECTS = std_reg_imm.$(OBJEXT)
 std_reg_imm_LDADD = $(LDADD)
+test_isa_2_06_part1_SOURCES = test_isa_2_06_part1.c
+test_isa_2_06_part1_OBJECTS =  \
+	test_isa_2_06_part1-test_isa_2_06_part1.$(OBJEXT)
+test_isa_2_06_part1_LDADD = $(LDADD)
+test_isa_2_06_part1_LINK = $(CCLD) $(test_isa_2_06_part1_CFLAGS) \
+	$(CFLAGS) $(AM_LDFLAGS) $(LDFLAGS) -o $@
 tw_td_SOURCES = tw_td.c
 tw_td_OBJECTS = tw_td.$(OBJEXT)
 tw_td_LDADD = $(LDADD)
@@ -94,9 +101,9 @@ COMPILE = $(CC) $(DEFS) $(DEFAULT_INCLUD
 CCLD = $(CC)
 LINK = $(CCLD) $(AM_CFLAGS) $(CFLAGS) $(AM_LDFLAGS) $(LDFLAGS) -o $@
 SOURCES = jm-insns.c lsw.c power6_bcmp.c power6_mf_gpr.c round.c \
-	std_reg_imm.c tw_td.c twi_tdi.c
+	std_reg_imm.c test_isa_2_06_part1.c tw_td.c twi_tdi.c
 DIST_SOURCES = jm-insns.c lsw.c power6_bcmp.c power6_mf_gpr.c round.c \
-	std_reg_imm.c tw_td.c twi_tdi.c
+	std_reg_imm.c test_isa_2_06_part1.c tw_td.c twi_tdi.c
 ETAGS = etags
 CTAGS = ctags
 DISTFILES = $(DIST_COMMON) $(DIST_SOURCES) $(TEXINFOS) $(EXTRA_DIST)
@@ -395,10 +402,18 @@ EXTRA_DIST = \
 	twi_tdi.stderr.exp twi_tdi.stdout.exp twi_tdi.vgtest \
 	tw_td.stderr.exp tw_td.stdout.exp tw_td.vgtest \
 	power6_bcmp.stderr.exp power6_bcmp.stdout.exp power6_bcmp.vgtest \
-	power6_mf_gpr.stderr.exp power6_mf_gpr.stdout.exp power6_mf_gpr.vgtest
+	power6_mf_gpr.stderr.exp power6_mf_gpr.stdout.exp power6_mf_gpr.vgtest \
+	test_isa_2_06_part1.stderr.exp  test_isa_2_06_part1.stdout.exp  test_isa_2_06_part1.vgtest
 
 @HAS_ALTIVEC_FALSE@ALTIVEC_FLAG = 
 @HAS_ALTIVEC_TRUE@ALTIVEC_FLAG = -DHAS_ALTIVEC
+@HAS_VSX_FALSE@BUILD_FLAG_VSX = 
+@HAS_VSX_TRUE@BUILD_FLAG_VSX = -mvsx
+@HAS_VSX_FALSE@VSX_FLAG = 
+@HAS_VSX_TRUE@VSX_FLAG = -DHAS_VSX
+test_isa_2_06_part1_CFLAGS = $(AM_CFLAGS) -Winline -Wall -O -g -mregnames $(VSX_FLAG) \
+			@FLAG_M64@ $(ALTIVEC_FLAG) $(BUILD_FLAG_VSX)
+
 jm_insns_CFLAGS = $(AM_CFLAGS) -Winline -Wall -O -g -mregnames -maltivec \
 			@FLAG_M64@ $(ALTIVEC_FLAG)
 
@@ -457,6 +472,9 @@ round$(EXEEXT): $(round_OBJECTS) $(round
 std_reg_imm$(EXEEXT): $(std_reg_imm_OBJECTS) $(std_reg_imm_DEPENDENCIES) 
 	@rm -f std_reg_imm$(EXEEXT)
 	$(LINK) $(std_reg_imm_OBJECTS) $(std_reg_imm_LDADD) $(LIBS)
+test_isa_2_06_part1$(EXEEXT): $(test_isa_2_06_part1_OBJECTS) $(test_isa_2_06_part1_DEPENDENCIES) 
+	@rm -f test_isa_2_06_part1$(EXEEXT)
+	$(test_isa_2_06_part1_LINK) $(test_isa_2_06_part1_OBJECTS) $(test_isa_2_06_part1_LDADD) $(LIBS)
 tw_td$(EXEEXT): $(tw_td_OBJECTS) $(tw_td_DEPENDENCIES) 
 	@rm -f tw_td$(EXEEXT)
 	$(LINK) $(tw_td_OBJECTS) $(tw_td_LDADD) $(LIBS)
@@ -476,6 +494,7 @@ distclean-compile:
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/power6_mf_gpr.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/round.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/std_reg_imm.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/test_isa_2_06_part1-test_isa_2_06_part1.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/tw_td.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/twi_tdi.Po@am__quote@
 
@@ -507,6 +526,20 @@ jm_insns-jm-insns.obj: jm-insns.c
 @AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
 @am__fastdepCC_FALSE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(jm_insns_CFLAGS) $(CFLAGS) -c -o jm_insns-jm-insns.obj `if test -f 'jm-insns.c'; then $(CYGPATH_W) 'jm-insns.c'; else $(CYGPATH_W) '$(srcdir)/jm-insns.c'; fi`
 
+test_isa_2_06_part1-test_isa_2_06_part1.o: test_isa_2_06_part1.c
+@am__fastdepCC_TRUE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(test_isa_2_06_part1_CFLAGS) $(CFLAGS) -MT test_isa_2_06_part1-test_isa_2_06_part1.o -MD -MP -MF $(DEPDIR)/test_isa_2_06_part1-test_isa_2_06_part1.Tpo -c -o test_isa_2_06_part1-test_isa_2_06_part1.o `test -f 'test_isa_2_06_part1.c' || echo '$(srcdir)/'`test_isa_2_06_part1.c
+@am__fastdepCC_TRUE@	$(am__mv) $(DEPDIR)/test_isa_2_06_part1-test_isa_2_06_part1.Tpo $(DEPDIR)/test_isa_2_06_part1-test_isa_2_06_part1.Po
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='test_isa_2_06_part1.c' object='test_isa_2_06_part1-test_isa_2_06_part1.o' libtool=no @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@am__fastdepCC_FALSE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(test_isa_2_06_part1_CFLAGS) $(CFLAGS) -c -o test_isa_2_06_part1-test_isa_2_06_part1.o `test -f 'test_isa_2_06_part1.c' || echo '$(srcdir)/'`test_isa_2_06_part1.c
+
+test_isa_2_06_part1-test_isa_2_06_part1.obj: test_isa_2_06_part1.c
+@am__fastdepCC_TRUE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(test_isa_2_06_part1_CFLAGS) $(CFLAGS) -MT test_isa_2_06_part1-test_isa_2_06_part1.obj -MD -MP -MF $(DEPDIR)/test_isa_2_06_part1-test_isa_2_06_part1.Tpo -c -o test_isa_2_06_part1-test_isa_2_06_part1.obj `if test -f 'test_isa_2_06_part1.c'; then $(CYGPATH_W) 'test_isa_2_06_part1.c'; else $(CYGPATH_W) '$(srcdir)/test_isa_2_06_part1.c'; fi`
+@am__fastdepCC_TRUE@	$(am__mv) $(DEPDIR)/test_isa_2_06_part1-test_isa_2_06_part1.Tpo $(DEPDIR)/test_isa_2_06_part1-test_isa_2_06_part1.Po
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='test_isa_2_06_part1.c' object='test_isa_2_06_part1-test_isa_2_06_part1.obj' libtool=no @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@am__fastdepCC_FALSE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(test_isa_2_06_part1_CFLAGS) $(CFLAGS) -c -o test_isa_2_06_part1-test_isa_2_06_part1.obj `if test -f 'test_isa_2_06_part1.c'; then $(CYGPATH_W) 'test_isa_2_06_part1.c'; else $(CYGPATH_W) '$(srcdir)/test_isa_2_06_part1.c'; fi`
+
 ID: $(HEADERS) $(SOURCES) $(LISP) $(TAGS_FILES)
 	list='$(SOURCES) $(HEADERS) $(LISP) $(TAGS_FILES)'; \
 	unique=`for i in $$list; do \
