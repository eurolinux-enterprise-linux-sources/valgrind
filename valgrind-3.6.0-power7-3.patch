svn diff -r12005:12007
svn diff -r2198:2199 VEX/
--- valgrind/VEX/priv/guest_ppc_defs.h	(revision 2198)
+++ valgrind/VEX/priv/guest_ppc_defs.h	(revision 2199)
@@ -128,6 +128,8 @@ enum {
    /* 13 */ PPCG_FLAG_OP_SRADI,   // sradi
    /* 14 */ PPCG_FLAG_OP_DIVDE,   // divdeo
    /* 15 */ PPCG_FLAG_OP_DIVWEU,  // divweuo
+   /* 16 */ PPCG_FLAG_OP_DIVWE,   // divweo
+   /* 17 */ PPCG_FLAG_OP_DIVDEU,  // divdeuo
    PPCG_FLAG_OP_NUMBER
 };
 
--- valgrind/VEX/priv/ir_defs.c	(revision 2198)
+++ valgrind/VEX/priv/ir_defs.c	(revision 2199)
@@ -220,8 +220,10 @@ void ppIROp ( IROp op )
       case Iop_DivS32: vex_printf("DivS32"); return;
       case Iop_DivU64: vex_printf("DivU64"); return;
       case Iop_DivS64: vex_printf("DivS64"); return;
+      case Iop_DivU64E: vex_printf("DivU64E"); return;
       case Iop_DivS64E: vex_printf("DivS64E"); return;
       case Iop_DivU32E: vex_printf("DivU32E"); return;
+      case Iop_DivS32E: vex_printf("DivS32E"); return;
 
       case Iop_DivModU64to32: vex_printf("DivModU64to32"); return;
       case Iop_DivModS64to32: vex_printf("DivModS64to32"); return;
@@ -2164,10 +2166,10 @@ void typeOfPrimop ( IROp op,
       case Iop_Clz64: case Iop_Ctz64:
          UNARY(Ity_I64, Ity_I64);
 
-      case Iop_DivU32: case Iop_DivS32: case Iop_DivU32E:
+      case Iop_DivU32: case Iop_DivS32: case Iop_DivU32E: case Iop_DivS32E:
          BINARY(Ity_I32,Ity_I32, Ity_I32);
 
-      case Iop_DivU64: case Iop_DivS64: case Iop_DivS64E:
+      case Iop_DivU64: case Iop_DivS64: case Iop_DivS64E: case Iop_DivU64E:
          BINARY(Ity_I64,Ity_I64, Ity_I64);
 
       case Iop_DivModU64to32: case Iop_DivModS64to32:
--- valgrind/VEX/priv/host_ppc_defs.c	(revision 2198)
+++ valgrind/VEX/priv/host_ppc_defs.c	(revision 2199)
@@ -3011,8 +3011,12 @@ Int emit_PPCInstr ( UChar* buf, Int nbuf
                // divweu r_dst,r_srcL,r_srcR
                p = mkFormXO(p, 31, r_dst, r_srcL, r_srcR, 0, 395, 0);
          } else {
-            // divde r_dst,r_srcL,r_srcR
-            p = mkFormXO(p, 31, r_dst, r_srcL, r_srcR, 0, 425, 0);
+            if (syned)
+               // divde r_dst,r_srcL,r_srcR
+               p = mkFormXO(p, 31, r_dst, r_srcL, r_srcR, 0, 425, 0);
+            else
+               // divdeu r_dst,r_srcL,r_srcR
+               p = mkFormXO(p, 31, r_dst, r_srcL, r_srcR, 0, 393, 0);
          }
       } else if (sz32) {
          if (syned)  // divw r_dst,r_srcL,r_srcR
--- valgrind/VEX/priv/guest_ppc_toIR.c	(revision 2198)
+++ valgrind/VEX/priv/guest_ppc_toIR.c	(revision 2199)
@@ -752,6 +752,33 @@ static void breakV128to4x64U ( IRExpr* t
    assign( *t0, unop(Iop_32Uto64, unop(Iop_64to32,   mkexpr(lo64))) );
 }
 
+static void breakV128to4x32( IRExpr* t128,
+                              /*OUTs*/
+                              IRTemp* t3, IRTemp* t2,
+                              IRTemp* t1, IRTemp* t0 )
+{
+   IRTemp hi64 = newTemp(Ity_I64);
+   IRTemp lo64 = newTemp(Ity_I64);
+
+   vassert(typeOfIRExpr(irsb->tyenv, t128) == Ity_V128);
+   vassert(t0 && *t0 == IRTemp_INVALID);
+   vassert(t1 && *t1 == IRTemp_INVALID);
+   vassert(t2 && *t2 == IRTemp_INVALID);
+   vassert(t3 && *t3 == IRTemp_INVALID);
+   *t0 = newTemp(Ity_I32);
+   *t1 = newTemp(Ity_I32);
+   *t2 = newTemp(Ity_I32);
+   *t3 = newTemp(Ity_I32);
+
+   assign( hi64, unop(Iop_V128HIto64, t128) );
+   assign( lo64, unop(Iop_V128to64,   t128) );
+   assign( *t3, unop(Iop_64HIto32, mkexpr(hi64)) );
+   assign( *t2, unop(Iop_64to32,   mkexpr(hi64)) );
+   assign( *t1, unop(Iop_64HIto32, mkexpr(lo64)) );
+   assign( *t0, unop(Iop_64to32,   mkexpr(lo64)) );
+}
+
+
 /* Signed saturating narrow 64S to 32 */
 static IRExpr* mkQNarrow64Sto32 ( IRExpr* t64 )
 {
@@ -1264,16 +1291,43 @@ static Int guestCR0offset ( UInt cr )
 }
 
 /* Generate an IR sequence to do a popcount operation on the supplied
- * IRTemp, and return an IRTemp holding the result.
- */
-static IRTemp gen_POPCOUNT ( IRTemp src )
+   IRTemp, and return a new IRTemp holding the result.  'ty' may be
+   Ity_I32 or Ity_I64 only. */
+static IRTemp gen_POPCOUNT ( IRType ty, IRTemp src )
 {
    Int i, shift[6];
+   IRTemp mask[6];
    IRTemp old = IRTemp_INVALID;
    IRTemp nyu = IRTemp_INVALID;
-   IRTemp mask[6];
 
-   vassert(typeOfIRExpr(irsb->tyenv,mkexpr(src)) == Ity_I64);
+   vassert(ty == Ity_I64 || ty == Ity_I32);
+
+   if (ty == Ity_I32) {
+      for (i = 0; i < 5; i++) {
+         mask[i]  = newTemp(ty);
+         shift[i] = 1 << i;
+      }
+      assign(mask[0], mkU32(0x55555555));
+      assign(mask[1], mkU32(0x33333333));
+      assign(mask[2], mkU32(0x0F0F0F0F));
+      assign(mask[3], mkU32(0x00FF00FF));
+      assign(mask[4], mkU32(0x0000FFFF));
+      old = src;
+      for (i = 0; i < 5; i++) {
+         nyu = newTemp(ty);
+         assign(nyu,
+                binop(Iop_Add32,
+                      binop(Iop_And32,
+                            mkexpr(old),
+                            mkexpr(mask[i])),
+                      binop(Iop_And32,
+                            binop(Iop_Shr32, mkexpr(old), mkU8(shift[i])),
+                            mkexpr(mask[i]))));
+         old = nyu;
+      }
+      return nyu;
+   }
+// else, ty == Ity_I64
    for (i = 0; i < 6; i++) {
       mask[i] = newTemp( Ity_I64 );
       shift[i] = 1 << i;
@@ -1853,6 +1907,21 @@ static void set_XER_OV_32( UInt op, IREx
                         unop( Iop_1Uto32, binop( Iop_CmpLT32U, argR, argL ) ) );
       break;
 
+   case PPCG_FLAG_OP_DIVWE:
+
+      /* If argR == 0 of if the result cannot fit in the 32-bit destination register,
+       * then OV <- 1.   If dest reg is 0 AND both dividend and divisor are non-zero,
+       * an overflow is implied.
+       */
+      xer_ov = binop( Iop_Or32,
+                      unop( Iop_1Uto32, binop( Iop_CmpEQ32, argR, mkU32( 0 ) ) ),
+                      unop( Iop_1Uto32, mkAND1( binop( Iop_CmpEQ32, res, mkU32( 0 ) ),
+                              mkAND1( binop( Iop_CmpNE32, argL, mkU32( 0 ) ),
+                                      binop( Iop_CmpNE32, argR, mkU32( 0 ) ) ) ) ) );
+      break;
+
+
+
    default: 
       vex_printf("set_XER_OV: op = %u\n", op);
       vpanic("set_XER_OV(ppc)");
@@ -1972,6 +2041,12 @@ static void set_XER_OV_64( UInt op, IREx
                                            binop( Iop_CmpNE64, argR, mkU64( 0 ) ) ) ) );
       break;
 
+   case PPCG_FLAG_OP_DIVDEU:
+     /* If argR == 0 or if argL >= argR, set OV. */
+     xer_ov = mkOR1( binop( Iop_CmpEQ64, argR, mkU64( 0 ) ),
+                         binop( Iop_CmpLE64U, argR, argL ) );
+     break;
+
    default: 
       vex_printf("set_XER_OV: op = %u\n", op);
       vpanic("set_XER_OV(ppc64)");
@@ -2604,10 +2679,21 @@ static void putGST_field ( PPC_GST reg,
                                mkexpr( x ), \
                                mkU64( NONZERO_FRAC_MASK ) )
 
+// Returns exponent part of a single precision floating point as I32
+static IRExpr * fp_exp_part_sp(IRTemp src)
+{
+   return binop( Iop_And32,
+                 binop( Iop_Shr32, mkexpr( src ), mkU8( 23 ) ),
+                 mkU32( 0xff ) );
+}
+
 // Returns exponent part of floating point as I32
-static IRExpr * fp_exp_part(IRTemp src)
+static IRExpr * fp_exp_part(IRTemp src, Bool sp)
 {
    IRExpr * exp;
+   if (sp)
+      return fp_exp_part_sp(src);
+
    if (!mode64)
       exp = binop( Iop_And32, binop( Iop_Shr32, unop( Iop_64HIto32,
                                                       mkexpr( src ) ),
@@ -2620,26 +2706,51 @@ static IRExpr * fp_exp_part(IRTemp src)
    return exp;
 }
 
+static IRExpr * is_Inf_sp(IRTemp src)
+{
+   IRTemp frac_part = newTemp(Ity_I32);
+   IRExpr * Inf_exp;
+
+   assign( frac_part, binop( Iop_And32, mkexpr(src), mkU32(0x007fffff)) );
+   Inf_exp = binop( Iop_CmpEQ32, fp_exp_part( src, True /*single precision*/ ), mkU32( 0xff ) );
+   return mkAND1( Inf_exp, binop( Iop_CmpEQ32, mkexpr( frac_part ), mkU32( 0 ) ) );
+}
+
 
 // Infinity: exp = 7ff and fraction is zero; s = 0/1
-static IRExpr * is_Inf(IRTemp src)
+static IRExpr * is_Inf(IRTemp src, Bool sp)
 {
    IRExpr * Inf_exp, * hi32, * low32;
-   IRTemp frac_part = newTemp(Ity_I64);
+   IRTemp frac_part;
 
+   if (sp)
+      return is_Inf_sp(src);
+
+   frac_part = newTemp(Ity_I64);
    assign( frac_part, FP_FRAC_PART(src) );
-   Inf_exp = binop( Iop_CmpEQ32, fp_exp_part( src ), mkU32( 0x7ff ) );
+   Inf_exp = binop( Iop_CmpEQ32, fp_exp_part( src, False /*not single precision*/  ), mkU32( 0x7ff ) );
    hi32 = unop( Iop_64HIto32, mkexpr( frac_part ) );
    low32 = unop( Iop_64to32, mkexpr( frac_part ) );
    return mkAND1( Inf_exp, binop( Iop_CmpEQ32, binop( Iop_Or32, low32, hi32 ),
                                   mkU32( 0 ) ) );
 }
 
+static IRExpr * is_Zero_sp(IRTemp src)
+{
+   IRTemp sign_less_part = newTemp(Ity_I32);
+   assign( sign_less_part, binop( Iop_And32, mkexpr( src ), mkU32( SIGN_MASK32 ) ) );
+   return binop( Iop_CmpEQ32, mkexpr( sign_less_part ), mkU32( 0 ) );
+}
+
 // Zero: exp is zero and fraction is zero; s = 0/1
-static IRExpr * is_Zero(IRTemp src)
+static IRExpr * is_Zero(IRTemp src, Bool sp)
 {
    IRExpr * hi32, * low32;
-   IRTemp sign_less_part = newTemp(Ity_I64);
+   IRTemp sign_less_part;
+   if (sp)
+      return is_Zero_sp(src);
+
+   sign_less_part = newTemp(Ity_I64);
 
    assign( sign_less_part, binop( Iop_And64, mkexpr( src ), mkU64( SIGN_MASK ) ) );
    hi32 = unop( Iop_64HIto32, mkexpr( sign_less_part ) );
@@ -2660,7 +2771,8 @@ static IRExpr * is_NaN(IRTemp src)
    assign( frac_part, FP_FRAC_PART(src) );
    hi32 = unop( Iop_64HIto32, mkexpr( frac_part ) );
    low32 = unop( Iop_64to32, mkexpr( frac_part ) );
-   NaN_exp = binop( Iop_CmpEQ32, fp_exp_part( src ), mkU32( 0x7ff ) );
+   NaN_exp = binop( Iop_CmpEQ32, fp_exp_part( src, False /*not single precision*/ ),
+                    mkU32( 0x7ff ) );
 
    return mkAND1( NaN_exp, binop( Iop_CmpNE32, binop( Iop_Or32, low32, hi32 ),
                                                mkU32( 0 ) ) );
@@ -3323,6 +3435,42 @@ static Bool dis_int_arith ( UInt theInst
          break;
       }
 
+      case 0x1AB: // divwe (Divide Word Extended)
+      {
+         /*
+          * If the quotient cannot be represented in 32 bits, or if an
+          * attempt is made to perform the division
+          *      <anything> / 0
+          * then the contents of register RD are undefined as are (if
+          * Rc=1) the contents of the LT, GT, and EQ bits of CR
+          * Field 0. In these cases, if OE=1 then OV is set to 1.
+          */
+
+         IRTemp res = newTemp(Ity_I32);
+         IRExpr * dividend, * divisor;
+         DIP("divwe%s%s r%u,r%u,r%u\n",
+             flag_OE ? "o" : "", flag_rC ? ".":"",
+                                         rD_addr, rA_addr, rB_addr);
+         if (mode64) {
+            dividend = unop( Iop_64to32, mkexpr( rA ) );
+            divisor = unop( Iop_64to32, mkexpr( rB ) );
+            assign( res, binop( Iop_DivS32E, dividend, divisor ) );
+            assign( rD, binop( Iop_32HLto64, mkU32( 0 ), mkexpr( res ) ) );
+         } else {
+            dividend = mkexpr( rA );
+            divisor =  mkexpr( rB );
+            assign( res, binop( Iop_DivS32E, dividend, divisor ) );
+            assign( rD, mkexpr( res) );
+         }
+
+         if (flag_OE) {
+            set_XER_OV_32( PPCG_FLAG_OP_DIVWE,
+                           mkexpr(res), dividend, divisor );
+         }
+         break;
+      }
+
+
       case 0x1A9: // divde (Divide Doubleword Extended)
         /*
          * If the quotient cannot be represented in 64 bits, or if an
@@ -3342,6 +3490,18 @@ static Bool dis_int_arith ( UInt theInst
          }
          break;
 
+      case 0x189: //  divdeuo (Divide Doubleword Extended Unsigned)
+        // Same CR and OV rules as given for divweu above
+        DIP("divdeu%s%s r%u,r%u,r%u\n",
+            flag_OE ? "o" : "", flag_rC ? ".":"",
+            rD_addr, rA_addr, rB_addr);
+        assign( rD, binop(Iop_DivU64E, mkexpr(rA), mkexpr(rB)) );
+        if (flag_OE) {
+           set_XER_OV_64( PPCG_FLAG_OP_DIVDEU, mkexpr( rD ),
+                          mkexpr( rA ), mkexpr( rB ) );
+        }
+        break;
+
       default:
          vex_printf("dis_int_arith(ppc)(opc2)\n");
          return False;
@@ -3742,11 +3902,28 @@ static Bool dis_int_logic ( UInt theInst
       case 0x1FA: // popcntd (population count doubleword
       {
     	  DIP("popcntd r%u,r%u\n", rA_addr, rS_addr);
-        IRTemp result = gen_POPCOUNT(rS);
+        IRTemp result = gen_POPCOUNT(ty, rS);
     	  putIReg( rA_addr, mkexpr(result) );
     	  return True;
       }
-
+      case 0x17A: // popcntw (Population Count Words)
+      {
+         DIP("popcntw r%u,r%u\n", rA_addr, rS_addr);
+         if (mode64) {
+            IRTemp resultHi, resultLo;
+            IRTemp argLo = newTemp(Ity_I32);
+            IRTemp argHi = newTemp(Ity_I32);
+            assign(argLo, unop(Iop_64to32, mkexpr(rS)));
+            assign(argHi, unop(Iop_64HIto32, mkexpr(rS)));
+            resultLo = gen_POPCOUNT(Ity_I32, argLo);
+            resultHi = gen_POPCOUNT(Ity_I32, argHi);
+            putIReg( rA_addr, binop(Iop_32HLto64, mkexpr(resultHi), mkexpr(resultLo)));
+         } else {
+            IRTemp result = gen_POPCOUNT(ty, rS);
+            putIReg( rA_addr, mkexpr(result) );
+         }
+         return True;
+      }
        case 0x0FC: // bpermd (Bit Permute Doubleword)
        {
           /* This is a lot of rigmarole to emulate bpermd like this, as it
@@ -7174,6 +7351,103 @@ static Bool dis_fp_multadd ( UInt theIns
 
 /*
  * fe_flag is set to 1 if any of the following conditions occurs:
+ *  - The floating-point operand in register FRB is a Zero, a
+ *    NaN, an Infinity, or a negative value.
+ *  - e_b is less than or equal to: -970 for double precision; -103 for single precision
+ *  Otherwise fe_flag is set to 0.
+ *
+ * fg_flag is set to 1 if either of the following conditions occurs.
+ *   - The floating-point operand in register FRB is a Zero, an
+ *     Infinity, or a denormalized value.
+ *  Otherwise fg_flag is set to 0.
+ *
+ */
+static void do_fp_tsqrt(IRTemp frB_Int, Bool sp, IRTemp * fe_flag_tmp, IRTemp * fg_flag_tmp)
+{
+   // The following temps are for holding intermediate results
+   IRTemp e_b = newTemp(Ity_I32);
+   IRExpr * fe_flag,  * fg_flag;
+   IRTemp frB_exp_shR = newTemp(Ity_I32);
+   UInt bias = sp? 127 : 1023;
+   IRExpr * frbNaN, * frbDenorm, * frBNeg;
+   IRExpr * eb_LTE;
+   IRTemp  frbZero_tmp = newTemp(Ity_I1);
+   IRTemp  frbInf_tmp = newTemp(Ity_I1);
+   *fe_flag_tmp = newTemp(Ity_I32);
+   *fg_flag_tmp = newTemp(Ity_I32);
+   assign( frB_exp_shR, fp_exp_part( frB_Int, sp ) );
+   assign(e_b, binop( Iop_Sub32, mkexpr(frB_exp_shR), mkU32( bias ) ));
+
+   //////////////////  fe_flag tests BEGIN //////////////////////
+   /* We first do all tests that may result in setting fe_flag to '1'.
+    * (NOTE: These tests are similar to those used for ftdiv.  See do_fp_tdiv()
+    * for details.)
+    */
+   frbNaN = sp ? is_NaN_32(frB_Int) : is_NaN(frB_Int);
+   assign( frbInf_tmp, is_Inf(frB_Int, sp) );
+   assign( frbZero_tmp, is_Zero(frB_Int, sp ) );
+   {
+      // Test_value = -970 for double precision
+      UInt test_value = sp ? 0xffffff99 : 0xfffffc36;
+      eb_LTE = binop( Iop_CmpLE32S, mkexpr( e_b ), mkU32( test_value ) );
+   }
+   frBNeg = binop( Iop_CmpEQ32,
+                   binop( Iop_Shr32,
+                          sp ? mkexpr( frB_Int ) : unop( Iop_64HIto32, mkexpr( frB_Int ) ),
+                          mkU8( 31 ) ),
+                   mkU32( 1 ) );
+   //////////////////  fe_flag tests END //////////////////////
+
+   //////////////////  fg_flag tests BEGIN //////////////////////
+   /*
+    * The following tests were already performed above in the fe_flag
+    * tests.  So these conditions will result in both fe_ and fg_ flags
+    * being set.
+    *   - Test if FRB is Zero
+    *   - Test if FRB is an Infinity
+    */
+
+   /*
+    * Test if FRB holds a denormalized value.  A denormalized value is one where
+    * the exp is 0 and the fraction is non-zero.
+    */
+   if (sp) {
+      IRTemp frac_part = newTemp(Ity_I32);
+      assign( frac_part, binop( Iop_And32, mkexpr(frB_Int), mkU32(0x007fffff)) );
+      frbDenorm
+               = mkAND1( binop( Iop_CmpEQ32, mkexpr( frB_exp_shR ), mkU32( 0 ) ),
+                         binop( Iop_CmpNE32, mkexpr( frac_part ), mkU32( 0 ) ) );
+   } else {
+      IRExpr * hi32, * low32, * fraction_is_nonzero;
+      IRTemp frac_part = newTemp(Ity_I64);
+
+      assign( frac_part, FP_FRAC_PART(frB_Int) );
+      hi32 = unop( Iop_64HIto32, mkexpr( frac_part ) );
+      low32 = unop( Iop_64to32, mkexpr( frac_part ) );
+      fraction_is_nonzero = binop( Iop_CmpNE32, binop( Iop_Or32, low32, hi32 ),
+                                                mkU32( 0 ) );
+      frbDenorm
+               = mkAND1( binop( Iop_CmpEQ32, mkexpr( frB_exp_shR ), mkU32( 0 ) ),
+                         fraction_is_nonzero );
+   }
+   //////////////////  fg_flag tests END //////////////////////
+
+   /////////////////////////
+   fe_flag = mkOR1( mkexpr( frbZero_tmp ),
+                    mkOR1( frbNaN,
+                           mkOR1( mkexpr( frbInf_tmp ),
+                                  mkOR1( frBNeg, eb_LTE ) ) ) );
+
+   fe_flag = unop(Iop_1Uto32, fe_flag);
+
+   fg_flag = mkOR1( mkexpr( frbZero_tmp ),
+                    mkOR1( mkexpr( frbInf_tmp ), frbDenorm ) );
+   fg_flag = unop(Iop_1Uto32, fg_flag);
+   assign (*fg_flag_tmp, fg_flag);
+   assign (*fe_flag_tmp, fe_flag);
+}
+/*
+ * fe_flag is set to 1 if any of the following conditions occurs:
  *  - The double-precision floating-point operand in register FRA is a NaN or an
  *    Infinity.
  *  - The double-precision floating-point operand in register FRB is a Zero, a
@@ -7195,7 +7469,7 @@ static Bool dis_fp_multadd ( UInt theIns
  *  Otherwise fg_flag is set to 0.
  *
  */
-static IRExpr * do_fp_tdiv(IRTemp frA_I64, IRTemp frB_I64)
+static void _do_fp_tdiv(IRTemp frA_int, IRTemp frB_int, Bool sp, IRTemp * fe_flag_tmp, IRTemp * fg_flag_tmp)
 {
    // The following temps are for holding intermediate results
    IRTemp e_a = newTemp(Ity_I32);
@@ -7203,7 +7477,9 @@ static IRExpr * do_fp_tdiv(IRTemp frA_I6
    IRTemp frA_exp_shR = newTemp(Ity_I32);
    IRTemp frB_exp_shR = newTemp(Ity_I32);
 
-   UInt bias = 1023;
+   UInt bias = sp? 127 : 1023;
+   *fe_flag_tmp = newTemp(Ity_I32);
+   *fg_flag_tmp = newTemp(Ity_I32);
 
    /* The following variables hold boolean results from tests
     * that are OR'ed together for setting the fe_ and fg_ flags.
@@ -7220,11 +7496,11 @@ static IRExpr * do_fp_tdiv(IRTemp frA_I6
 /* The following are the flags that are set by OR'ing the results of
  * all the tests done for tdiv.  These flags are the input to the specified CR.
  */
-   IRExpr * fe_flag, * fl_flag, * fg_flag;
+   IRExpr * fe_flag, * fg_flag;
 
    // Create temps that will be used throughout the following tests.
-   assign( frA_exp_shR, fp_exp_part( frA_I64 ) );
-   assign( frB_exp_shR, fp_exp_part( frB_I64 ) );
+   assign( frA_exp_shR, fp_exp_part( frA_int, sp ) );
+   assign( frB_exp_shR, fp_exp_part( frB_int, sp ) );
    /* Let e_[a|b] be the unbiased exponent: i.e. exp - 1023. */
    assign(e_a, binop( Iop_Sub32, mkexpr(frA_exp_shR), mkU32( bias ) ));
    assign(e_b, binop( Iop_Sub32, mkexpr(frB_exp_shR), mkU32( bias ) ));
@@ -7236,67 +7512,62 @@ static IRExpr * do_fp_tdiv(IRTemp frA_I6
    /*
     * Test if the double-precision floating-point operand in register FRA is
     * a NaN:
-    *    exp = 7ff and fraction is non-zero; s = 0/1
     */
-   fraNaN = is_NaN(frA_I64);
+   fraNaN = sp ? is_NaN_32(frA_int) : is_NaN(frA_int);
    /*
     * Test if the double-precision floating-point operand in register FRA is
     * an Infinity.
-    *    exp = 7ff and fraction is zero; s = 0/1
     */
-   assign(fraInf_tmp, is_Inf(frA_I64));
+   assign(fraInf_tmp, is_Inf(frA_int, sp));
 
    /*
     * Test if the double-precision floating-point operand in register FRB is
     * a NaN:
-    *    exp = 7ff and fraction is non-zero; s = 0/1
     */
-   frbNaN = is_NaN(frB_I64);
+   frbNaN = sp ? is_NaN_32(frB_int) : is_NaN(frB_int);
    /*
     * Test if the double-precision floating-point operand in register FRB is
     * an Infinity.
-    *    exp = 7ff and fraction is zero; s = 0/1
     */
-   assign( frbInf_tmp, is_Inf(frB_I64) );
+   assign( frbInf_tmp, is_Inf(frB_int, sp) );
    /*
     * Test if the double-precision floating-point operand in register FRB is
     * a Zero.
-    *    exp is zero and fraction is zero; s = 0/1
     */
-   assign( frbZero_tmp, is_Zero(frB_I64) );
+   assign( frbZero_tmp, is_Zero(frB_int, sp) );
 
    /*
-    * Test if e_b <= -1022
+    * Test if e_b <= -1022 for double precision;
+    * or e_b <= -126 for single precision
     */
    {
-      UInt test_value = 0xfffffc02;  //Int test_value = -1022;
+      UInt test_value = sp ? 0xffffff82 : 0xfffffc02;
       eb_LTE = binop(Iop_CmpLE32S, mkexpr(e_b), mkU32(test_value));
    }
 
    /*
-    * Test if e_b >= 1021
-    *   ==> 1021 < e_b
+    * Test if e_b >= 1021 (i.e., 1021 < e_b) for double precision;
+    * or e_b >= -125 (125 < e_b) for single precision
     */
    {
-      Int test_value = 1021;
+      Int test_value = sp ? 125 : 1021;
       eb_GTE = binop(Iop_CmpLT32S, mkU32(test_value), mkexpr(e_b));
    }
 
    /*
-    * Test if FRA != Zero and (e_a - e_b) >= 1023
-    *   ==> FRA != Zero && (1023 < (e_a - e_b)
+    * Test if FRA != Zero and (e_a - e_b) >= bias
     */
-   assign( fraNotZero_tmp, unop( Iop_Not1, is_Zero( frA_I64 ) ) );
+   assign( fraNotZero_tmp, unop( Iop_Not1, is_Zero( frA_int, sp ) ) );
    ea_eb_GTE = mkAND1( mkexpr( fraNotZero_tmp ),
                        binop( Iop_CmpLT32S, mkU32( bias ),
                               binop( Iop_Sub32, mkexpr( e_a ),
                                      mkexpr( e_b ) ) ) );
 
    /*
-    * Test if FRA != Zero and (e_a - e_b) <= -1021
+    * Test if FRA != Zero and (e_a - e_b) <= [-1021 (double precision) or -125 (single precision)]
     */
    {
-      UInt test_value = 0xfffffc03;  //Int test_value = -1021;
+      UInt test_value = sp ? 0xffffff83 : 0xfffffc03;
 
       ea_eb_LTE = mkAND1( mkexpr( fraNotZero_tmp ),
                           binop( Iop_CmpLE32S,
@@ -7307,7 +7578,7 @@ static IRExpr * do_fp_tdiv(IRTemp frA_I6
    }
 
    /*
-    * Test if FRA != Zero and e_a <= -970
+    * Test if FRA != Zero and e_a <= [-970 (double precision) or -103 (single precision)]
     */
    {
       UInt test_value = 0xfffffc36;  //Int test_value = -970;
@@ -7333,27 +7604,27 @@ static IRExpr * do_fp_tdiv(IRTemp frA_I6
     * the exp is 0 and the fraction is non-zero.
     */
    {
-      IRExpr * hi32, * low32, * fraction_is_nonzero;
-      IRTemp frac_part = newTemp(Ity_I64);
+      IRExpr * fraction_is_nonzero;
 
-      assign( frac_part, FP_FRAC_PART(frB_I64) );
-      hi32 = unop( Iop_64HIto32, mkexpr( frac_part ) );
-      low32 = unop( Iop_64to32, mkexpr( frac_part ) );
-      fraction_is_nonzero = binop( Iop_CmpNE32, binop( Iop_Or32, low32, hi32 ),
-                                                mkU32( 0 ) );
+      if (sp) {
+         fraction_is_nonzero = binop( Iop_CmpNE32, FP_FRAC_PART32(frB_int),
+                                      mkU32( 0 ) );
+      } else {
+         IRExpr * hi32, * low32;
+         IRTemp frac_part = newTemp(Ity_I64);
+         assign( frac_part, FP_FRAC_PART(frB_int) );
+
+         hi32 = unop( Iop_64HIto32, mkexpr( frac_part ) );
+         low32 = unop( Iop_64to32, mkexpr( frac_part ) );
+         fraction_is_nonzero = binop( Iop_CmpNE32, binop( Iop_Or32, low32, hi32 ),
+                                      mkU32( 0 ) );
+      }
       frbDenorm = mkAND1( binop( Iop_CmpEQ32, mkexpr( frB_exp_shR ),
-                                 mkU32( 0x0ULL ) ), fraction_is_nonzero );
+                                 mkU32( 0x0 ) ), fraction_is_nonzero );
 
    }
    //////////////////  fg_flag tests END //////////////////////
 
-   /////////////////////////
-   /* The CR field consists of fl_flag || fg_flag || fe_flag || 0b0
-    * where fl_flag == 1 on ppc64.
-    */
-   fl_flag = unop(Iop_Not32, mkU32(0xFFFFFE));
-
-
    fe_flag
    = mkOR1(
             fraNaN,
@@ -7377,38 +7648,89 @@ static IRExpr * do_fp_tdiv(IRTemp frA_I6
                                                  mkOR1( mkexpr( frbInf_tmp ),
                                                         frbDenorm ) ) );
    fg_flag = unop(Iop_1Uto32, fg_flag);
+   assign(*fe_flag_tmp, fe_flag);
+   assign(*fg_flag_tmp, fg_flag);
+}
 
+/* See description for _do_fp_tdiv() above. */
+static IRExpr * do_fp_tdiv(IRTemp frA_int, IRTemp frB_int)
+{
+   IRTemp  fe_flag, fg_flag;
+   /////////////////////////
+   /* The CR field consists of fl_flag || fg_flag || fe_flag || 0b0
+    * where fl_flag == 1 on ppc64.
+    */
+   IRExpr * fl_flag = unop(Iop_Not32, mkU32(0xFFFFFE));
+   fe_flag = fg_flag = IRTemp_INVALID;
+   _do_fp_tdiv(frA_int, frB_int, False/*not single precision*/, &fe_flag, &fg_flag);
    return binop( Iop_Or32,
                  binop( Iop_Or32,
                         binop( Iop_Shl32, fl_flag, mkU8( 3 ) ),
-                        binop( Iop_Shl32, fg_flag, mkU8( 2 ) ) ),
-                 binop( Iop_Shl32, fe_flag, mkU8( 1 ) ) );
+                        binop( Iop_Shl32, mkexpr(fg_flag), mkU8( 2 ) ) ),
+                 binop( Iop_Shl32, mkexpr(fe_flag), mkU8( 1 ) ) );
 }
 
-static Bool dis_fp_ftdiv ( UInt theInstr )
+static Bool dis_fp_tests ( UInt theInstr )
 {
    UChar opc1     = ifieldOPC(theInstr);
    UChar crfD     = toUChar( IFIELD( theInstr, 23, 3 ) );
-   UChar b21to22  = toUChar( IFIELD( theInstr, 21, 2 ) );
-   UChar frA_addr = ifieldRegA(theInstr);
    UChar frB_addr = ifieldRegB(theInstr);
    UChar b0       = ifieldBIT0(theInstr);
-
-   IRTemp frA_I64     = newTemp(Ity_I64);
+   UInt  opc2     = ifieldOPClo10(theInstr);
    IRTemp frB_I64     = newTemp(Ity_I64);
 
-
-   if (opc1 != 0x3F || b21to22 != 0 || b0 != 0) {
-      vex_printf("dis_fp_ftdiv(ppc)(instr)\n");
+   if (opc1 != 0x3F || b0 != 0 ){
+      vex_printf("dis_fp_tests(ppc)(ftdiv)\n");
       return False;
    }
-
-   assign( frA_I64, unop( Iop_ReinterpF64asI64, getFReg( frA_addr ) ) );
    assign( frB_I64, unop( Iop_ReinterpF64asI64, getFReg( frB_addr ) ) );
 
-   putGST_field( PPC_GST_CR, do_fp_tdiv(frA_I64, frB_I64), crfD );
+   switch (opc2) {
+      case 0x080: // ftdiv
+      {
+         UChar frA_addr = ifieldRegA(theInstr);
+         IRTemp frA_I64     = newTemp(Ity_I64);
+         UChar b21to22  = toUChar( IFIELD( theInstr, 21, 2 ) );
+         if (b21to22 != 0 ) {
+            vex_printf("dis_fp_tests(ppc)(ftdiv)\n");
+            return False;
+         }
+
+         assign( frA_I64, unop( Iop_ReinterpF64asI64, getFReg( frA_addr ) ) );
+         putGST_field( PPC_GST_CR, do_fp_tdiv(frA_I64, frB_I64), crfD );
 
-   DIP("ftdiv crf%d,fr%u,fr%u\n", crfD, frA_addr, frB_addr);
+         DIP("ftdiv crf%d,fr%u,fr%u\n", crfD, frA_addr, frB_addr);
+         break;
+      }
+      case 0x0A0: // ftsqrt
+      {
+         IRTemp flags = newTemp(Ity_I32);
+         IRTemp  fe_flag, fg_flag;
+         fe_flag = fg_flag = IRTemp_INVALID;
+         UChar b18to22  = toUChar( IFIELD( theInstr, 18, 5 ) );
+         if ( b18to22 != 0) {
+            vex_printf("dis_fp_tests(ppc)(ftsqrt)\n");
+            return False;
+         }
+         DIP("ftsqrt crf%d,fr%u\n", crfD, frB_addr);
+         do_fp_tsqrt(frB_I64, False /* not single precision*/, &fe_flag, &fg_flag);
+         /* The CR field consists of fl_flag || fg_flag || fe_flag || 0b0
+          * where fl_flag == 1 on ppc64.
+          */
+         assign( flags,
+                 binop( Iop_Or32,
+                        binop( Iop_Or32, mkU32( 8 ), // fl_flag
+                               binop( Iop_Shl32, mkexpr(fg_flag), mkU8( 2 ) ) ),
+                        binop( Iop_Shl32, mkexpr(fe_flag), mkU8( 1 ) ) ) );
+         putGST_field( PPC_GST_CR, mkexpr(flags), crfD );
+         break;
+      }
+
+      default:
+         vex_printf("dis_fp_tests(ppc)(opc2)\n");
+         return False;
+
+   }
    return True;
 }
 
@@ -7546,7 +7868,6 @@ static Bool dis_fp_round ( UInt theInstr
    }
 
    assign( frB, getFReg(frB_addr));
-   // TODO : add support here for fcfdus
    if (opc1 == 0x3B) {
       /* The fcfid[u]s instructions (from ISA 2.06) are a bit odd because
        * they're very similar to the other instructions handled here, but have
@@ -8151,160 +8472,432 @@ dis_vx_conv ( UInt theInstr, UInt opc2 )
    UChar opc1 = ifieldOPC( theInstr );
    UChar XT = ifieldRegXT( theInstr );
    UChar XB = ifieldRegXB( theInstr );
-   IRTemp frB = newTemp(Ity_F64);
-   IRTemp r_tmp64 = newTemp(Ity_I64);
+   IRTemp xB, xB2;
+   IRTemp b3, b2, b1, b0;
+   xB = xB2 = IRTemp_INVALID;
 
    if (opc1 != 0x3C) {
       vex_printf( "dis_vx_conv(ppc)(instr)\n" );
       return False;
    }
 
-   assign(frB, unop(Iop_ReinterpI64asF64, unop(Iop_V128HIto64, getVSReg( XB ))));
-   /* For all the VSX scalar convert instructions, the contents of doubleword element 1
-    * of VSX[XT] are undefined after the operation; therefore, we can simply
-    * move the entire array element where it makes sense to do so.
-    */
+   /* Create and assign temps only as needed for the given instruction. */
+   switch (opc2) {
+      // scalar double-precision floating point argument
+      case 0x2B0: case 0x0b0: case 0x290: case 0x212: case 0x090:
+         xB = newTemp(Ity_F64);
+         assign( xB,
+                 unop( Iop_ReinterpI64asF64,
+                       unop( Iop_V128HIto64, getVSReg( XB ) ) ) );
+         break;
+      // vector double-precision floating point arguments
+      case 0x1b0: case 0x312: case 0x390: case 0x190: case 0x3B0:
+
+         xB = newTemp(Ity_F64);
+         xB2 = newTemp(Ity_F64);
+         assign( xB,
+                 unop( Iop_ReinterpI64asF64,
+                       unop( Iop_V128HIto64, getVSReg( XB ) ) ) );
+         assign( xB2,
+                 unop( Iop_ReinterpI64asF64,
+                       unop( Iop_V128to64, getVSReg( XB ) ) ) );
+         break;
+      // vector single precision or [un]signed integer word arguments
+      case 0x130: case 0x392: case 0x330: case 0x310: case 0x110:
+      case 0x1f0: case 0x1d0:
+         b3 = b2 = b1 = b0 = IRTemp_INVALID;
+         breakV128to4x32(getVSReg(XB), &b3, &b2, &b1, &b0);
+         break;
+         // vector [un]signed integer doubleword argument
+      case 0x3f0: case 0x370: case 0x3d0: case 0x350:
+         xB = newTemp(Ity_I64);
+         assign( xB, unop( Iop_V128HIto64, getVSReg( XB ) ) );
+         xB2 = newTemp(Ity_I64);
+         assign( xB2, unop( Iop_V128to64, getVSReg( XB ) ) );
+         break;
+      // scalar [un]signed integer doubleword argument
+      case 0x2F0: case 0x2D0:
+         xB = newTemp(Ity_I64);
+         assign( xB, unop( Iop_V128HIto64, getVSReg( XB ) ) );
+         break;
+      // scalar single precision argument
+      case 0x292: // xscvspdp
+         xB = newTemp(Ity_I32);
+         assign( xB,
+                 unop( Iop_64HIto32, unop( Iop_V128HIto64, getVSReg( XB ) ) ) );
+         break;
+
+      /* Certain instructions have their complete implementation in the main switch statement
+       * that follows this one; thus we have a "do nothing" case for those instructions here.
+       */
+      case 0x170: case 0x150:
+         break; // do nothing
+
+      default:
+         vex_printf( "dis_vx_conv(ppc)(opc2)\n" );
+         return False;
+   }
+
 
    switch (opc2) {
-   case 0x2B0:
-      // xscvdpsxds (VSX Scalar truncate Double-Precision to integer and Convert
-      //             to Signed Integer Doubleword format with Saturate)
-      DIP("xscvdpsxds fr%u,fr%u\n",  (UInt)XT, (UInt)XB);
-      putVSReg( XT,
+      case 0x2B0:
+         // xscvdpsxds (VSX Scalar truncate Double-Precision to integer and Convert
+         //             to Signed Integer Doubleword format with Saturate)
+         DIP("xscvdpsxds v%u,v%u\n",  (UInt)XT, (UInt)XB);
+         putVSReg( XT,
                    binop( Iop_64HLtoV128, binop( Iop_F64toI64S,
                                                  mkU32( Irrm_ZERO ),
-                                                 mkexpr( frB ) ), mkU64( 0 ) ) );
-      break;
-   case 0x0b0: // xscvdpsxws (VSX Scalar truncate Double-Precision to integer and
-               //             Convert to Signed Integer Word format with Saturate)
-      DIP("xscvdpsxws v%u,v%u\n",  (UInt)XT, (UInt)XB);
-      putVSReg( XT,
+                                                 mkexpr( xB ) ), mkU64( 0 ) ) );
+         break;
+      case 0x0b0: // xscvdpsxws (VSX Scalar truncate Double-Precision to integer and
+                  //             Convert to Signed Integer Word format with Saturate)
+         DIP("xscvdpsxws v%u,v%u\n",  (UInt)XT, (UInt)XB);
+         putVSReg( XT,
                    binop( Iop_64HLtoV128,
                           unop( Iop_32Sto64,
                                 binop( Iop_F64toI32S,
                                        mkU32( Irrm_ZERO ),
-                                       mkexpr( frB ) ) ),
-                          mkU64( 0ULL ) ) );
+                                       mkexpr( xB ) ) ),
+                                       mkU64( 0ULL ) ) );
          break;
-   case 0x290: // xscvdpuxds (VSX Scalar truncate Double-Precision integer and Convert
-               //             to Unsigned Integer Doubleword format with Saturate)
-      DIP("xscvdpuxds v%u,v%u\n",  (UInt)XT, (UInt)XB);
-      putVSReg( XT,
+      case 0x290: // xscvdpuxds (VSX Scalar truncate Double-Precision integer and Convert
+                  //             to Unsigned Integer Doubleword format with Saturate)
+         DIP("xscvdpuxds v%u,v%u\n",  (UInt)XT, (UInt)XB);
+         putVSReg( XT,
                    binop( Iop_64HLtoV128,
                           binop( Iop_F64toI64U,
                                  mkU32( Irrm_ZERO ),
-                                 mkexpr( frB ) ),
-                          mkU64( 0ULL ) ) );
-      break;
-   case 0x2F0:
-      // xscvsxddp (VSX Scalar Convert and round Signed Integer Doubleword to
-      //            Double-Precision format)
-      DIP("xscvsxddp v%u,v%u\n",  (UInt)XT, (UInt)XB);
-
-      assign( r_tmp64, unop( Iop_ReinterpF64asI64, mkexpr(frB)) );
-      putVSReg( XT,
+                                 mkexpr( xB ) ),
+                                 mkU64( 0ULL ) ) );
+         break;
+      case 0x2F0:
+         // xscvsxddp (VSX Scalar Convert and round Signed Integer Doubleword to
+         //            Double-Precision format)
+         DIP("xscvsxddp v%u,v%u\n",  (UInt)XT, (UInt)XB);
+         putVSReg( XT,
                    binop( Iop_64HLtoV128, unop( Iop_ReinterpF64asI64,
                                                 binop( Iop_I64StoF64, get_IR_roundingmode(),
-                                                       mkexpr( r_tmp64 ) ) ),
-                          mkU64( 0 ) ) );
-      break;
-   case 0x2D0:
-      // xscvuxddp (VSX Scalar Convert and round Unsigned Integer Doubleword to
-      //            Double-Precision format)
-      DIP("xscvuxddp v%u,v%u\n",  (UInt)XT, (UInt)XB);
-
-      assign( r_tmp64, unop( Iop_ReinterpF64asI64, mkexpr(frB)) );
-      putVSReg( XT,
+                                                       mkexpr( xB ) ) ),
+                                                       mkU64( 0 ) ) );
+         break;
+      case 0x2D0:
+         // xscvuxddp (VSX Scalar Convert and round Unsigned Integer Doubleword to
+         //            Double-Precision format)
+         DIP("xscvuxddp v%u,v%u\n",  (UInt)XT, (UInt)XB);
+         putVSReg( XT,
                    binop( Iop_64HLtoV128, unop( Iop_ReinterpF64asI64,
                                                 binop( Iop_I64UtoF64, get_IR_roundingmode(),
-                                                       mkexpr( r_tmp64 ) ) ),
-                          mkU64( 0 ) ) );
-      break;
-
-   case 0x1b0: // xvcvdpsxws (VSX Vector truncate Double-Precision to integer and Convert
-               //             to Signed Integer Word format with Saturate)
-   {
-      IRTemp frB2 = newTemp(Ity_F64);
-      IRTemp hiResult_32 = newTemp(Ity_I32);
-      IRTemp loResult_32 = newTemp(Ity_I32);
-      IRExpr* rmZero = mkU32(Irrm_ZERO);
-
-      DIP("xvcvdpsxws v%u,v%u\n",  (UInt)XT, (UInt)XB);
-      assign(frB2, unop(Iop_ReinterpI64asF64, unop(Iop_V128to64, getVSReg( XB ))));
-      assign(hiResult_32, binop(Iop_F64toI32S, rmZero, mkexpr(frB)));
-      assign(loResult_32, binop(Iop_F64toI32S, rmZero, mkexpr(frB2)));
-      putVSReg( XT,
+                                                       mkexpr( xB ) ) ),
+                                                       mkU64( 0 ) ) );
+         break;
+      case 0x1b0: // xvcvdpsxws (VSX Vector truncate Double-Precision to integer and Convert
+                  //             to Signed Integer Word format with Saturate)
+      {
+         IRTemp hiResult_32 = newTemp(Ity_I32);
+         IRTemp loResult_32 = newTemp(Ity_I32);
+         IRExpr* rmZero = mkU32(Irrm_ZERO);
+
+         DIP("xvcvdpsxws v%u,v%u\n",  (UInt)XT, (UInt)XB);
+         assign(hiResult_32, binop(Iop_F64toI32S, rmZero, mkexpr(xB)));
+         assign(loResult_32, binop(Iop_F64toI32S, rmZero, mkexpr(xB2)));
+         putVSReg( XT,
                    binop( Iop_64HLtoV128,
                           unop( Iop_32Sto64, mkexpr( hiResult_32 ) ),
                           unop( Iop_32Sto64, mkexpr( loResult_32 ) ) ) );
-      break;
-   }
-   case 0x130: // xvcvspsxws (VSX Vector truncate Single-Precision to integer and
-               // Convert to Signed Integer Word format with Saturate)
-   {
-      IRTemp tempResult = newTemp(Ity_V128);
-      IRTemp b3, b2, b1, b0;
-      IRTemp res0 = newTemp(Ity_I32);
-      IRTemp res1 = newTemp(Ity_I32);
-      IRTemp res2 = newTemp(Ity_I32);
-      IRTemp res3 = newTemp(Ity_I32);
-      IRTemp b0_32 = newTemp(Ity_I32);
-      IRTemp b1_32 = newTemp(Ity_I32);
-      IRTemp b2_32 = newTemp(Ity_I32);
-      IRTemp b3_32 = newTemp(Ity_I32);
-      IRTemp hi64 = newTemp(Ity_I64);
-      IRTemp lo64 = newTemp(Ity_I64);
-      IRExpr * b0_result, * b1_result, * b2_result, * b3_result;
-      b3 = b2 = b1 = b0 = IRTemp_INVALID;
-
-      DIP("xvcvspsxws v%u,v%u\n",  (UInt)XT, (UInt)XB);
-      /* The xvcvspsxws instruction is similar to vctsxs, except if src is a NaN,
-       * then result is set to 0x80000000.  */
-      assign(tempResult, unop(Iop_QFtoI32Sx4_RZ, getVSReg(XB)));
-      breakV128to4x64U(getVSReg(XB), &b3, &b2, &b1, &b0);
-      assign(b3_32, unop(Iop_64to32, mkexpr(b3)));
-      assign(b2_32, unop(Iop_64to32, mkexpr(b2)));
-      assign(b1_32, unop(Iop_64to32, mkexpr(b1)));
-      assign(b0_32, unop(Iop_64to32, mkexpr(b0)));
-
-      assign( hi64, unop(Iop_V128HIto64, mkexpr(tempResult)) );
-      assign( lo64, unop(Iop_V128to64,   mkexpr(tempResult)) );
-      assign( res3, unop(Iop_64HIto32, mkexpr(hi64)) );
-      assign( res2, unop(Iop_64to32,   mkexpr(hi64)) );
-      assign( res1, unop(Iop_64HIto32, mkexpr(lo64)) );
-      assign( res0, unop(Iop_64to32,   mkexpr(lo64)) );
-
-      b3_result = IRExpr_Mux0X(unop(Iop_1Uto8, is_NaN_32(b3_32)),
-                               // else: result is from the Iop_QFtoI32Sx4_RZ
-                               mkexpr(res3),
-                               // then: result is 0x80000000
-                               mkU32(0x80000000));
-      b2_result = IRExpr_Mux0X(unop(Iop_1Uto8, is_NaN_32(b2_32)),
-                               // else: result is from the Iop_QFtoI32Sx4_RZ
-                               mkexpr(res2),
-                               // then: result is 0x80000000
-                               mkU32(0x80000000));
-      b1_result = IRExpr_Mux0X(unop(Iop_1Uto8, is_NaN_32(b1_32)),
-                               // else: result is from the Iop_QFtoI32Sx4_RZ
-                               mkexpr(res1),
-                               // then: result is 0x80000000
-                               mkU32(0x80000000));
-      b0_result = IRExpr_Mux0X(unop(Iop_1Uto8, is_NaN_32(b0_32)),
-                               // else: result is from the Iop_QFtoI32Sx4_RZ
-                               mkexpr(res0),
-                               // then: result is 0x80000000
-                               mkU32(0x80000000));
+         break;
+      }
+      case 0x130: case 0x110: // xvcvspsxws, xvcvspuxws
+         //  (VSX Vector truncate Single-Precision to integer and
+         //   Convert to [Un]signed Integer Word format with Saturate)
+      {
+         IRExpr * b0_result, * b1_result, * b2_result, * b3_result;
+         IRTemp tempResult = newTemp(Ity_V128);
+         IRTemp res0 = newTemp(Ity_I32);
+         IRTemp res1 = newTemp(Ity_I32);
+         IRTemp res2 = newTemp(Ity_I32);
+         IRTemp res3 = newTemp(Ity_I32);
+         IRTemp hi64 = newTemp(Ity_I64);
+         IRTemp lo64 = newTemp(Ity_I64);
+         Bool un_signed = (opc2 == 0x110);
+         IROp op = un_signed ? Iop_QFtoI32Ux4_RZ : Iop_QFtoI32Sx4_RZ;
+
+         DIP("xvcvsp%sxws v%u,v%u\n", un_signed ? "u" : "s", (UInt)XT, (UInt)XB);
+         /* The xvcvsp{s|u}xws instruction is similar to vct{s|u}xs, except if src is a NaN,
+          * then result is set to 0x80000000.  */
+         assign(tempResult, unop(op, getVSReg(XB)));
+         assign( hi64, unop(Iop_V128HIto64, mkexpr(tempResult)) );
+         assign( lo64, unop(Iop_V128to64,   mkexpr(tempResult)) );
+         assign( res3, unop(Iop_64HIto32, mkexpr(hi64)) );
+         assign( res2, unop(Iop_64to32,   mkexpr(hi64)) );
+         assign( res1, unop(Iop_64HIto32, mkexpr(lo64)) );
+         assign( res0, unop(Iop_64to32,   mkexpr(lo64)) );
+
+         b3_result = IRExpr_Mux0X(unop(Iop_1Uto8, is_NaN_32(b3)),
+                                  // else: result is from the Iop_QFtoI32{s|u}x4_RZ
+                                  mkexpr(res3),
+                                  // then: result is 0x{8|0}80000000
+                                  mkU32(un_signed ? 0x00000000 : 0x80000000));
+         b2_result = IRExpr_Mux0X(unop(Iop_1Uto8, is_NaN_32(b2)),
+                                  // else: result is from the Iop_QFtoI32{s|u}x4_RZ
+                                  mkexpr(res2),
+                                  // then: result is 0x{8|0}80000000
+                                  mkU32(un_signed ? 0x00000000 : 0x80000000));
+         b1_result = IRExpr_Mux0X(unop(Iop_1Uto8, is_NaN_32(b1)),
+                                  // else: result is from the Iop_QFtoI32{s|u}x4_RZ
+                                  mkexpr(res1),
+                                  // then: result is 0x{8|0}80000000
+                                  mkU32(un_signed ? 0x00000000 : 0x80000000));
+         b0_result = IRExpr_Mux0X(unop(Iop_1Uto8, is_NaN_32(b0)),
+                                  // else: result is from the Iop_QFtoI32{s|u}x4_RZ
+                                  mkexpr(res0),
+                                  // then: result is 0x{8|0}80000000
+                                  mkU32(un_signed ? 0x00000000 : 0x80000000));
 
-      putVSReg( XT,
+         putVSReg( XT,
                    binop( Iop_64HLtoV128,
                           binop( Iop_32HLto64, b3_result, b2_result ),
                           binop( Iop_32HLto64, b1_result, b0_result ) ) );
-      break;
-   }
+         break;
+      }
+      case 0x212: // xscvdpsp (VSX Scalar round Double-Precision to single-precision and
+                  //           Convert to Single-Precision format
+         DIP("xscvdpsp v%u,v%u\n",  (UInt)XT, (UInt)XB);
+         putVSReg( XT,
+                   binop( Iop_64HLtoV128,
+                          binop( Iop_32HLto64,
+                                 unop( Iop_ReinterpF32asI32,
+                                       unop( Iop_TruncF64asF32,
+                                             binop( Iop_RoundF64toF32,
+                                                    get_IR_roundingmode(),
+                                                    mkexpr( xB ) ) ) ),
+                                 mkU32( 0 ) ),
+                          mkU64( 0ULL ) ) );
+         break;
+      case 0x090: // xscvdpuxws (VSX Scalar truncate Double-Precision to integer
+                  //             and Convert to Unsigned Integer Word format with Saturate)
+         DIP("xscvdpuxws v%u,v%u\n",  (UInt)XT, (UInt)XB);
+         putVSReg( XT,
+                   binop( Iop_64HLtoV128,
+                          binop( Iop_32HLto64,
+                                 mkU32( 0 ),
+                                 binop( Iop_F64toI32U,
+                                        mkU32( Irrm_ZERO ),
+                                        mkexpr( xB ) ) ),
+                          mkU64( 0ULL ) ) );
+         break;
+      case 0x292: // xscvspdp (VSX Scalar Convert Single-Precision to Double-Precision format)
+         DIP("xscvspdp v%u,v%u\n",  (UInt)XT, (UInt)XB);
+         putVSReg( XT,
+                   binop( Iop_64HLtoV128,
+                          unop( Iop_ReinterpF64asI64,
+                                unop( Iop_F32toF64,
+                                      unop( Iop_ReinterpI32asF32, mkexpr( xB ) ) ) ),
+                          mkU64( 0ULL ) ) );
+         break;
+      case 0x312: // xvcvdpsp (VSX Vector round Double-Precision to single-precision
+                  //           and Convert to Single-Precision format)
+         DIP("xvcvdpsp v%u,v%u\n",  (UInt)XT, (UInt)XB);
+         putVSReg( XT,
+                   binop( Iop_64HLtoV128,
+                          binop( Iop_32HLto64,
+                                 unop( Iop_ReinterpF32asI32,
+                                       unop( Iop_TruncF64asF32,
+                                             binop( Iop_RoundF64toF32,
+                                                    get_IR_roundingmode(),
+                                                    mkexpr( xB ) ) ) ),
+                                 mkU32( 0 ) ),
+                          binop( Iop_32HLto64,
+                                 unop( Iop_ReinterpF32asI32,
+                                       unop( Iop_TruncF64asF32,
+                                             binop( Iop_RoundF64toF32,
+                                                    get_IR_roundingmode(),
+                                                    mkexpr( xB2 ) ) ) ),
+                                 mkU32( 0 ) ) ) );
+         break;
+      case 0x390: // xvcvdpuxds (VSX Vector truncate Double-Precision to integer
+                  //             and Convert to Unsigned Integer Doubleword format
+                  //             with Saturate)
+         DIP("xvcvdpuxds v%u,v%u\n",  (UInt)XT, (UInt)XB);
+         putVSReg( XT,
+                   binop( Iop_64HLtoV128,
+                          binop( Iop_F64toI64U, mkU32( Irrm_ZERO ), mkexpr( xB ) ),
+                          binop( Iop_F64toI64U, mkU32( Irrm_ZERO ), mkexpr( xB2 ) ) ) );
+         break;
+      case 0x190: // xvcvdpuxws (VSX Vector truncate Double-Precision to integer and
+                  //             Convert to Unsigned Integer Word format with Saturate)
+         DIP("xvcvdpuxws v%u,v%u\n",  (UInt)XT, (UInt)XB);
+         putVSReg( XT,
+                   binop( Iop_64HLtoV128,
+                          binop( Iop_32HLto64,
+                                 binop( Iop_F64toI32U,
+                                        mkU32( Irrm_ZERO ),
+                                        mkexpr( xB ) ),
+                                 mkU32( 0 ) ),
+                          binop( Iop_32HLto64,
+                                 binop( Iop_F64toI32U,
+                                        mkU32( Irrm_ZERO ),
+                                        mkexpr( xB2 ) ),
+                                 mkU32( 0 ) ) ) );
+         break;
+      case 0x392: // xvcvspdp (VSX Vector Convert Single-Precision to Double-Precision format)
+         DIP("xvcvspdp v%u,v%u\n",  (UInt)XT, (UInt)XB);
+         putVSReg( XT,
+                   binop( Iop_64HLtoV128,
+                          unop( Iop_ReinterpF64asI64,
+                                unop( Iop_F32toF64,
+                                      unop( Iop_ReinterpI32asF32, mkexpr( b3 ) ) ) ),
+                          unop( Iop_ReinterpF64asI64,
+                                unop( Iop_F32toF64,
+                                      unop( Iop_ReinterpI32asF32, mkexpr( b1 ) ) ) ) ) );
+         break;
+      case 0x330: // xvcvspsxds (VSX Vector truncate Single-Precision to integer and
+                  //           Convert to Signed Integer Doubleword format with Saturate)
+         DIP("xvcvspsxds v%u,v%u\n",  (UInt)XT, (UInt)XB);
+         putVSReg( XT,
+                   binop( Iop_64HLtoV128,
+                          binop( Iop_F64toI64S,
+                                 mkU32( Irrm_ZERO ),
+                                 unop( Iop_F32toF64,
+                                       unop( Iop_ReinterpI32asF32, mkexpr( b3 ) ) ) ),
+                          binop( Iop_F64toI64S,
+                                 mkU32( Irrm_ZERO ),
+                                 unop( Iop_F32toF64,
+                                       unop( Iop_ReinterpI32asF32, mkexpr( b1 ) ) ) ) ) );
+         break;
+      case 0x310: // xvcvspuxds (VSX Vector truncate Single-Precision to integer and
+                  //            Convert to Unsigned Integer Doubleword format with Saturate)
+         DIP("xvcvspuxds v%u,v%u\n",  (UInt)XT, (UInt)XB);
+         putVSReg( XT,
+                   binop( Iop_64HLtoV128,
+                          binop( Iop_F64toI64U,
+                                 mkU32( Irrm_ZERO ),
+                                 unop( Iop_F32toF64,
+                                       unop( Iop_ReinterpI32asF32, mkexpr( b3 ) ) ) ),
+                          binop( Iop_F64toI64U,
+                                 mkU32( Irrm_ZERO ),
+                                 unop( Iop_F32toF64,
+                                       unop( Iop_ReinterpI32asF32, mkexpr( b1 ) ) ) ) ) );
+         break;
+      case 0x3B0: // xvcvdpsxds (VSX Vector truncate Double-Precision to integer and
+                  //             Convert to Signed Integer Doubleword format with Saturate)
+         DIP("xvcvdpsxds v%u,v%u\n",  (UInt)XT, (UInt)XB);
+         putVSReg( XT,
+                   binop( Iop_64HLtoV128,
+                          binop( Iop_F64toI64S, mkU32( Irrm_ZERO ), mkexpr( xB ) ),
+                          binop( Iop_F64toI64S, mkU32( Irrm_ZERO ), mkexpr( xB2 ) ) ) );
+         break;
+      case 0x3f0: // xvcvsxddp (VSX Vector Convert and round Signed Integer Doubleword
+                  //            to Double-Precision format)
+         DIP("xvcvsxddp v%u,v%u\n",  (UInt)XT, (UInt)XB);
+         putVSReg( XT,
+                   binop( Iop_64HLtoV128,
+                          unop( Iop_ReinterpF64asI64,
+                                binop( Iop_I64StoF64,
+                                       get_IR_roundingmode(),
+                                       mkexpr( xB ) ) ),
+                          unop( Iop_ReinterpF64asI64,
+                                binop( Iop_I64StoF64,
+                                       get_IR_roundingmode(),
+                                       mkexpr( xB2 ) ) ) ) );
+         break;
+      case 0x3d0: // xvcvuxddp (VSX Vector Convert and round Unsigned Integer Doubleword
+                  //            to Double-Precision format)
+         DIP("xvcvuxddp v%u,v%u\n",  (UInt)XT, (UInt)XB);
+         putVSReg( XT,
+                   binop( Iop_64HLtoV128,
+                          unop( Iop_ReinterpF64asI64,
+                                binop( Iop_I64UtoF64,
+                                       get_IR_roundingmode(),
+                                       mkexpr( xB ) ) ),
+                          unop( Iop_ReinterpF64asI64,
+                                binop( Iop_I64UtoF64,
+                                       get_IR_roundingmode(),
+                                       mkexpr( xB2 ) ) ) ) );
 
-   default:
-      vex_printf( "dis_vx_conv(ppc)(opc2)\n" );
-      return False;
+         break;
+      case 0x370: // xvcvsxdsp (VSX Vector Convert and round Signed Integer Doubleword
+                  //            to Single-Precision format)
+         DIP("xvcvsxddp v%u,v%u\n",  (UInt)XT, (UInt)XB);
+         putVSReg( XT,
+                   binop( Iop_64HLtoV128,
+                          binop( Iop_32HLto64,
+                                 unop( Iop_ReinterpF32asI32,
+                                       unop( Iop_TruncF64asF32,
+                                             binop( Iop_RoundF64toF32,
+                                                    get_IR_roundingmode(),
+                                                    binop( Iop_I64StoF64,
+                                                           get_IR_roundingmode(),
+                                                           mkexpr( xB ) ) ) ) ),
+                                 mkU32( 0 ) ),
+                          binop( Iop_32HLto64,
+                                 unop( Iop_ReinterpF32asI32,
+                                       unop( Iop_TruncF64asF32,
+                                             binop( Iop_RoundF64toF32,
+                                                    get_IR_roundingmode(),
+                                                    binop( Iop_I64StoF64,
+                                                           get_IR_roundingmode(),
+                                                           mkexpr( xB2 ) ) ) ) ),
+                                 mkU32( 0 ) ) ) );
+         break;
+      case 0x350: // xvcvuxdsp (VSX Vector Convert and round Unsigned Integer Doubleword
+                  //            to Single-Precision format)
+         DIP("xvcvuxddp v%u,v%u\n", (UInt)XT, (UInt)XB);
+         putVSReg( XT,
+                   binop( Iop_64HLtoV128,
+                          binop( Iop_32HLto64,
+                                 unop( Iop_ReinterpF32asI32,
+                                       unop( Iop_TruncF64asF32,
+                                             binop( Iop_RoundF64toF32,
+                                                    get_IR_roundingmode(),
+                                                    binop( Iop_I64UtoF64,
+                                                           get_IR_roundingmode(),
+                                                           mkexpr( xB ) ) ) ) ),
+                                 mkU32( 0 ) ),
+                          binop( Iop_32HLto64,
+                                 unop( Iop_ReinterpF32asI32,
+                                       unop( Iop_TruncF64asF32,
+                                             binop( Iop_RoundF64toF32,
+                                                    get_IR_roundingmode(),
+                                                    binop( Iop_I64UtoF64,
+                                                           get_IR_roundingmode(),
+                                                           mkexpr( xB2 ) ) ) ) ),
+                                 mkU32( 0 ) ) ) );
+         break;
+
+      case 0x1f0: // xvcvsxwdp (VSX Vector Convert Signed Integer Word to Double-Precision format)
+         DIP("xvcvsxwdp v%u,v%u\n",  (UInt)XT, (UInt)XB);
+         putVSReg( XT,
+                   binop( Iop_64HLtoV128,
+                          unop( Iop_ReinterpF64asI64,
+                                binop( Iop_I64StoF64, get_IR_roundingmode(),
+                                       unop( Iop_32Sto64, mkexpr( b3 ) ) ) ),
+                          unop( Iop_ReinterpF64asI64,
+                                binop( Iop_I64StoF64, get_IR_roundingmode(),
+                                       unop( Iop_32Sto64, mkexpr( b1 ) ) ) ) ) );
+         break;
+      case 0x1d0: // xvcvuxwdp (VSX Vector Convert Unsigned Integer Word to Double-Precision format)
+         DIP("xvcvuxwdp v%u,v%u\n",  (UInt)XT, (UInt)XB);
+         putVSReg( XT,
+                   binop( Iop_64HLtoV128,
+                          unop( Iop_ReinterpF64asI64,
+                                binop( Iop_I64UtoF64, get_IR_roundingmode(),
+                                       unop( Iop_32Uto64, mkexpr( b3 ) ) ) ),
+                          unop( Iop_ReinterpF64asI64,
+                                binop( Iop_I64UtoF64, get_IR_roundingmode(),
+                                       unop( Iop_32Uto64, mkexpr( b1 ) ) ) ) ) );
+         break;
+      case 0x170: // xvcvsxwsp (VSX Vector Convert Signed Integer Word to Single-Precision format)
+         DIP("xvcvsxwsp v%u,v%u\n",  (UInt)XT, (UInt)XB);
+         putVSReg( XT, unop( Iop_I32StoFx4, getVSReg( XB ) ) );
+         break;
+      case 0x150: // xvcvuxwsp (VSX Vector Convert Unsigned Integer Word to Single-Precision format)
+         DIP("xvcvuxwsp v%u,v%u\n",  (UInt)XT, (UInt)XB);
+         putVSReg( XT, unop( Iop_I32UtoFx4, getVSReg( XB ) ) );
+         break;
+
+      default:
+         vex_printf( "dis_vx_conv(ppc)(opc2)\n" );
+         return False;
    }
    return True;
 }
@@ -8379,7 +8972,22 @@ dis_vxv_dp_arith ( UInt theInstr, UInt o
                    binop( Iop_64HLtoV128, mkexpr( hiResult ), mkexpr( loResult ) ) );
          break;
       }
+      case 0x196: // xvsqrtdp
+      {
+         IRTemp hiResult = newTemp(Ity_I64);
+         IRTemp loResult = newTemp(Ity_I64);
+         DIP("xvsqrtdp v%d,v%d\n", (UInt)XT, (UInt)XB);
 
+         assign( hiResult,
+                 unop( Iop_ReinterpF64asI64,
+                       binop( Iop_SqrtF64, rm, mkexpr( frB ) ) ) );
+         assign( loResult,
+                 unop( Iop_ReinterpF64asI64,
+                       binop( Iop_SqrtF64, rm, mkexpr( frB2 ) ) ) );
+         putVSReg( XT,
+                   binop( Iop_64HLtoV128, mkexpr( hiResult ), mkexpr( loResult ) ) );
+         break;
+      }
       case 0x184: case 0x1A4: // xvmaddadp, xvmaddmdp (VSX Vector Multiply-Add Double-Precision)
       case 0x1C4: case 0x1E4: // xvmsubadp, xvmsubmdp (VSX Vector Multiply-Subtract Double-Precision)
       case 0x384: case 0x3A4: // xvnmaddadp, xvnmaddmdp (VSX Vector Negate Multiply-Add Double-Precision)
@@ -8458,6 +9066,77 @@ dis_vxv_dp_arith ( UInt theInstr, UInt o
                                          : loResult ) ) );
          break;
       }
+      case 0x1D4: // xvtsqrtdp (VSX Vector Test for software Square Root Double-Precision)
+      {
+         IRTemp frBHi_I64 = newTemp(Ity_I64);
+         IRTemp frBLo_I64 = newTemp(Ity_I64);
+         IRTemp flagsHi = newTemp(Ity_I32);
+         IRTemp flagsLo = newTemp(Ity_I32);
+         UChar crfD     = toUChar( IFIELD( theInstr, 23, 3 ) );
+         IRTemp  fe_flagHi, fg_flagHi, fe_flagLo, fg_flagLo;
+         fe_flagHi = fg_flagHi = fe_flagLo = fg_flagLo = IRTemp_INVALID;
+
+         DIP("xvtsqrtdp cr%d,v%d\n", (UInt)crfD, (UInt)XB);
+         assign( frBHi_I64, unop(Iop_V128HIto64, getVSReg( XB )) );
+         assign( frBLo_I64, unop(Iop_V128to64, getVSReg( XB )) );
+         do_fp_tsqrt(frBHi_I64, False /*not single precision*/, &fe_flagHi, &fg_flagHi);
+         do_fp_tsqrt(frBLo_I64, False /*not single precision*/, &fe_flagLo, &fg_flagLo);
+         /* The CR field consists of fl_flag || fg_flag || fe_flag || 0b0
+          * where fl_flag == 1 on ppc64.
+          */
+         assign( flagsHi,
+                 binop( Iop_Or32,
+                        binop( Iop_Or32, mkU32( 8 ), // fl_flag
+                               binop( Iop_Shl32, mkexpr(fg_flagHi), mkU8( 2 ) ) ),
+                        binop( Iop_Shl32, mkexpr(fe_flagHi), mkU8( 1 ) ) ) );
+         assign( flagsLo,
+                 binop( Iop_Or32,
+                        binop( Iop_Or32, mkU32( 8 ), // fl_flag
+                               binop( Iop_Shl32, mkexpr(fg_flagLo), mkU8( 2 ) ) ),
+                        binop( Iop_Shl32, mkexpr(fe_flagLo), mkU8( 1 ) ) ) );
+         putGST_field( PPC_GST_CR,
+                       binop( Iop_Or32, mkexpr( flagsHi ), mkexpr( flagsLo ) ),
+                       crfD );
+         break;
+      }
+      case 0x1F4: // xvtdivdp (VSX Vector Test for software Divide Double-Precision)
+      {
+         IRTemp frBHi_I64 = newTemp(Ity_I64);
+         IRTemp frBLo_I64 = newTemp(Ity_I64);
+         IRTemp frAHi_I64 = newTemp(Ity_I64);
+         IRTemp frALo_I64 = newTemp(Ity_I64);
+         IRTemp flagsHi = newTemp(Ity_I32);
+         IRTemp flagsLo = newTemp(Ity_I32);
+         UChar crfD     = toUChar( IFIELD( theInstr, 23, 3 ) );
+         IRTemp  fe_flagHi, fg_flagHi, fe_flagLo, fg_flagLo;
+         fe_flagHi = fg_flagHi = fe_flagLo = fg_flagLo = IRTemp_INVALID;
+
+         DIP("xvtdivdp cr%d,v%d,v%d\n", (UInt)crfD, (UInt)XA, (UInt)XB);
+         assign( frAHi_I64, unop(Iop_V128HIto64, getVSReg( XA )) );
+         assign( frALo_I64, unop(Iop_V128to64, getVSReg( XA )) );
+         assign( frBHi_I64, unop(Iop_V128HIto64, getVSReg( XB )) );
+         assign( frBLo_I64, unop(Iop_V128to64, getVSReg( XB )) );
+
+         _do_fp_tdiv(frAHi_I64, frBHi_I64, False/*dp*/, &fe_flagHi, &fg_flagHi);
+         _do_fp_tdiv(frALo_I64, frBLo_I64, False/*dp*/, &fe_flagLo, &fg_flagLo);
+         /* The CR field consists of fl_flag || fg_flag || fe_flag || 0b0
+          * where fl_flag == 1 on ppc64.
+          */
+         assign( flagsHi,
+                 binop( Iop_Or32,
+                        binop( Iop_Or32, mkU32( 8 ), // fl_flag
+                               binop( Iop_Shl32, mkexpr(fg_flagHi), mkU8( 2 ) ) ),
+                        binop( Iop_Shl32, mkexpr(fe_flagHi), mkU8( 1 ) ) ) );
+         assign( flagsLo,
+                 binop( Iop_Or32,
+                        binop( Iop_Or32, mkU32( 8 ), // fl_flag
+                               binop( Iop_Shl32, mkexpr(fg_flagLo), mkU8( 2 ) ) ),
+                        binop( Iop_Shl32, mkexpr(fe_flagLo), mkU8( 1 ) ) ) );
+         putGST_field( PPC_GST_CR,
+                       binop( Iop_Or32, mkexpr( flagsHi ), mkexpr( flagsLo ) ),
+                       crfD );
+         break;
+      }
 
       default:
          vex_printf( "dis_vxv_dp_arith(ppc)(opc2)\n" );
@@ -8546,6 +9225,39 @@ dis_vxv_sp_arith ( UInt theInstr, UInt o
                           binop( Iop_32HLto64, mkexpr( res1 ), mkexpr( res0 ) ) ) );
          break;
       }
+      case 0x116: // xvsqrtsp (VSX Vector Square Root Single-Precision)
+      {
+         DIP("xvsqrtsp v%d,v%d\n", (UInt)XT, (UInt)XB);
+         breakV128to4xF64( getVSReg( XB ), &b3, &b2, &b1, &b0 );
+         /* Note: The native xvsqrtsp insruction does not always give the same precision
+          * as what we get with Iop_SqrtF64.  But it doesn't seem worthwhile to implement
+          * an Iop_SqrtF32 that would give us a lower precision result, albeit more true
+          * to the actual instruction.
+          */
+
+         assign( res0,
+                 unop( Iop_ReinterpF32asI32,
+                       unop( Iop_TruncF64asF32,
+                             binop(Iop_SqrtF64, rm, mkexpr( b0 ) ) ) ) );
+         assign( res1,
+                 unop( Iop_ReinterpF32asI32,
+                       unop( Iop_TruncF64asF32,
+                             binop(Iop_SqrtF64, rm, mkexpr( b1 ) ) ) ) );
+         assign( res2,
+                 unop( Iop_ReinterpF32asI32,
+                       unop( Iop_TruncF64asF32,
+                             binop(Iop_SqrtF64, rm, mkexpr( b2) ) ) ) );
+         assign( res3,
+                 unop( Iop_ReinterpF32asI32,
+                       unop( Iop_TruncF64asF32,
+                             binop(Iop_SqrtF64, rm, mkexpr( b3 ) ) ) ) );
+
+         putVSReg( XT,
+                   binop( Iop_64HLtoV128,
+                          binop( Iop_32HLto64, mkexpr( res3 ), mkexpr( res2 ) ),
+                          binop( Iop_32HLto64, mkexpr( res1 ), mkexpr( res0 ) ) ) );
+         break;
+      }
 
       case 0x104: case 0x124: // xvmaddasp, xvmaddmsp (VSX Vector Multiply-Add Single-Precision)
       case 0x144: case 0x164: // xvmsubasp, xvmsubmsp (VSX Vector Multiply-Subtract Single-Precision)
@@ -8636,6 +9348,115 @@ dis_vxv_sp_arith ( UInt theInstr, UInt o
 
          break;
       }
+      case 0x154: // xvtsqrtsp (VSX Vector Test for software Square Root Single-Precision)
+      {
+         IRTemp flags0 = newTemp(Ity_I32);
+         IRTemp flags1 = newTemp(Ity_I32);
+         IRTemp flags2 = newTemp(Ity_I32);
+         IRTemp flags3 = newTemp(Ity_I32);
+         UChar crfD     = toUChar( IFIELD( theInstr, 23, 3 ) );
+         IRTemp  fe_flag0, fg_flag0, fe_flag1, fg_flag1;
+         IRTemp  fe_flag2, fg_flag2, fe_flag3, fg_flag3;
+         fe_flag0 = fg_flag0 = fe_flag1 = fg_flag1 = IRTemp_INVALID;
+         fe_flag2 = fg_flag2 = fe_flag3 = fg_flag3 = IRTemp_INVALID;
+         DIP("xvtsqrtsp cr%d,v%d\n", (UInt)crfD, (UInt)XB);
+
+         breakV128to4x32( getVSReg( XB ), &b3, &b2, &b1, &b0 );
+         do_fp_tsqrt(b0, True /* single precision*/, &fe_flag0, &fg_flag0);
+         do_fp_tsqrt(b1, True /* single precision*/, &fe_flag1, &fg_flag1);
+         do_fp_tsqrt(b2, True /* single precision*/, &fe_flag2, &fg_flag2);
+         do_fp_tsqrt(b3, True /* single precision*/, &fe_flag3, &fg_flag3);
+
+         /* The CR field consists of fl_flag || fg_flag || fe_flag || 0b0
+          * where fl_flag == 1 on ppc64.
+          */
+         assign( flags0,
+                 binop( Iop_Or32,
+                        binop( Iop_Or32, mkU32( 8 ), // fl_flag
+                               binop( Iop_Shl32, mkexpr(fg_flag0), mkU8( 2 ) ) ),
+                        binop( Iop_Shl32, mkexpr(fe_flag0), mkU8( 1 ) ) ) );
+         assign( flags1,
+                 binop( Iop_Or32,
+                        binop( Iop_Or32, mkU32( 8 ), // fl_flag
+                               binop( Iop_Shl32, mkexpr(fg_flag1), mkU8( 2 ) ) ),
+                        binop( Iop_Shl32, mkexpr(fe_flag1), mkU8( 1 ) ) ) );
+         assign( flags2,
+                 binop( Iop_Or32,
+                        binop( Iop_Or32, mkU32( 8 ), // fl_flag
+                               binop( Iop_Shl32, mkexpr(fg_flag2), mkU8( 2 ) ) ),
+                        binop( Iop_Shl32, mkexpr(fe_flag2), mkU8( 1 ) ) ) );
+         assign( flags3,
+                 binop( Iop_Or32,
+                        binop( Iop_Or32, mkU32( 8 ), // fl_flag
+                               binop( Iop_Shl32, mkexpr(fg_flag3), mkU8( 2 ) ) ),
+                        binop( Iop_Shl32, mkexpr(fe_flag3), mkU8( 1 ) ) ) );
+         putGST_field( PPC_GST_CR,
+                       binop( Iop_Or32,
+                              mkexpr( flags0 ),
+                              binop( Iop_Or32,
+                                     mkexpr( flags1 ),
+                                     binop( Iop_Or32,
+                                            mkexpr( flags2 ),
+                                            mkexpr( flags3 ) ) ) ),
+                       crfD );
+
+         break;
+      }
+      case 0x174: // xvtdivsp (VSX Vector Test for software Divide Single-Precision)
+      {
+         IRTemp flags0 = newTemp(Ity_I32);
+         IRTemp flags1 = newTemp(Ity_I32);
+         IRTemp flags2 = newTemp(Ity_I32);
+         IRTemp flags3 = newTemp(Ity_I32);
+         UChar crfD     = toUChar( IFIELD( theInstr, 23, 3 ) );
+         IRTemp  fe_flag0, fg_flag0, fe_flag1, fg_flag1;
+         IRTemp  fe_flag2, fg_flag2, fe_flag3, fg_flag3;
+         fe_flag0 = fg_flag0 = fe_flag1 = fg_flag1 = IRTemp_INVALID;
+         fe_flag2 = fg_flag2 = fe_flag3 = fg_flag3 = IRTemp_INVALID;
+         DIP("xvtdivsp cr%d,v%d,v%d\n", (UInt)crfD, (UInt)XA, (UInt)XB);
+
+         breakV128to4x32( getVSReg( XA ), &a3, &a2, &a1, &a0 );
+         breakV128to4x32( getVSReg( XB ), &b3, &b2, &b1, &b0 );
+         _do_fp_tdiv(a0, b0, True /* single precision*/, &fe_flag0, &fg_flag0);
+         _do_fp_tdiv(a1, b1, True /* single precision*/, &fe_flag1, &fg_flag1);
+         _do_fp_tdiv(a2, b2, True /* single precision*/, &fe_flag2, &fg_flag2);
+         _do_fp_tdiv(a3, b3, True /* single precision*/, &fe_flag3, &fg_flag3);
+
+         /* The CR field consists of fl_flag || fg_flag || fe_flag || 0b0
+          * where fl_flag == 1 on ppc64.
+          */
+         assign( flags0,
+                 binop( Iop_Or32,
+                        binop( Iop_Or32, mkU32( 8 ), // fl_flag
+                               binop( Iop_Shl32, mkexpr(fg_flag0), mkU8( 2 ) ) ),
+                        binop( Iop_Shl32, mkexpr(fe_flag0), mkU8( 1 ) ) ) );
+         assign( flags1,
+                 binop( Iop_Or32,
+                        binop( Iop_Or32, mkU32( 8 ), // fl_flag
+                               binop( Iop_Shl32, mkexpr(fg_flag1), mkU8( 2 ) ) ),
+                        binop( Iop_Shl32, mkexpr(fe_flag1), mkU8( 1 ) ) ) );
+         assign( flags2,
+                 binop( Iop_Or32,
+                        binop( Iop_Or32, mkU32( 8 ), // fl_flag
+                               binop( Iop_Shl32, mkexpr(fg_flag2), mkU8( 2 ) ) ),
+                        binop( Iop_Shl32, mkexpr(fe_flag2), mkU8( 1 ) ) ) );
+         assign( flags3,
+                 binop( Iop_Or32,
+                        binop( Iop_Or32, mkU32( 8 ), // fl_flag
+                               binop( Iop_Shl32, mkexpr(fg_flag3), mkU8( 2 ) ) ),
+                        binop( Iop_Shl32, mkexpr(fe_flag3), mkU8( 1 ) ) ) );
+         putGST_field( PPC_GST_CR,
+                       binop( Iop_Or32,
+                              mkexpr( flags0 ),
+                              binop( Iop_Or32,
+                                     mkexpr( flags1 ),
+                                     binop( Iop_Or32,
+                                            mkexpr( flags2 ),
+                                            mkexpr( flags3 ) ) ) ),
+                       crfD );
+
+         break;
+      }
 
       default:
          vex_printf( "dis_vxv_sp_arith(ppc)(opc2)\n" );
@@ -8808,8 +9629,8 @@ static IRExpr * get_max_min_fp(IRTemp fr
    IRTemp anyNaN = newTemp(Ity_I1);
    IRTemp frA_isZero = newTemp(Ity_I1);
    IRTemp frB_isZero = newTemp(Ity_I1);
-   assign(frA_isZero, is_Zero(frA_I64));
-   assign(frB_isZero, is_Zero(frB_I64));
+   assign(frA_isZero, is_Zero(frA_I64, False /*not single precision*/ ));
+   assign(frB_isZero, is_Zero(frB_I64, False /*not single precision*/ ));
    assign(anyNaN, mkOR1(is_NaN(frA_I64), is_NaN(frB_I64)));
 #define MINUS_ZERO 0x8000000000000000ULL
 
@@ -8833,6 +9654,95 @@ static IRExpr * get_max_min_fp(IRTemp fr
                                       mkexpr( frB_I64 ),
                                       mkU64( isMin ? MINUS_ZERO : 0ULL ) ) );
 }
+
+/*
+ * Helper function for vector/scalar double precision fp round to integer instructions.
+ */
+static IRExpr * _do_vsx_fp_roundToInt(IRTemp frB_I64, UInt opc2, UChar * insn_suffix)
+{
+
+   /* The same rules apply for x{s|v}rdpi{m|p|c|z} as for floating point round operations (fri{m|n|p|z}). */
+   IRTemp frB = newTemp(Ity_F64);
+   IRTemp frD = newTemp(Ity_F64);
+   IRTemp intermediateResult = newTemp(Ity_I64);
+   IRTemp is_SNAN = newTemp(Ity_I1);
+   IRExpr * hi32;
+   IRExpr * rxpi_rm;
+   switch (opc2 & 0x7F) {
+      case 0x72:
+         insn_suffix = "m";
+         rxpi_rm = mkU32(Irrm_NegINF);
+         break;
+      case 0x52:
+         insn_suffix = "p";
+         rxpi_rm = mkU32(Irrm_PosINF);
+         break;
+      case 0x56:
+         insn_suffix = "c";
+         rxpi_rm = get_IR_roundingmode();
+         break;
+      case 0x32:
+         insn_suffix = "z";
+         rxpi_rm = mkU32(Irrm_ZERO);
+         break;
+      case 0x12:
+         insn_suffix = "";
+         rxpi_rm = mkU32(Irrm_NEAREST);
+         break;
+
+      default: // Impossible to get here
+         vex_printf( "_do_vsx_fp_roundToInt(ppc)(opc2)\n" );
+         return NULL;
+   }
+   assign(frB, unop(Iop_ReinterpI64asF64, mkexpr(frB_I64)));
+   assign( intermediateResult,
+           binop( Iop_F64toI64S, rxpi_rm,
+                  mkexpr( frB ) ) );
+
+   /* don't use the rounded integer if frB is outside -9e18..9e18 */
+   /* F64 has only log10(2**52) significant digits anyway */
+   /* need to preserve sign of zero */
+   /*   frD = (fabs(frB) > 9e18) ? frB :
+            (sign(frB)) ? -fabs((double)intermediateResult) : (double)intermediateResult  */
+   assign( frD,
+           IRExpr_Mux0X( unop( Iop_32to8,
+                               binop( Iop_CmpF64,
+                                      IRExpr_Const( IRConst_F64( 9e18 ) ),
+                                      unop( Iop_AbsF64, mkexpr( frB ) ) ) ),
+                         IRExpr_Mux0X( unop( Iop_32to8,
+                                             binop( Iop_Shr32,
+                                                    unop( Iop_64HIto32,
+                                                          mkexpr( frB_I64 ) ),
+                                                    mkU8( 31 ) ) ),
+                                       binop( Iop_I64StoF64,
+                                              mkU32( 0 ),
+                                              mkexpr( intermediateResult ) ),
+                                       unop( Iop_NegF64,
+                                             unop( Iop_AbsF64,
+                                                   binop( Iop_I64StoF64,
+                                                          mkU32( 0 ),
+                                                          mkexpr( intermediateResult ) ) ) ) ),
+                         mkexpr( frB ) ) );
+
+   /* See Appendix "Floating-Point Round to Integer Model" in ISA doc.
+    * If frB is a SNAN, then frD <- frB, with bit 12 set to '1'.
+    */
+#define SNAN_MASK 0x0008000000000000ULL
+   hi32 = unop( Iop_64HIto32, mkexpr(frB_I64) );
+   assign( is_SNAN,
+           mkAND1( is_NaN( frB_I64 ),
+                   binop( Iop_CmpEQ32,
+                          binop( Iop_And32, hi32, mkU32( 0x00080000 ) ),
+                          mkU32( 0 ) ) ) );
+
+   return IRExpr_Mux0X( unop( Iop_1Uto8, mkexpr( is_SNAN ) ),
+                        mkexpr( frD ),
+                        unop( Iop_ReinterpI64asF64,
+                              binop( Iop_Xor64,
+                                     mkU64( SNAN_MASK ),
+                                     mkexpr( frB_I64 ) ) ) );
+}
+
 /*
  * Miscellaneous VSX vector instructions
  */
@@ -8850,35 +9760,106 @@ dis_vxv_misc ( UInt theInstr, UInt opc2
    }
 
    switch (opc2) {
+      case 0x1B4:  // xvredp (VSX Vector Reciprocal Estimate Double-Precision)
+      case 0x194:  // xvrsqrtedp (VSX Vector Reciprocal Square Root Estimate
+                   //             Double-Precision)
+      {
+         IRExpr* ieee_one = IRExpr_Const(IRConst_F64i(0x3ff0000000000000ULL));
+         IRExpr* rm  = get_IR_roundingmode();
+         IRTemp frB = newTemp(Ity_I64);
+         IRTemp frB2 = newTemp(Ity_I64);
+         Bool redp = opc2 == 0x1B4;
+         IRTemp sqrtHi = newTemp(Ity_F64);
+         IRTemp sqrtLo = newTemp(Ity_F64);
+         assign(frB,  unop(Iop_V128HIto64, getVSReg( XB )));
+         assign(frB2, unop(Iop_V128to64, getVSReg( XB )));
+
+         DIP("%s v%d,v%d\n", redp ? "xvredp" : "xvrsqrtedp", (UInt)XT, (UInt)XB);
+         if (!redp) {
+            assign( sqrtHi,
+                    binop( Iop_SqrtF64,
+                           rm,
+                           unop( Iop_ReinterpI64asF64, mkexpr( frB ) ) ) );
+            assign( sqrtLo,
+                    binop( Iop_SqrtF64,
+                           rm,
+                           unop( Iop_ReinterpI64asF64, mkexpr( frB2 ) ) ) );
+         }
+         putVSReg( XT,
+                   binop( Iop_64HLtoV128,
+                          unop( Iop_ReinterpF64asI64,
+                                triop( Iop_DivF64,
+                                       rm,
+                                       ieee_one,
+                                       redp ? unop( Iop_ReinterpI64asF64,
+                                                    mkexpr( frB ) )
+                                            : mkexpr( sqrtHi ) ) ),
+                          unop( Iop_ReinterpF64asI64,
+                                triop( Iop_DivF64,
+                                       rm,
+                                       ieee_one,
+                                       redp ? unop( Iop_ReinterpI64asF64,
+                                                    mkexpr( frB2 ) )
+                                            : mkexpr( sqrtLo ) ) ) ) );
+         break;
+
+      }
       case 0x134: // xvresp (VSX Vector Reciprocal Estimate Single-Precision)
+      case 0x114: // xvrsqrtesp (VSX Vector Reciprocal Square Root Estimate Single-Precision)
       {
          IRTemp b3, b2, b1, b0;
          IRTemp res0 = newTemp(Ity_I32);
          IRTemp res1 = newTemp(Ity_I32);
          IRTemp res2 = newTemp(Ity_I32);
          IRTemp res3 = newTemp(Ity_I32);
+         IRTemp sqrt3 = newTemp(Ity_F64);
+         IRTemp sqrt2 = newTemp(Ity_F64);
+         IRTemp sqrt1 = newTemp(Ity_F64);
+         IRTemp sqrt0 = newTemp(Ity_F64);
          IRExpr* rm  = get_IR_roundingmode();
+         Bool resp = opc2 == 0x134;
+
          IRExpr* ieee_one = IRExpr_Const(IRConst_F64i(0x3ff0000000000000ULL));
 
          b3 = b2 = b1 = b0 = IRTemp_INVALID;
-         DIP("xvresp v%d,v%d\n", (UInt)XT, (UInt)XB);
+         DIP("%s v%d,v%d\n", resp ? "xvresp" : "xvrsqrtesp", (UInt)XT, (UInt)XB);
          breakV128to4xF64( getVSReg( XB ), &b3, &b2, &b1, &b0 );
+
+         if (!resp) {
+            assign( sqrt3, binop( Iop_SqrtF64, rm, mkexpr( b3 ) ) );
+            assign( sqrt2, binop( Iop_SqrtF64, rm, mkexpr( b2 ) ) );
+            assign( sqrt1, binop( Iop_SqrtF64, rm, mkexpr( b1 ) ) );
+            assign( sqrt0, binop( Iop_SqrtF64, rm, mkexpr( b0 ) ) );
+         }
+
          assign( res0,
                  unop( Iop_ReinterpF32asI32,
                        unop( Iop_TruncF64asF32,
-                             triop( Iop_DivF64r32, rm, ieee_one, mkexpr( b0 ) ) ) ) );
+                             triop( Iop_DivF64r32,
+                                    rm,
+                                    ieee_one,
+                                    resp ? mkexpr( b0 ) : mkexpr( sqrt0 ) ) ) ) );
          assign( res1,
                  unop( Iop_ReinterpF32asI32,
                        unop( Iop_TruncF64asF32,
-                             triop( Iop_DivF64r32, rm, ieee_one, mkexpr( b1 ) ) ) ) );
+                             triop( Iop_DivF64r32,
+                                    rm,
+                                    ieee_one,
+                                    resp ? mkexpr( b1 ) : mkexpr( sqrt1 ) ) ) ) );
          assign( res2,
                  unop( Iop_ReinterpF32asI32,
                        unop( Iop_TruncF64asF32,
-                             triop( Iop_DivF64r32, rm, ieee_one, mkexpr( b2 ) ) ) ) );
+                             triop( Iop_DivF64r32,
+                                    rm,
+                                    ieee_one,
+                                    resp ? mkexpr( b2 ) : mkexpr( sqrt2 ) ) ) ) );
          assign( res3,
                  unop( Iop_ReinterpF32asI32,
                        unop( Iop_TruncF64asF32,
-                             triop( Iop_DivF64r32, rm, ieee_one, mkexpr( b3 ) ) ) ) );
+                             triop( Iop_DivF64r32,
+                                    rm,
+                                    ieee_one,
+                                    resp ? mkexpr( b3 ) : mkexpr( sqrt3 ) ) ) ) );
          putVSReg( XT,
                    binop( Iop_64HLtoV128,
                           binop( Iop_32HLto64, mkexpr( res3 ), mkexpr( res2 ) ),
@@ -9046,6 +10027,181 @@ dis_vxv_misc ( UInt theInstr, UInt opc2
          putVSReg( XT, binop( Iop_64HLtoV128, mkexpr( resHi ), mkexpr( resLo ) ) );
          break;
       }
+      case 0x3B2: // xvabsdp (VSX Vector Absolute Value Double-Precision)
+      case 0x3D2: // xvnabsdp VSX Vector Negative Absolute Value Double-Precision)
+      {
+         IRTemp frB = newTemp(Ity_F64);
+         IRTemp frB2 = newTemp(Ity_F64);
+         IRTemp abs_resultHi = newTemp(Ity_F64);
+         IRTemp abs_resultLo = newTemp(Ity_F64);
+         Bool make_negative = (opc2 == 0x3D2) ? True : False;
+         assign(frB,  unop(Iop_ReinterpI64asF64, unop(Iop_V128HIto64, getVSReg( XB ))));
+         assign(frB2, unop(Iop_ReinterpI64asF64, unop(Iop_V128to64, getVSReg(XB))));
+
+         DIP("xv%sabsdp v%d,v%d\n", make_negative ? "n" : "", (UInt)XT, (UInt)XB);
+         if (make_negative) {
+            assign(abs_resultHi, unop( Iop_NegF64, unop( Iop_AbsF64, mkexpr( frB ) ) ) );
+            assign(abs_resultLo, unop( Iop_NegF64, unop( Iop_AbsF64, mkexpr( frB2 ) ) ) );
+
+         } else {
+            assign(abs_resultHi, unop( Iop_AbsF64, mkexpr( frB ) ) );
+            assign(abs_resultLo, unop( Iop_AbsF64, mkexpr( frB2 ) ) );
+         }
+         putVSReg( XT, binop( Iop_64HLtoV128,
+                              unop( Iop_ReinterpF64asI64, mkexpr( abs_resultHi ) ),
+                              unop( Iop_ReinterpF64asI64, mkexpr( abs_resultLo ) ) ) );
+         break;
+      }
+      case 0x332: // xvabssp (VSX Vector Absolute Value Single-Precision)
+      case 0x352: // xvnabssp (VSX Vector Negative Absolute Value Single-Precision)
+      {
+         /*
+          * The Iop_AbsF32 IRop is not implemented for ppc64 since, up until introduction
+          * of xvabssp, there has not been an abs(sp) type of instruction.  But since emulation
+          * of this function is so easy using shifts, I choose to emulate this instruction that
+          * way versus a native instruction method of implementation.
+          */
+         Bool make_negative = (opc2 == 0x352) ? True : False;
+         IRTemp shiftVector = newTemp(Ity_V128);
+         IRTemp absVal_vector = newTemp(Ity_V128);
+         assign( shiftVector,
+                 binop( Iop_64HLtoV128,
+                        binop( Iop_32HLto64, mkU32( 1 ), mkU32( 1 ) ),
+                        binop( Iop_32HLto64, mkU32( 1 ), mkU32( 1 ) ) ) );
+         assign( absVal_vector,
+                   binop( Iop_Shr32x4,
+                          binop( Iop_Shl32x4,
+                                 getVSReg( XB ),
+                                 mkexpr( shiftVector ) ),
+                          mkexpr( shiftVector ) ) );
+         if (make_negative) {
+            IRTemp signBit_vector = newTemp(Ity_V128);
+            assign( signBit_vector,
+                    binop( Iop_64HLtoV128,
+                           binop( Iop_32HLto64,
+                                  mkU32( 0x80000000 ),
+                                  mkU32( 0x80000000 ) ),
+                           binop( Iop_32HLto64,
+                                  mkU32( 0x80000000 ),
+                                  mkU32( 0x80000000 ) ) ) );
+            putVSReg( XT,
+                      binop( Iop_OrV128,
+                             mkexpr( absVal_vector ),
+                             mkexpr( signBit_vector ) ) );
+         } else {
+            putVSReg( XT, mkexpr( absVal_vector ) );
+         }
+         break;
+      }
+      case 0x3F2: // xvnegdp (VSX Vector Negate Double-Precision)
+      {
+         IRTemp frB = newTemp(Ity_F64);
+         IRTemp frB2 = newTemp(Ity_F64);
+         assign(frB,  unop(Iop_ReinterpI64asF64, unop(Iop_V128HIto64, getVSReg( XB ))));
+         assign(frB2, unop(Iop_ReinterpI64asF64, unop(Iop_V128to64, getVSReg(XB))));
+         DIP("xvnegdp v%d,v%d\n",  (UInt)XT, (UInt)XB);
+         putVSReg( XT,
+                   binop( Iop_64HLtoV128,
+                          unop( Iop_ReinterpF64asI64,
+                                unop( Iop_NegF64, mkexpr( frB ) ) ),
+                          unop( Iop_ReinterpF64asI64,
+                                unop( Iop_NegF64, mkexpr( frB2 ) ) ) ) );
+         break;
+      }
+      case 0x192: // xvrdpi  (VSX Vector Round to Double-Precision Integer using round toward Nearest Away)
+      case 0x1D6: // xvrdpic (VSX Vector Round to Double-Precision Integer using Current rounding mode)
+      case 0x1F2: // xvrdpim (VSX Vector Round to Double-Precision Integer using round toward -Infinity)
+      case 0x1D2: // xvrdpip (VSX Vector Round to Double-Precision Integer using round toward +Infinity)
+      case 0x1B2: // xvrdpiz (VSX Vector Round to Double-Precision Integer using round toward Zero)
+      {
+         IRTemp frBHi_I64 = newTemp(Ity_I64);
+         IRTemp frBLo_I64 = newTemp(Ity_I64);
+         IRExpr * frD_fp_roundHi = NULL;
+         IRExpr * frD_fp_roundLo = NULL;
+         UChar * insn_suffix = NULL;
+
+         assign( frBHi_I64, unop( Iop_V128HIto64, getVSReg( XB ) ) );
+         frD_fp_roundHi = _do_vsx_fp_roundToInt(frBHi_I64, opc2, insn_suffix);
+         assign( frBLo_I64, unop( Iop_V128to64, getVSReg( XB ) ) );
+         frD_fp_roundLo = _do_vsx_fp_roundToInt(frBLo_I64, opc2, insn_suffix);
+
+         DIP("xvrdpi%s v%d,v%d\n", insn_suffix, (UInt)XT, (UInt)XB);
+         putVSReg( XT,
+                   binop( Iop_64HLtoV128,
+                          unop( Iop_ReinterpF64asI64, frD_fp_roundHi ),
+                          unop( Iop_ReinterpF64asI64, frD_fp_roundLo ) ) );
+         break;
+      }
+      case 0x112: // xvrspi  (VSX Vector Round to Single-Precision Integer using round toward Nearest Away)
+      case 0x156: // xvrspic (VSX Vector Round to SinglePrecision Integer using Current rounding mode)
+      case 0x172: // xvrspim (VSX Vector Round to SinglePrecision Integer using round toward -Infinity)
+      case 0x152: // xvrspip (VSX Vector Round to SinglePrecision Integer using round toward +Infinity)
+      case 0x132: // xvrspiz (VSX Vector Round to SinglePrecision Integer using round toward Zero)
+      {
+         UChar * insn_suffix = NULL;
+         IROp op;
+         if (opc2 != 0x156) {
+            // Use pre-defined IRop's for vrfi{m|n|p|z}
+            switch (opc2) {
+               case 0x112:
+                  insn_suffix = "";
+                  op = Iop_RoundF32x4_RN;
+                  break;
+               case 0x172:
+                  insn_suffix = "m";
+                  op = Iop_RoundF32x4_RM;
+                  break;
+               case 0x152:
+                  insn_suffix = "p";
+                  op = Iop_RoundF32x4_RP;
+                  break;
+               case 0x132:
+                  insn_suffix = "z";
+                  op = Iop_RoundF32x4_RZ;
+                  break;
+
+               default:
+                  vex_printf( "dis_vxv_misc(ppc)(vrspi<x>)(opc2)\n" );
+                  return False;
+            }
+            DIP("xvrspi%s v%d,v%d\n", insn_suffix, (UInt)XT, (UInt)XB);
+            putVSReg( XT, unop( op, getVSReg(XB) ) );
+         } else {
+            // Handle xvrspic.  Unfortunately there is no corresponding "vfric" instruction.
+            IRExpr * frD_fp_roundb3, * frD_fp_roundb2, * frD_fp_roundb1, * frD_fp_roundb0;
+            IRTemp b3_F64, b2_F64, b1_F64, b0_F64;
+            IRTemp b3_I64 = newTemp(Ity_I64);
+            IRTemp b2_I64 = newTemp(Ity_I64);
+            IRTemp b1_I64 = newTemp(Ity_I64);
+            IRTemp b0_I64 = newTemp(Ity_I64);
+
+            b3_F64 = b2_F64 = b1_F64 = b0_F64 = IRTemp_INVALID;
+            frD_fp_roundb3 = frD_fp_roundb2 = frD_fp_roundb1 = frD_fp_roundb0 = NULL;
+            breakV128to4xF64( getVSReg(XB), &b3_F64, &b2_F64, &b1_F64, &b0_F64);
+            assign(b3_I64, unop(Iop_ReinterpF64asI64, mkexpr(b3_F64)));
+            assign(b2_I64, unop(Iop_ReinterpF64asI64, mkexpr(b2_F64)));
+            assign(b1_I64, unop(Iop_ReinterpF64asI64, mkexpr(b1_F64)));
+            assign(b0_I64, unop(Iop_ReinterpF64asI64, mkexpr(b0_F64)));
+            frD_fp_roundb3 = unop(Iop_TruncF64asF32,
+                                  _do_vsx_fp_roundToInt(b3_I64, opc2, insn_suffix));
+            frD_fp_roundb2 = unop(Iop_TruncF64asF32,
+                                  _do_vsx_fp_roundToInt(b2_I64, opc2, insn_suffix));
+            frD_fp_roundb1 = unop(Iop_TruncF64asF32,
+                                  _do_vsx_fp_roundToInt(b1_I64, opc2, insn_suffix));
+            frD_fp_roundb0 = unop(Iop_TruncF64asF32,
+                                  _do_vsx_fp_roundToInt(b0_I64, opc2, insn_suffix));
+            DIP("xvrspic v%d,v%d\n", (UInt)XT, (UInt)XB);
+            putVSReg( XT,
+                      binop( Iop_64HLtoV128,
+                             binop( Iop_32HLto64,
+                                    unop( Iop_ReinterpF32asI32, frD_fp_roundb3 ),
+                                    unop( Iop_ReinterpF32asI32, frD_fp_roundb2 ) ),
+                             binop( Iop_32HLto64,
+                                    unop( Iop_ReinterpF32asI32, frD_fp_roundb1 ),
+                                    unop( Iop_ReinterpF32asI32, frD_fp_roundb0 ) ) ) );
+         }
+         break;
+      }
 
       default:
          vex_printf( "dis_vxv_misc(ppc)(opc2)\n" );
@@ -9209,6 +10365,27 @@ dis_vxs_arith ( UInt theInstr, UInt opc2
          putGST_field( PPC_GST_CR, do_fp_tdiv(frA_I64, frB_I64), crfD );
          break;
       }
+      case 0x0D4: // xstsqrtdp (VSX Vector Test for software Square Root Double-Precision)
+      {
+         IRTemp frB_I64 = newTemp(Ity_I64);
+         UChar crfD     = toUChar( IFIELD( theInstr, 23, 3 ) );
+         IRTemp flags = newTemp(Ity_I32);
+         IRTemp  fe_flag, fg_flag;
+         fe_flag = fg_flag = IRTemp_INVALID;
+         DIP("xstsqrtdp v%d,v%d\n", (UInt)XT, (UInt)XB);
+         assign( frB_I64, unop(Iop_V128HIto64, getVSReg( XB )) );
+         do_fp_tsqrt(frB_I64, False /*not single precision*/, &fe_flag, &fg_flag);
+         /* The CR field consists of fl_flag || fg_flag || fe_flag || 0b0
+          * where fl_flag == 1 on ppc64.
+          */
+         assign( flags,
+                 binop( Iop_Or32,
+                        binop( Iop_Or32, mkU32( 8 ), // fl_flag
+                               binop( Iop_Shl32, mkexpr(fg_flag), mkU8( 2 ) ) ),
+                        binop( Iop_Shl32, mkexpr(fe_flag), mkU8( 1 ) ) ) );
+         putGST_field( PPC_GST_CR, mkexpr(flags), crfD );
+         break;
+      }
 
       default:
          vex_printf( "dis_vxs_arith(ppc)(opc2)\n" );
@@ -9541,71 +10718,52 @@ dis_vxs_misc( UInt theInstr, UInt opc2 )
          break;
       }
       case 0x0F2: // xsrdpim (VSX Scalar Round to Double-Precision Integer using round toward -Infinity)
-      case 0x0D2: // xsrdpim (VSX Scalar Round to Double-Precision Integer using round toward +Infinity)
+      case 0x0D2: // xsrdpip (VSX Scalar Round to Double-Precision Integer using round toward +Infinity)
+      case 0x0D6: // xsrdpic (VSX Scalar Round to Double-Precision Integer using Current rounding mode)
+      case 0x0B2: // xsrdpiz (VSX Scalar Round to Double-Precision Integer using round toward Zero)
+      case 0x092: // xsrdpi  (VSX Scalar Round to Double-Precision Integer using round toward Nearest Away)
       {
-         /* The same rules apply for xsrdpi{m|p} as for floating point round operations (e.g., frim) */
-         IRTemp frB = newTemp(Ity_F64);
-         IRTemp frD = newTemp(Ity_F64);
-         IRTemp frD_fp_round = newTemp(Ity_F64);
-         IRTemp intermediateResult = newTemp(Ity_I64);
          IRTemp frB_I64 = newTemp(Ity_I64);
-         IRTemp is_SNAN = newTemp(Ity_I1);
-         IRExpr * hi32;
-         DIP("xsrdpi%s v%d,v%d\n", (opc2 == 0x0F2) ? "m" : "p", (UInt)XT, (UInt)XB);
-         assign(frB_I64, unop(Iop_V128HIto64, mkexpr( vB )));
-         assign(frB, unop(Iop_ReinterpI64asF64, mkexpr(frB_I64)));
-         assign( intermediateResult,
-                 binop( Iop_F64toI64S, mkU32( (opc2 == 0x0F2) ? Irrm_NegINF : Irrm_PosINF ),
-                        mkexpr( frB ) ) );
-
-         /* don't use the rounded integer if frB is outside -9e18..9e18 */
-         /* F64 has only log10(2**52) significant digits anyway */
-         /* need to preserve sign of zero */
-         /*   frD = (fabs(frB) > 9e18) ? frB :
-                  (sign(frB)) ? -fabs((double)r_tmp64) : (double)r_tmp64  */
-         assign( frD,
-                 IRExpr_Mux0X( unop( Iop_32to8,
-                                     binop( Iop_CmpF64,
-                                            IRExpr_Const( IRConst_F64( 9e18 ) ),
-                                            unop( Iop_AbsF64, mkexpr( frB ) ) ) ),
-                               IRExpr_Mux0X( unop( Iop_32to8,
-                                                   binop( Iop_Shr32,
-                                                          unop( Iop_64HIto32,
-                                                                mkexpr(frB_I64) ),
-                                                          mkU8( 31 ) ) ),
-                                             binop( Iop_I64StoF64,
-                                                    mkU32( 0 ),
-                                                    mkexpr( intermediateResult ) ),
-                                             unop( Iop_NegF64,
-                                                   unop( Iop_AbsF64,
-                                                         binop( Iop_I64StoF64,
-                                                                mkU32( 0 ),
-                                                                mkexpr( intermediateResult ) ) ) ) ),
-                               mkexpr( frB ) ) );
+         IRExpr * frD_fp_round = NULL;
+         UChar * insn_suffix = NULL;
 
-         /* See Appendix "Floating-Point Round to Integer Model" in ISA doc.
-          * If frB is a SNAN, then frD <- frB, with bith 12 set to '1'.
-          */
-#define SNAN_MASK 0x0008000000000000ULL
-         hi32 = unop( Iop_64HIto32, mkexpr(frB_I64) );
-         assign( is_SNAN,
-                 mkAND1( is_NaN( frB_I64 ),
-                         binop( Iop_CmpEQ32,
-                                binop( Iop_And32, hi32, mkU32( 0x00080000 ) ),
-                                mkU32( 0 ) ) ) );
-         assign( frD_fp_round,
-                 IRExpr_Mux0X( unop( Iop_1Uto8, mkexpr( is_SNAN ) ),
-                               mkexpr( frD ),
-                               unop( Iop_ReinterpI64asF64,
-                                     binop( Iop_Xor64,
-                                            mkU64( SNAN_MASK ),
-                                            mkexpr( frB_I64 ) ) ) ) );
+         assign(frB_I64, unop(Iop_V128HIto64, mkexpr( vB )));
+         frD_fp_round = _do_vsx_fp_roundToInt(frB_I64, opc2, insn_suffix);
 
+         DIP("xsrdpi%s v%d,v%d\n", insn_suffix, (UInt)XT, (UInt)XB);
          putVSReg( XT,
                    binop( Iop_64HLtoV128,
-                          unop( Iop_ReinterpF64asI64, mkexpr( frD_fp_round ) ),
+                          unop( Iop_ReinterpF64asI64, frD_fp_round),
                           mkU64( 0 ) ) );
+         break;
+      }
+      case 0x0B4: // xsredp (VSX Scalar Reciprocal Estimate Double-Precision)
+      case 0x094: // xsrsqrtedp (VSX Scalar Reciprocal Square Root Estimate Double-Precision)
 
+      {
+         IRTemp frB = newTemp(Ity_F64);
+         IRTemp sqrt = newTemp(Ity_F64);
+         IRExpr* ieee_one = IRExpr_Const(IRConst_F64i(0x3ff0000000000000ULL));
+         IRExpr* rm  = get_IR_roundingmode();
+         Bool redp = opc2 == 0x0B4;
+         DIP("%s v%d,v%d\n", redp ? "xsredp" : "xsrsqrtedp", (UInt)XT, (UInt)XB);
+         assign( frB,
+                 unop( Iop_ReinterpI64asF64,
+                       unop( Iop_V128HIto64, mkexpr( vB ) ) ) );
+
+         if (!redp)
+            assign( sqrt,
+                    binop( Iop_SqrtF64,
+                           rm,
+                           mkexpr(frB) ) );
+         putVSReg( XT,
+                      binop( Iop_64HLtoV128,
+                             unop( Iop_ReinterpF64asI64,
+                                   triop( Iop_DivF64,
+                                          rm,
+                                          ieee_one,
+                                          redp ? mkexpr( frB ) : mkexpr( sqrt ) ) ),
+                             mkU64( 0 ) ) );
          break;
       }
 
@@ -12453,6 +13611,9 @@ DisResult disInstr_PPC_WRK (
          case 0x2D2: case 0x2F2: // xsnabsdp, xsnegdp
          case 0x280: case 0x2A0: // xsmaxdp, xsmindp
          case 0x0F2: case 0x0D2: // xsrdpim, xsrdpip
+         case 0x0B4: case 0x094: // xsredp, xsrsqrtedp
+         case 0x0D6: case 0x0B2: // xsrdpic, xsrdpiz
+         case 0x092: // xsrdpi
             if (dis_vxs_misc(theInstr, vsxOpc2)) goto decode_success;
             goto decode_failure;
          case 0x08C: case 0x0AC: // xscmpudp, xscmpodp
@@ -12465,6 +13626,7 @@ DisResult disInstr_PPC_WRK (
          case 0x2C4: case 0x2E4: // xsnmsubadp, xsnmsubmdp
          case 0x0C0: case 0x0A0: // xsmuldp, xssubdp
          case 0x096: case 0x0F4: // xssqrtdp, xstdivdp
+         case 0x0D4: // xstsqrtdp
             if (dis_vxs_arith(theInstr, vsxOpc2)) goto decode_success;
             goto decode_failure;
          case 0x180: // xvadddp
@@ -12475,6 +13637,8 @@ DisResult disInstr_PPC_WRK (
          case 0x1C4: case 0x1E4: // xvmsubadp, xvmsubmdp
          case 0x384: case 0x3A4: // xvnmaddadp, xvnmaddmdp
          case 0x3C4: case 0x3E4: // xvnmsubadp, xvnmsubmdp
+         case 0x1D4: case 0x1F4: // xvtsqrtdp, xvtdivdp
+         case 0x196: // xvsqrtdp
             if (dis_vxv_dp_arith(theInstr, vsxOpc2)) goto decode_success;
             goto decode_failure;
          case 0x100: // xvaddsp
@@ -12485,12 +13649,24 @@ DisResult disInstr_PPC_WRK (
          case 0x144: case 0x164: // xvmsubasp, xvmsubmsp
          case 0x304: case 0x324: // xvnmaddasp, xvnmaddmsp
          case 0x344: case 0x364: // xvnmsubasp, xvnmsubmsp
+         case 0x154: case 0x174: // xvtsqrtsp, xvtdivsp
+         case 0x116: // xvsqrtsp
             if (dis_vxv_sp_arith(theInstr, vsxOpc2)) goto decode_success;
             goto decode_failure;
 
          case 0x2B0: case 0x2F0: case 0x2D0: // xscvdpsxds, xscvsxddp, xscvuxddp
          case 0x1b0: case 0x130: // xvcvdpsxws, xvcvspsxws
          case 0x0b0: case 0x290: // xscvdpsxws, xscvdpuxds
+         case 0x212: case 0x090: // xscvdpsp, xscvdpuxws
+         case 0x292: case 0x312: // xscvspdp, xvcvdpsp
+         case 0x390: case 0x190: // xvcvdpuxds, xvcvdpuxws
+         case 0x3B0: case 0x310: // xvcvdpsxds, xvcvspuxds
+         case 0x392: case 0x330: // xvcvspdp, xvcvspsxds
+         case 0x110: case 0x3f0: // xvcvspuxws, xvcvsxddp
+         case 0x370: case 0x1f0: // xvcvsxdsp, xvcvsxwdp
+         case 0x170: case 0x150: // xvcvsxwsp, xvcvuxwsp
+         case 0x3d0: case 0x350: // xvcvuxddp, xvcvuxdsp
+         case 0x1d0: // xvcvuxwdp
             if (dis_vx_conv(theInstr, vsxOpc2)) goto decode_success;
             goto decode_failure;
 
@@ -12504,10 +13680,19 @@ DisResult disInstr_PPC_WRK (
              goto decode_failure;
 
          case 0x134:  // xvresp
-         case 0x380: case 0x3A0: //xvmaxdp, xvmindp
+         case 0x1B4:  // xvredp
+         case 0x194: case 0x114: // xvrsqrtedp, xvrsqrtesp
+         case 0x380: case 0x3A0: // xvmaxdp, xvmindp
          case 0x300: case 0x320: // xvmaxsp, xvminsp
-         case 0x3c0: // xvcpsgndp
-         case 0x340: // xvcpsgnsp
+         case 0x3C0: case 0x340: // xvcpsgndp, xvcpsgnsp
+         case 0x3B2: case 0x332: // xvabsdp, xvabssp
+         case 0x3D2: case 0x352: // xvnabsdp, xvnabssp
+         case 0x192: case 0x1D6: // xvrdpi, xvrdpic
+         case 0x1F2: case 0x1D2: // xvrdpim, xvrdpip
+         case 0x1B2: case 0x3F2: // xvrdpiz, xvnegdp
+         case 0x112: case 0x156: // xvrspi, xvrspic
+         case 0x172: case 0x152: // xvrspim, xvrspip
+         case 0x132: // xvrspiz
             if (dis_vxv_misc(theInstr, vsxOpc2)) goto decode_success;
             goto decode_failure;
 
@@ -12568,7 +13753,8 @@ DisResult disInstr_PPC_WRK (
          goto decode_failure;
          
       case 0x080: // ftdiv
-         if (dis_fp_ftdiv(theInstr)) goto decode_success;
+      case 0x0A0: // ftsqrt
+         if (dis_fp_tests(theInstr)) goto decode_success;
          goto decode_failure;
 
       /* Floating Point Rounding/Conversion Instructions */         
@@ -12666,6 +13852,7 @@ DisResult disInstr_PPC_WRK (
          goto decode_failure;
 
       case 0x18B: // divweu (implemented as native insn)
+      case 0x1AB: // divwe (implemented as native insn)
          if (!allow_VX) goto decode_noVX;
          if (dis_int_arith( theInstr )) goto decode_success;
          goto decode_failure;
@@ -12678,6 +13865,7 @@ DisResult disInstr_PPC_WRK (
          goto decode_failure;
 
       case 0x1A9: //  divde (implemented as native insn)
+      case 0x189: //  divdeuo (implemented as native insn)
          if (!allow_VX) goto decode_noVX;
          if (!mode64) goto decode_failure;
          if (dis_int_arith( theInstr )) goto decode_success;
@@ -12893,6 +14081,7 @@ DisResult disInstr_PPC_WRK (
 
       /* Miscellaneous ISA 2.06 instructions */
       case 0x1FA: // popcntd
+      case 0x17A: // popcntw
     	  if (dis_int_logic( theInstr )) goto decode_success;
     	  goto decode_failure;
 
--- valgrind/VEX/priv/host_ppc_isel.c	(revision 2198)
+++ valgrind/VEX/priv/host_ppc_isel.c	(revision 2199)
@@ -1285,29 +1285,41 @@ static HReg iselWordExpr_R_wrk ( ISelEnv
       /* How about a div? */
       if (e->Iex.Binop.op == Iop_DivS32 || 
           e->Iex.Binop.op == Iop_DivU32 ||
+          e->Iex.Binop.op == Iop_DivS32E ||
           e->Iex.Binop.op == Iop_DivU32E) {
-         Bool syned  = toBool(e->Iex.Binop.op == Iop_DivS32);
+         Bool syned  = toBool((e->Iex.Binop.op == Iop_DivS32) || (e->Iex.Binop.op == Iop_DivS32E));
          HReg r_dst  = newVRegI(env);
          HReg r_srcL = iselWordExpr_R(env, e->Iex.Binop.arg1);
          HReg r_srcR = iselWordExpr_R(env, e->Iex.Binop.arg2);
          addInstr( env,
-                      PPCInstr_Div( e->Iex.Binop.op == Iop_DivU32E ? True
-                                                                   : False,
-                                    syned, True/*32bit div*/, r_dst,
-                                    r_srcL, r_srcR ) );
+                      PPCInstr_Div( ( ( e->Iex.Binop.op == Iop_DivU32E )
+                                             || ( e->Iex.Binop.op == Iop_DivS32E ) ) ? True
+                                                                                     : False,
+                                    syned,
+                                    True/*32bit div*/,
+                                    r_dst,
+                                    r_srcL,
+                                    r_srcR ) );
          return r_dst;
       }
       if (e->Iex.Binop.op == Iop_DivS64 || 
-          e->Iex.Binop.op == Iop_DivU64 || e->Iex.Binop.op == Iop_DivS64E) {
+          e->Iex.Binop.op == Iop_DivU64 || e->Iex.Binop.op == Iop_DivS64E
+          || e->Iex.Binop.op == Iop_DivU64E ) {
          Bool syned  = toBool((e->Iex.Binop.op == Iop_DivS64) ||(e->Iex.Binop.op == Iop_DivS64E));
          HReg r_dst  = newVRegI(env);
          HReg r_srcL = iselWordExpr_R(env, e->Iex.Binop.arg1);
          HReg r_srcR = iselWordExpr_R(env, e->Iex.Binop.arg2);
          vassert(mode64);
          addInstr( env,
-                      PPCInstr_Div( e->Iex.Binop.op == Iop_DivS64E ? True : False,
-                                    syned, False/*64bit div*/,
-                                    r_dst, r_srcL, r_srcR ) );
+                      PPCInstr_Div( ( ( e->Iex.Binop.op == Iop_DivS64E )
+                                             || ( e->Iex.Binop.op
+                                                      == Iop_DivU64E ) ) ? True
+                                                                         : False,
+                                    syned,
+                                    False/*64bit div*/,
+                                    r_dst,
+                                    r_srcL,
+                                    r_srcR ) );
          return r_dst;
       }
 
--- valgrind/VEX/pub/libvex_ir.h	(revision 2198)
+++ valgrind/VEX/pub/libvex_ir.h	(revision 2199)
@@ -469,8 +469,10 @@ typedef
       Iop_DivS32,   // ditto, signed
       Iop_DivU64,   // :: I64,I64 -> I64 (simple div, no mod)
       Iop_DivS64,   // ditto, signed
-      Iop_DivS64E,  // :: I64,I64 -> I64 (dividend is 64-bit arg (hi) concat with 64 0's (low))
+      Iop_DivU64E,  // :: I64,I64 -> I64 (dividend is 64-bit arg (hi) concat with 64 0's (low))
+      Iop_DivS64E,  // ditto, signed
       Iop_DivU32E,  // :: I32,I32 -> I32 (dividend is 32-bit arg (hi) concat with 32 0's (low))
+      Iop_DivS32E,  // ditto, signed
 
       Iop_DivModU64to32, // :: I64,I32 -> I64
                          // of which lo half is div and hi half is mod
--- valgrind/memcheck/mc_translate.c	(revision 12005)
+++ valgrind/memcheck/mc_translate.c	(revision 12007)
@@ -3052,11 +3052,13 @@ IRAtom* expr2vbits_Binop ( MCEnv* mce,
       case Iop_DivS32:
       case Iop_DivU32:
       case Iop_DivU32E:
+      case Iop_DivS32E:
          return mkLazy2(mce, Ity_I32, vatom1, vatom2);
 
       case Iop_DivS64:
       case Iop_DivU64:
       case Iop_DivS64E:
+      case Iop_DivU64E:
          return mkLazy2(mce, Ity_I64, vatom1, vatom2);
 
       case Iop_Add32:
--- valgrind/none/tests/ppc32/test_isa_2_06_part3.c	(revision 0)
+++ valgrind/none/tests/ppc32/test_isa_2_06_part3.c	(revision 12007)
@@ -0,0 +1,1582 @@
+/*  Copyright (C) 2011 IBM
+
+ Author: Maynard Johnson <maynardj@us.ibm.com>
+
+ This program is free software; you can redistribute it and/or
+ modify it under the terms of the GNU General Public License as
+ published by the Free Software Foundation; either version 2 of the
+ License, or (at your option) any later version.
+
+ This program is distributed in the hope that it will be useful, but
+ WITHOUT ANY WARRANTY; without even the implied warranty of
+ MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ General Public License for more details.
+
+ You should have received a copy of the GNU General Public License
+ along with this program; if not, write to the Free Software
+ Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+ 02111-1307, USA.
+
+ The GNU General Public License is contained in the file COPYING.
+ */
+
+#ifdef HAS_VSX
+
+#include <stdio.h>
+#include <stdint.h>
+#include <stdlib.h>
+#include <string.h>
+#include <malloc.h>
+#include <altivec.h>
+#include <math.h>
+
+#ifndef __powerpc64__
+typedef uint32_t HWord_t;
+#else
+typedef uint64_t HWord_t;
+#endif /* __powerpc64__ */
+
+typedef unsigned char Bool;
+#define True 1
+#define False 0
+register HWord_t r14 __asm__ ("r14");
+register HWord_t r15 __asm__ ("r15");
+register HWord_t r16 __asm__ ("r16");
+register HWord_t r17 __asm__ ("r17");
+register double f14 __asm__ ("fr14");
+register double f15 __asm__ ("fr15");
+register double f16 __asm__ ("fr16");
+register double f17 __asm__ ("fr17");
+
+static volatile unsigned int div_flags, div_xer;
+
+#define ALLCR "cr0","cr1","cr2","cr3","cr4","cr5","cr6","cr7"
+
+#define SET_CR(_arg) \
+      __asm__ __volatile__ ("mtcr  %0" : : "b"(_arg) : ALLCR );
+
+#define SET_XER(_arg) \
+      __asm__ __volatile__ ("mtxer %0" : : "b"(_arg) : "xer" );
+
+#define GET_CR(_lval) \
+      __asm__ __volatile__ ("mfcr %0"  : "=b"(_lval) )
+
+#define GET_XER(_lval) \
+      __asm__ __volatile__ ("mfxer %0" : "=b"(_lval) )
+
+#define GET_CR_XER(_lval_cr,_lval_xer) \
+   do { GET_CR(_lval_cr); GET_XER(_lval_xer); } while (0)
+
+#define SET_CR_ZERO \
+      SET_CR(0)
+
+#define SET_XER_ZERO \
+      SET_XER(0)
+
+#define SET_CR_XER_ZERO \
+   do { SET_CR_ZERO; SET_XER_ZERO; } while (0)
+
+#define SET_FPSCR_ZERO \
+   do { double _d = 0.0; \
+        __asm__ __volatile__ ("mtfsf 0xFF, %0" : : "f"(_d) ); \
+   } while (0)
+
+
+typedef void (*test_func_t)(void);
+typedef struct test_table test_table_t;
+
+
+/* These functions below that construct a table of floating point
+ * values were lifted from none/tests/ppc32/jm-insns.c.
+ */
+
+#if defined (DEBUG_ARGS_BUILD)
+#define AB_DPRINTF(fmt, args...) do { fprintf(stderr, fmt , ##args); } while (0)
+#else
+#define AB_DPRINTF(fmt, args...) do { } while (0)
+#endif
+
+static inline void register_farg (void *farg,
+                                  int s, uint16_t _exp, uint64_t mant)
+{
+   uint64_t tmp;
+
+   tmp = ((uint64_t)s << 63) | ((uint64_t)_exp << 52) | mant;
+   *(uint64_t *)farg = tmp;
+   AB_DPRINTF("%d %03x %013llx => %016llx %0e\n",
+              s, _exp, mant, *(uint64_t *)farg, *(double *)farg);
+}
+
+
+typedef struct fp_test_args {
+   int fra_idx;
+   int frb_idx;
+} fp_test_args_t;
+
+
+fp_test_args_t two_arg_fp_tests[] = {
+                                     {8, 8},
+                                     {8, 14},
+                                     {15, 16},
+                                     {8, 5},
+                                     {8, 4},
+                                     {8, 7},
+                                     {8, 9},
+                                     {8, 11},
+                                     {14, 8},
+                                     {14, 14},
+                                     {14, 6},
+                                     {14, 5},
+                                     {14, 4},
+                                     {14, 7},
+                                     {14, 9},
+                                     {14, 11},
+                                     {6, 8},
+                                     {6, 14},
+                                     {6, 6},
+                                     {6, 5},
+                                     {6, 4},
+                                     {6, 7},
+                                     {6, 9},
+                                     {6, 11},
+                                     {5, 8},
+                                     {5, 14},
+                                     {5, 6},
+                                     {5, 5},
+                                     {5, 4},
+                                     {5, 7},
+                                     {5, 9},
+                                     {5, 11},
+                                     {4, 8},
+                                     {4, 14},
+                                     {4, 6},
+                                     {4, 5},
+                                     {4, 1},
+                                     {4, 7},
+                                     {4, 9},
+                                     {4, 11},
+                                     {7, 8},
+                                     {7, 14},
+                                     {7, 6},
+                                     {7, 5},
+                                     {7, 4},
+                                     {7, 7},
+                                     {7, 9},
+                                     {7, 11},
+                                     {10, 8},
+                                     {10, 14},
+                                     {12, 6},
+                                     {12, 5},
+                                     {10, 4},
+                                     {10, 7},
+                                     {10, 9},
+                                     {10, 11},
+                                     {12, 8 },
+                                     {12, 14},
+                                     {12, 6},
+                                     {15, 16},
+                                     {15, 16},
+                                     {9, 11},
+                                     {11, 11},
+                                     {11, 12},
+                                     {16, 18},
+                                     {17, 16},
+                                     {19, 19},
+                                     {19, 18}
+};
+
+
+static int nb_special_fargs;
+static double * spec_fargs;
+static float * spec_sp_fargs;
+
+static void build_special_fargs_table(void)
+{
+/*
+  Entry  Sign Exp   fraction                  Special value
+   0      0   3fd   0x8000000000000ULL         Positive finite number
+   1      0   404   0xf000000000000ULL         ...
+   2      0   001   0x8000000b77501ULL         ...
+   3      0   7fe   0x800000000051bULL         ...
+   4      0   012   0x3214569900000ULL         ...
+   5      0   000   0x0000000000000ULL         +0.0 (+zero)
+   6      1   000   0x0000000000000ULL         -0.0 (-zero)
+   7      0   7ff   0x0000000000000ULL         +infinity
+   8      1   7ff   0x0000000000000ULL         -infinity
+   9      0   7ff   0x7FFFFFFFFFFFFULL         +SNaN
+   10     1   7ff   0x7FFFFFFFFFFFFULL         -SNaN
+   11     0   7ff   0x8000000000000ULL         +QNaN
+   12     1   7ff   0x8000000000000ULL         -QNaN
+   13     1   000   0x8340000078000ULL         Denormalized val (zero exp and non-zero fraction)
+   14     1   40d   0x0650f5a07b353ULL         Negative finite number
+   15     0   412   0x32585a9900000ULL         A few more positive finite numbers
+   16     0   413   0x82511a2000000ULL         ...
+   17  . . . . . . . . . . . . . . . . . . . . . . .
+   18  . . . . . . . . . . . . . . . . . . . . . . .
+   19  . . . . . . . . . . . . . . . . . . . . . . .
+*/
+
+   uint64_t mant;
+   uint16_t _exp;
+   int s;
+   int j, i = 0;
+
+   if (spec_fargs)
+      return;
+
+   spec_fargs = malloc( 20 * sizeof(double) );
+   spec_sp_fargs = malloc( 20 * sizeof(float) );
+
+   // #0
+   s = 0;
+   _exp = 0x3fd;
+   mant = 0x8000000000000ULL;
+   register_farg(&spec_fargs[i++], s, _exp, mant);
+
+   // #1
+   s = 0;
+   _exp = 0x404;
+   mant = 0xf000000000000ULL;
+   register_farg(&spec_fargs[i++], s, _exp, mant);
+
+   // #2
+   s = 0;
+   _exp = 0x001;
+   mant = 0x8000000b77501ULL;
+   register_farg(&spec_fargs[i++], s, _exp, mant);
+
+   // #3
+   s = 0;
+   _exp = 0x7fe;
+   mant = 0x800000000051bULL;
+   register_farg(&spec_fargs[i++], s, _exp, mant);
+
+   // #4
+   s = 0;
+   _exp = 0x012;
+   mant = 0x3214569900000ULL;
+   register_farg(&spec_fargs[i++], s, _exp, mant);
+
+
+   /* Special values */
+   /* +0.0      : 0 0x000 0x0000000000000 */
+   // #5
+   s = 0;
+   _exp = 0x000;
+   mant = 0x0000000000000ULL;
+   register_farg(&spec_fargs[i++], s, _exp, mant);
+
+   /* -0.0      : 1 0x000 0x0000000000000 */
+   // #6
+   s = 1;
+   _exp = 0x000;
+   mant = 0x0000000000000ULL;
+   register_farg(&spec_fargs[i++], s, _exp, mant);
+
+   /* +infinity : 0 0x7FF 0x0000000000000  */
+   // #7
+   s = 0;
+   _exp = 0x7FF;
+   mant = 0x0000000000000ULL;
+   register_farg(&spec_fargs[i++], s, _exp, mant);
+
+   /* -infinity : 1 0x7FF 0x0000000000000 */
+   // #8
+   s = 1;
+   _exp = 0x7FF;
+   mant = 0x0000000000000ULL;
+   register_farg(&spec_fargs[i++], s, _exp, mant);
+
+   /* +QNaN     : 0 0x7FF 0x7FFFFFFFFFFFF */
+   // #9
+   s = 0;
+   _exp = 0x7FF;
+   mant = 0x7FFFFFFFFFFFFULL;
+   register_farg(&spec_fargs[i++], s, _exp, mant);
+
+   /* -QNaN     : 1 0x7FF 0x7FFFFFFFFFFFF */
+   // #10
+   s = 1;
+   _exp = 0x7FF;
+   mant = 0x7FFFFFFFFFFFFULL;
+   register_farg(&spec_fargs[i++], s, _exp, mant);
+
+   /* +SNaN     : 0 0x7FF 0x8000000000000 */
+   // #11
+   s = 0;
+   _exp = 0x7FF;
+   mant = 0x8000000000000ULL;
+   register_farg(&spec_fargs[i++], s, _exp, mant);
+
+   /* -SNaN     : 1 0x7FF 0x8000000000000 */
+   // #12
+   s = 1;
+   _exp = 0x7FF;
+   mant = 0x8000000000000ULL;
+   register_farg(&spec_fargs[i++], s, _exp, mant);
+
+   /* denormalized value */
+   // #13
+   s = 1;
+   _exp = 0x000;
+   mant = 0x8340000078000ULL;
+   register_farg(&spec_fargs[i++], s, _exp, mant);
+
+   /* Negative finite number */
+   // #14
+   s = 1;
+   _exp = 0x40d;
+   mant = 0x0650f5a07b353ULL;
+   register_farg(&spec_fargs[i++], s, _exp, mant);
+
+   /* A few positive finite numbers ... */
+   // #15
+   s = 0;
+   _exp = 0x412;
+   mant = 0x32585a9900000ULL;
+   register_farg(&spec_fargs[i++], s, _exp, mant);
+
+   // #16
+   s = 0;
+   _exp = 0x413;
+   mant = 0x82511a2000000ULL;
+   register_farg(&spec_fargs[i++], s, _exp, mant);
+
+   // #17
+   s = 0;
+   _exp = 0x403;
+   mant = 0x12ef5a9300000ULL;
+   register_farg(&spec_fargs[i++], s, _exp, mant);
+
+   // #18
+   s = 0;
+   _exp = 0x405;
+   mant = 0x14bf5d2300000ULL;
+   register_farg(&spec_fargs[i++], s, _exp, mant);
+
+   // #19
+   s = 0;
+   _exp = 0x409;
+   mant = 0x76bf982440000ULL;
+   register_farg(&spec_fargs[i++], s, _exp, mant);
+
+   nb_special_fargs = i;
+   for (j = 0; j < i; j++) {
+      spec_sp_fargs[j] = spec_fargs[j];
+   }
+}
+
+
+struct test_table
+{
+   test_func_t test_category;
+   char * name;
+};
+
+/*  Type of input for floating point operations.*/
+typedef enum {
+   SINGLE_TEST,
+   DOUBLE_TEST
+} precision_type_t;
+
+typedef enum {
+   VX_SCALAR_CONV_TO_WORD,
+   VX_CONV_TO_SINGLE,
+   VX_CONV_TO_DOUBLE,
+   VX_ESTIMATE,
+   VX_DEFAULT
+} vx_fp_test_type;
+
+static vector unsigned int vec_out, vec_inA, vec_inB;
+
+/* This function is for checking the reciprocal and reciprocal square root
+ * estimate instructions.
+ */
+Bool check_estimate(precision_type_t type, Bool is_rsqrte, int idx, int output_vec_idx)
+{
+   /* Technically, the number of bits of precision for xvredp and xvrsqrtedp is
+    * 14 bits (14 = log2 16384).  However, the VEX emulation of these instructions
+    * does an actual reciprocal calculation versus estimation, so the answer we get back from
+    * valgrind can easily differ from the estimate in the lower bits (within the 14 bits of
+    * precision) and the estimate may still be within expected tolerances.  On top of that,
+    * we can't count on these estimates always being the same across implementations.
+    * For example, with the fre[s] instruction (which should be correct to within one part
+    * in 256 -- i.e., 8 bits of precision) . . . When approximating the value 1.0111_1111_1111,
+    * one implementation could return 1.0111_1111_0000 and another implementation could return
+    * 1.1000_0000_0000.  Both estimates meet the 1/256 accuracy requirement, but share only a
+    * single bit in common.
+    *
+    * The upshot is we can't validate the VEX output for these instructions by comparing against
+    * stored bit patterns.  We must check that the result is within expected tolerances.
+    */
+
+
+   /* A mask to be used for validation as a last resort.
+    * Only use 12 bits of precision for reasons discussed above.
+    */
+#define VSX_RECIP_ESTIMATE_MASK_DP 0xFFFFFF0000000000ULL
+#define VSX_RECIP_ESTIMATE_MASK_SP 0xFFFFFF00
+
+   Bool result = False;
+   Bool dp_test = type == DOUBLE_TEST;
+   double src_dp, res_dp;
+   float src_sp, res_sp;
+   src_dp = res_dp = 0;
+   src_sp = res_sp = 0;
+#define SRC (dp_test ? src_dp : src_sp)
+#define RES (dp_test ? res_dp : res_sp)
+   Bool src_is_negative = False;
+   Bool res_is_negative = False;
+   unsigned long long * dst_dp = NULL;
+   unsigned int * dst_sp = NULL;
+   if (dp_test) {
+      unsigned long long * src_dp_ull;
+      dst_dp = (unsigned long long *) &vec_out;
+      src_dp = spec_fargs[idx];
+      src_dp_ull = (unsigned long long *) &src_dp;
+      src_is_negative = (*src_dp_ull & 0x8000000000000000ULL) ? True : False;
+      res_is_negative = (dst_dp[output_vec_idx] & 0x8000000000000000ULL) ? True : False;
+      memcpy(&res_dp, &dst_dp[output_vec_idx], 8);
+   } else {
+      unsigned int * src_sp_uint;
+      dst_sp = (unsigned int *) &vec_out;
+      src_sp = spec_sp_fargs[idx];
+      src_sp_uint = (unsigned int *) &src_sp;
+      src_is_negative = (*src_sp_uint & 0x80000000) ? True : False;
+      res_is_negative = (dst_sp[output_vec_idx] & 0x80000000) ? True : False;
+      memcpy(&res_sp, &dst_sp[output_vec_idx], 4);
+   }
+
+   // Below are common rules for xvre{d|s}p and xvrsqrte{d|s}p
+   if (isnan(SRC))
+      return isnan(RES);
+   if (fpclassify(SRC) == FP_ZERO)
+      return isinf(RES);
+   if (!src_is_negative && isinf(SRC))
+      return !res_is_negative && (fpclassify(RES) == FP_ZERO);
+   if (is_rsqrte) {
+      if (src_is_negative)
+         return isnan(RES);
+   } else {
+      if (src_is_negative && isinf(SRC))
+         return res_is_negative && (fpclassify(RES) == FP_ZERO);
+   }
+   if (dp_test) {
+      double calc_diff;
+      double real_diff;
+      double recip_divisor;
+      double div_result;
+      double calc_diff_tmp;
+
+      if (is_rsqrte)
+         recip_divisor = sqrt(src_dp);
+      else
+         recip_divisor = src_dp;
+
+      div_result = 1.0/recip_divisor;
+      calc_diff_tmp = recip_divisor * 16384.0;
+      if (isnormal(calc_diff_tmp)) {
+         calc_diff = fabs(1.0/calc_diff_tmp);
+         real_diff = fabs(res_dp - div_result);
+         result = ( ( res_dp == div_result )
+                  || ( real_diff <= calc_diff ) );
+      } else {
+         /* Unable to compute theoretical difference, so we fall back to masking out
+          * un-precise bits.
+          */
+         unsigned long long * div_result_dp = (unsigned long long *) &div_result;
+         result = (dst_dp[output_vec_idx] & VSX_RECIP_ESTIMATE_MASK_DP) == (*div_result_dp & VSX_RECIP_ESTIMATE_MASK_DP);
+      }
+      /* For debug use . . .
+         if (!result) {
+             unsigned long long * dv = &div_result;
+             unsigned long long * rd = &real_diff;
+             unsigned long long * cd = &calc_diff;
+             printf("\n\t {actual div_result: %016llx; real_diff:  %016llx; calc_diff:  %016llx}\n",
+       *dv, *rd, *cd);
+          }
+       */
+   } else {  // single precision test (only have xvrsqrtesp, since xvresp was implemented in stage 2)
+      float calc_diff;
+      float real_diff;
+      float div_result;
+      float calc_diff_tmp;
+      float recip_divisor = sqrt(src_sp);
+
+      div_result = 1.0/recip_divisor;
+      calc_diff_tmp = recip_divisor * 16384.0;
+      if (isnormal(calc_diff_tmp)) {
+         calc_diff = fabsf(1.0/calc_diff_tmp);
+         real_diff = fabsf(res_sp - div_result);
+         result = ( ( res_sp == div_result )
+                  || ( real_diff <= calc_diff ) );
+      } else {
+         /* Unable to compute theoretical difference, so we fall back to masking out
+          * un-precise bits.
+          */
+         unsigned int * div_result_sp = (unsigned int *) &div_result;
+         result = (dst_sp[output_vec_idx] & VSX_RECIP_ESTIMATE_MASK_SP) == (*div_result_sp & VSX_RECIP_ESTIMATE_MASK_SP);
+      }
+      /* For debug use . . .
+         if (!result) {
+             unsigned long long * dv = &div_result;
+             unsigned long long * rd = &real_diff;
+             unsigned long long * cd = &calc_diff;
+             printf("\n\t {actual div_result: %016llx; real_diff:  %016llx; calc_diff:  %016llx}\n",
+       *dv, *rd, *cd);
+          }
+       */
+   }
+   return result;
+}
+
+typedef struct vx_fp_test
+{
+   test_func_t test_func;
+   const char * name;
+   fp_test_args_t * targs;
+   int num_tests;
+   precision_type_t precision;
+   vx_fp_test_type type;
+   const char * op;
+} vx_fp_test_t;
+
+
+static Bool do_dot;
+
+static void test_xvredp(void)
+{
+   __asm__ __volatile__ ("xvredp   %x0, %x1" : "=wa" (vec_out): "wa" (vec_inB));
+}
+
+static void test_xsredp(void)
+{
+   __asm__ __volatile__ ("xsredp   %x0, %x1" : "=wa" (vec_out): "wa" (vec_inB));
+}
+
+static void test_xvrsqrtedp(void)
+{
+   __asm__ __volatile__ ("xvrsqrtedp   %x0, %x1" : "=wa" (vec_out): "wa" (vec_inB));
+}
+
+static void test_xsrsqrtedp(void)
+{
+   __asm__ __volatile__ ("xsrsqrtedp   %x0, %x1" : "=wa" (vec_out): "wa" (vec_inB));
+}
+
+static void test_xvrsqrtesp(void)
+{
+   __asm__ __volatile__ ("xvrsqrtesp   %x0, %x1" : "=wa" (vec_out): "wa" (vec_inB));
+}
+
+static void test_xstsqrtdp(void)
+{
+   __asm__ __volatile__ ("xstsqrtdp   cr1, %x0" : : "wa" (vec_inB));
+}
+
+static void test_xvtsqrtdp(void)
+{
+   __asm__ __volatile__ ("xvtsqrtdp   cr1, %x0" : : "wa" (vec_inB));
+}
+
+static void test_xvtsqrtsp(void)
+{
+   __asm__ __volatile__ ("xvtsqrtsp   cr1, %x0" : : "wa" (vec_inB));
+}
+
+static void test_xvsqrtdp(void)
+{
+   __asm__ __volatile__ ("xvsqrtdp   %x0, %x1" : "=wa" (vec_out): "wa" (vec_inB));
+}
+
+static void test_xvsqrtsp(void)
+{
+   __asm__ __volatile__ ("xvsqrtsp   %x0, %x1" : "=wa" (vec_out): "wa" (vec_inB));
+}
+
+static void test_xvtdivdp(void)
+{
+   __asm__ __volatile__ ("xvtdivdp   cr1, %x0, %x1" : : "wa" (vec_inA), "wa" (vec_inB));
+}
+
+static void test_xvtdivsp(void)
+{
+   __asm__ __volatile__ ("xvtdivsp   cr1, %x0, %x1" : : "wa" (vec_inA), "wa" (vec_inB));
+}
+
+static void test_xscvdpsp(void)
+{
+   __asm__ __volatile__ ("xscvdpsp   %x0, %x1" : "=wa" (vec_out): "wa" (vec_inB));
+}
+
+static void test_xscvdpuxws(void)
+{
+   __asm__ __volatile__ ("xscvdpuxws   %x0, %x1" : "=wa" (vec_out): "wa" (vec_inB));
+}
+
+static void test_xscvspdp(void)
+{
+   __asm__ __volatile__ ("xscvspdp   %x0, %x1" : "=wa" (vec_out): "wa" (vec_inB));
+}
+
+static void test_xvcvdpsp(void)
+{
+   __asm__ __volatile__ ("xvcvdpsp   %x0, %x1" : "=wa" (vec_out): "wa" (vec_inB));
+}
+
+static void test_xvcvdpuxds(void)
+{
+   __asm__ __volatile__ ("xvcvdpuxds   %x0, %x1" : "=wa" (vec_out): "wa" (vec_inB));
+}
+
+static void test_xvcvdpuxws(void)
+{
+   __asm__ __volatile__ ("xvcvdpuxws   %x0, %x1" : "=wa" (vec_out): "wa" (vec_inB));
+}
+
+static void test_xvcvspdp(void)
+{
+   __asm__ __volatile__ ("xvcvspdp   %x0, %x1" : "=wa" (vec_out): "wa" (vec_inB));
+}
+
+static void test_xvcvspsxds(void)
+{
+   __asm__ __volatile__ ("xvcvspsxds   %x0, %x1" : "=wa" (vec_out): "wa" (vec_inB));
+}
+
+static void test_xvcvspuxds(void)
+{
+   __asm__ __volatile__ ("xvcvspuxds   %x0, %x1" : "=wa" (vec_out): "wa" (vec_inB));
+}
+
+static void test_xvcvdpsxds(void)
+{
+   __asm__ __volatile__ ("xvcvdpsxds   %x0, %x1" : "=wa" (vec_out): "wa" (vec_inB));
+}
+
+static void test_xvcvspuxws(void)
+{
+   __asm__ __volatile__ ("xvcvspuxws   %x0, %x1" : "=wa" (vec_out): "wa" (vec_inB));
+}
+
+static void test_xvcvsxddp(void)
+{
+   __asm__ __volatile__ ("xvcvsxddp   %x0, %x1" : "=wa" (vec_out): "wa" (vec_inB));
+}
+
+static void test_xvcvuxddp(void)
+{
+   __asm__ __volatile__ ("xvcvuxddp   %x0, %x1" : "=wa" (vec_out): "wa" (vec_inB));
+}
+
+static void test_xvcvsxdsp(void)
+{
+   __asm__ __volatile__ ("xvcvsxdsp   %x0, %x1" : "=wa" (vec_out): "wa" (vec_inB));
+}
+
+static void test_xvcvuxdsp(void)
+{
+   __asm__ __volatile__ ("xvcvuxdsp   %x0, %x1" : "=wa" (vec_out): "wa" (vec_inB));
+}
+
+static void test_xvcvsxwdp(void)
+{
+   __asm__ __volatile__ ("xvcvsxwdp   %x0, %x1" : "=wa" (vec_out): "wa" (vec_inB));
+}
+
+static void test_xvcvuxwdp(void)
+{
+   __asm__ __volatile__ ("xvcvuxwdp   %x0, %x1" : "=wa" (vec_out): "wa" (vec_inB));
+}
+
+static void test_xvcvsxwsp(void)
+{
+   __asm__ __volatile__ ("xvcvsxwsp   %x0, %x1" : "=wa" (vec_out): "wa" (vec_inB));
+}
+
+static void test_xvcvuxwsp(void)
+{
+   __asm__ __volatile__ ("xvcvuxwsp   %x0, %x1" : "=wa" (vec_out): "wa" (vec_inB));
+}
+
+static void test_xsrdpic(void)
+{
+   __asm__ __volatile__ ("xsrdpic   %x0, %x1" : "=wa" (vec_out): "wa" (vec_inB));
+}
+
+static void test_xsrdpiz(void)
+{
+   __asm__ __volatile__ ("xsrdpiz   %x0, %x1" : "=wa" (vec_out): "wa" (vec_inB));
+}
+
+static void test_xsrdpi(void)
+{
+   __asm__ __volatile__ ("xsrdpi   %x0, %x1" : "=wa" (vec_out): "wa" (vec_inB));
+}
+
+static void test_xvabsdp(void)
+{
+   __asm__ __volatile__ ("xvabsdp   %x0, %x1" : "=wa" (vec_out): "wa" (vec_inB));
+}
+
+static void test_xvnabsdp(void)
+{
+   __asm__ __volatile__ ("xvnabsdp   %x0, %x1" : "=wa" (vec_out): "wa" (vec_inB));
+}
+
+static void test_xvnegdp(void)
+{
+   __asm__ __volatile__ ("xvnegdp   %x0, %x1" : "=wa" (vec_out): "wa" (vec_inB));
+}
+
+static void test_xvabssp(void)
+{
+   __asm__ __volatile__ ("xvabssp   %x0, %x1" : "=wa" (vec_out): "wa" (vec_inB));
+}
+
+static void test_xvnabssp(void)
+{
+   __asm__ __volatile__ ("xvnabssp   %x0, %x1" : "=wa" (vec_out): "wa" (vec_inB));
+}
+
+static void test_xvrdpi(void)
+{
+   __asm__ __volatile__ ("xvrdpi   %x0, %x1" : "=wa" (vec_out): "wa" (vec_inB));
+}
+
+static void test_xvrdpic(void)
+{
+   __asm__ __volatile__ ("xvrdpic   %x0, %x1" : "=wa" (vec_out): "wa" (vec_inB));
+}
+
+static void test_xvrdpim(void)
+{
+   __asm__ __volatile__ ("xvrdpim   %x0, %x1" : "=wa" (vec_out): "wa" (vec_inB));
+}
+
+static void test_xvrdpip(void)
+{
+   __asm__ __volatile__ ("xvrdpip   %x0, %x1" : "=wa" (vec_out): "wa" (vec_inB));
+}
+
+static void test_xvrdpiz(void)
+{
+   __asm__ __volatile__ ("xvrdpiz   %x0, %x1" : "=wa" (vec_out): "wa" (vec_inB));
+}
+
+static void test_xvrspi(void)
+{
+   __asm__ __volatile__ ("xvrspi   %x0, %x1" : "=wa" (vec_out): "wa" (vec_inB));
+}
+
+static void test_xvrspic(void)
+{
+   __asm__ __volatile__ ("xvrspic   %x0, %x1" : "=wa" (vec_out): "wa" (vec_inB));
+}
+
+static void test_xvrspim(void)
+{
+   __asm__ __volatile__ ("xvrspim   %x0, %x1" : "=wa" (vec_out): "wa" (vec_inB));
+}
+
+static void test_xvrspip(void)
+{
+   __asm__ __volatile__ ("xvrspip   %x0, %x1" : "=wa" (vec_out): "wa" (vec_inB));
+}
+
+static void test_xvrspiz(void)
+{
+   __asm__ __volatile__ ("xvrspiz   %x0, %x1" : "=wa" (vec_out): "wa" (vec_inB));
+}
+
+static vx_fp_test_t
+vsx_one_fp_arg_tests[] = {
+                                { &test_xvredp, "xvredp", NULL, 18, DOUBLE_TEST, VX_ESTIMATE, "1/x"},
+                                { &test_xsredp, "xsredp", NULL, 18, DOUBLE_TEST, VX_ESTIMATE, "1/x"},
+                                { &test_xvrsqrtedp, "xvrsqrtedp", NULL, 18, DOUBLE_TEST, VX_ESTIMATE, "1/x-sqrt"},
+                                { &test_xsrsqrtedp, "xsrsqrtedp", NULL, 18, DOUBLE_TEST, VX_ESTIMATE, "1/x-sqrt"},
+                                { &test_xvrsqrtesp, "xvrsqrtesp", NULL, 18, SINGLE_TEST, VX_ESTIMATE, "1/x-sqrt"},
+                                { &test_xvsqrtdp, "xvsqrtdp", NULL, 18, DOUBLE_TEST, VX_DEFAULT, "sqrt"},
+                                { &test_xvsqrtsp, "xvsqrtsp", NULL, 18, SINGLE_TEST, VX_DEFAULT, "sqrt"},
+                                { &test_xscvdpsp, "xscvdpsp", NULL, 20, DOUBLE_TEST, VX_CONV_TO_SINGLE, "conv"},
+                                { &test_xscvdpuxws, "xscvdpuxws", NULL, 20, DOUBLE_TEST, VX_SCALAR_CONV_TO_WORD, "conv"},
+                                { &test_xscvspdp, "xscvspdp", NULL, 20, SINGLE_TEST, VX_CONV_TO_DOUBLE, "conv"},
+                                { &test_xvcvdpsp, "xvcvdpsp", NULL, 20, DOUBLE_TEST, VX_CONV_TO_SINGLE, "conv"},
+                                { &test_xvcvdpuxds, "xvcvdpuxds", NULL, 20, DOUBLE_TEST, VX_CONV_TO_DOUBLE, "conv"},
+                                { &test_xvcvdpuxws, "xvcvdpuxws", NULL, 20, DOUBLE_TEST, VX_CONV_TO_SINGLE, "conv"},
+                                { &test_xvcvspdp, "xvcvspdp", NULL, 20, SINGLE_TEST, VX_CONV_TO_DOUBLE, "conv"},
+                                { &test_xvcvspsxds, "xvcvspsxds", NULL, 20, SINGLE_TEST, VX_CONV_TO_DOUBLE, "conv"},
+                                { &test_xvcvdpsxds, "xvcvdpsxds", NULL, 20, DOUBLE_TEST, VX_CONV_TO_DOUBLE, "conv"},
+                                { &test_xvcvspuxds, "xvcvspuxds", NULL, 20, SINGLE_TEST, VX_CONV_TO_DOUBLE, "conv"},
+                                { &test_xvcvspuxws, "xvcvspuxws", NULL, 20, SINGLE_TEST, VX_CONV_TO_SINGLE, "conv"},
+                                { &test_xsrdpic, "xsrdpic", NULL, 20, DOUBLE_TEST, VX_CONV_TO_DOUBLE, "round"},
+                                { &test_xsrdpiz, "xsrdpiz", NULL, 20, DOUBLE_TEST, VX_CONV_TO_DOUBLE, "round"},
+                                { &test_xsrdpi, "xsrdpi", NULL, 20, DOUBLE_TEST, VX_CONV_TO_DOUBLE, "round"},
+                                { &test_xvabsdp, "xvabsdp", NULL, 20, DOUBLE_TEST, VX_DEFAULT, "abs"},
+                                { &test_xvnabsdp, "xvnabsdp", NULL, 20, DOUBLE_TEST, VX_DEFAULT, "nabs"},
+                                { &test_xvnegdp, "xvnegdp", NULL, 20, DOUBLE_TEST, VX_DEFAULT, "neg"},
+                                { &test_xvabssp, "xvabssp", NULL, 20, SINGLE_TEST, VX_DEFAULT, "abs"},
+                                { &test_xvnabssp, "xvnabssp", NULL, 20, SINGLE_TEST, VX_DEFAULT, "nabs"},
+                                { &test_xvrdpi,  "xvrdpi",  NULL, 20, DOUBLE_TEST, VX_CONV_TO_DOUBLE, "round"},
+                                { &test_xvrdpic, "xvrdpic", NULL, 20, DOUBLE_TEST, VX_CONV_TO_DOUBLE, "round"},
+                                { &test_xvrdpim, "xvrdpim", NULL, 20, DOUBLE_TEST, VX_CONV_TO_DOUBLE, "round"},
+                                { &test_xvrdpip, "xvrdpip", NULL, 20, DOUBLE_TEST, VX_CONV_TO_DOUBLE, "round"},
+                                { &test_xvrdpiz, "xvrdpiz", NULL, 20, DOUBLE_TEST, VX_CONV_TO_DOUBLE, "round"},
+                                { &test_xvrspi,  "xvrspi",  NULL, 20, SINGLE_TEST, VX_CONV_TO_SINGLE, "round"},
+                                { &test_xvrspic, "xvrspic", NULL, 20, SINGLE_TEST, VX_CONV_TO_SINGLE, "round"},
+                                { &test_xvrspim, "xvrspim", NULL, 20, SINGLE_TEST, VX_CONV_TO_SINGLE, "round"},
+                                { &test_xvrspip, "xvrspip", NULL, 20, SINGLE_TEST, VX_CONV_TO_SINGLE, "round"},
+                                { &test_xvrspiz, "xvrspiz", NULL, 20, SINGLE_TEST, VX_CONV_TO_SINGLE, "round"},
+                                { NULL, NULL, NULL, 0, 0, 0, NULL}
+};
+
+static vx_fp_test_t
+vx_tdivORtsqrt_tests[] = {
+                          { &test_xstsqrtdp, "xstsqrtdp", NULL, 20, DOUBLE_TEST, VX_DEFAULT, "test-sqrt"},
+                          { &test_xvtsqrtdp, "xvtsqrtdp", NULL, 20, DOUBLE_TEST, VX_DEFAULT, "test-sqrt"},
+                          { &test_xvtsqrtsp, "xvtsqrtsp", NULL, 20, SINGLE_TEST, VX_DEFAULT, "test-sqrt"},
+                          { &test_xvtdivdp, "xvtdivdp", two_arg_fp_tests, 68, DOUBLE_TEST, VX_DEFAULT, "test-div"},
+                          { &test_xvtdivsp, "xvtdivsp", two_arg_fp_tests, 68, SINGLE_TEST, VX_DEFAULT, "test-div"},
+                          { NULL, NULL, NULL, 0 , 0, 0, NULL}
+};
+
+static unsigned long long doubleWord[] = { 0,
+                                  0xffffffff00000000LL,
+                                  0x00000000ffffffffLL,
+                                  0xffffffffffffffffLL,
+                                  0x89abcde123456789LL,
+                                  0x0102030405060708LL,
+                                  0x00000000a0b1c2d3LL,
+                                  0x1111222233334444LL
+};
+
+static unsigned int singleWord[] = {0,
+                                  0xffff0000,
+                                  0x0000ffff,
+                                  0xffffffff,
+                                  0x89a73522,
+                                  0x01020304,
+                                  0x0000abcd,
+                                  0x11223344
+};
+
+typedef struct vx_intToFp_test
+{
+   test_func_t test_func;
+   const char * name;
+   void * targs;
+   int num_tests;
+   precision_type_t precision;
+   vx_fp_test_type type;
+} vx_intToFp_test_t;
+
+static vx_intToFp_test_t
+intToFp_tests[] = {
+                   { test_xvcvsxddp, "xvcvsxddp", (void *)doubleWord, 8, DOUBLE_TEST, VX_CONV_TO_DOUBLE },
+                   { test_xvcvuxddp, "xvcvuxddp", (void *)doubleWord, 8, DOUBLE_TEST, VX_CONV_TO_DOUBLE },
+                   { test_xvcvsxdsp, "xvcvsxdsp", (void *)doubleWord, 8, DOUBLE_TEST, VX_CONV_TO_SINGLE },
+                   { test_xvcvuxdsp, "xvcvuxdsp", (void *)doubleWord, 8, DOUBLE_TEST, VX_CONV_TO_SINGLE },
+                   { test_xvcvsxwdp, "xvcvsxwdp", (void *)singleWord, 8, SINGLE_TEST, VX_CONV_TO_DOUBLE },
+                   { test_xvcvuxwdp, "xvcvuxwdp", (void *)singleWord, 8, SINGLE_TEST, VX_CONV_TO_DOUBLE },
+                   { test_xvcvsxwsp, "xvcvsxwsp", (void *)singleWord, 8, SINGLE_TEST, VX_CONV_TO_SINGLE },
+                   { test_xvcvuxwsp, "xvcvuxwsp", (void *)singleWord, 8, SINGLE_TEST, VX_CONV_TO_SINGLE },
+                   { NULL, NULL, NULL, 0, 0 }
+};
+
+static Bool do_OE;
+typedef enum {
+   DIV_BASE = 1,
+   DIV_OE = 2,
+   DIV_DOT = 4,
+} div_type_t;
+/* Possible divde type combinations are:
+ *   - base
+ *   - base+dot
+ *   - base+OE
+ *   - base+OE+dot
+ */
+#ifdef __powerpc64__
+static void test_divdeu(void)
+{
+   int divdeu_type = DIV_BASE;
+   if (do_OE)
+      divdeu_type |= DIV_OE;
+   if (do_dot)
+      divdeu_type |= DIV_DOT;
+
+   switch (divdeu_type) {
+      case 1:
+        SET_CR_XER_ZERO;
+         __asm__ __volatile__ ("divdeu %0, %1, %2" : "=r" (r17) : "r" (r14),"r" (r15));
+         GET_CR_XER(div_flags, div_xer);
+         break;
+      case 3:
+        SET_CR_XER_ZERO;
+         __asm__ __volatile__ ("divdeuo %0, %1, %2" : "=r" (r17) : "r" (r14),"r" (r15));
+         GET_CR_XER(div_flags, div_xer);
+         break;
+      case 5:
+        SET_CR_XER_ZERO;
+         __asm__ __volatile__ ("divdeu. %0, %1, %2" : "=r" (r17) : "r" (r14),"r" (r15));
+         GET_CR_XER(div_flags, div_xer);
+         break;
+      case 7:
+        SET_CR_XER_ZERO;
+         __asm__ __volatile__ ("divdeuo. %0, %1, %2" : "=r" (r17) : "r" (r14),"r" (r15));
+         GET_CR_XER(div_flags, div_xer);
+         break;
+      default:
+         fprintf(stderr, "Invalid divdeu type. Exiting\n");
+         exit(1);
+   }
+}
+#endif
+
+static void test_divwe(void)
+{
+   int divwe_type = DIV_BASE;
+   if (do_OE)
+      divwe_type |= DIV_OE;
+   if (do_dot)
+      divwe_type |= DIV_DOT;
+
+   switch (divwe_type) {
+      case 1:
+        SET_CR_XER_ZERO;
+         __asm__ __volatile__ ("divwe %0, %1, %2" : "=r" (r17) : "r" (r14),"r" (r15));
+         GET_CR_XER(div_flags, div_xer);
+         break;
+      case 3:
+        SET_CR_XER_ZERO;
+         __asm__ __volatile__ ("divweo %0, %1, %2" : "=r" (r17) : "r" (r14),"r" (r15));
+         GET_CR_XER(div_flags, div_xer);
+         break;
+      case 5:
+        SET_CR_XER_ZERO;
+         __asm__ __volatile__ ("divwe. %0, %1, %2" : "=r" (r17) : "r" (r14),"r" (r15));
+         GET_CR_XER(div_flags, div_xer);
+         break;
+      case 7:
+        SET_CR_XER_ZERO;
+         __asm__ __volatile__ ("divweo. %0, %1, %2" : "=r" (r17) : "r" (r14),"r" (r15));
+         GET_CR_XER(div_flags, div_xer);
+         break;
+      default:
+         fprintf(stderr, "Invalid divweu type. Exiting\n");
+         exit(1);
+   }
+}
+
+
+typedef struct simple_test {
+   test_func_t test_func;
+   char * name;
+   precision_type_t precision;
+} simple_test_t;
+
+
+static void setup_sp_fp_args(fp_test_args_t * targs, Bool swap_inputs)
+{
+   int a_idx, b_idx, i;
+   void * inA, * inB;
+   void * vec_src = swap_inputs ? &vec_out : &vec_inB;
+
+   for (i = 0; i < 4; i++) {
+      a_idx = targs->fra_idx;
+      b_idx = targs->frb_idx;
+      inA = (void *)&spec_sp_fargs[a_idx];
+      inB = (void *)&spec_sp_fargs[b_idx];
+      // copy single precision FP  into vector element i
+      memcpy(((void *)&vec_inA) + (i * 4), inA, 4);
+      memcpy(vec_src + (i * 4), inB, 4);
+      targs++;
+   }
+}
+
+static void setup_dp_fp_args(fp_test_args_t * targs, Bool swap_inputs)
+{
+   int a_idx, b_idx, i;
+   void * inA, * inB;
+   void * vec_src = swap_inputs ? (void *)&vec_out : (void *)&vec_inB;
+
+   for (i = 0; i < 2; i++) {
+      a_idx = targs->fra_idx;
+      b_idx = targs->frb_idx;
+      inA = (void *)&spec_fargs[a_idx];
+      inB = (void *)&spec_fargs[b_idx];
+      // copy double precision FP  into vector element i
+      memcpy(((void *)&vec_inA) + (i * 8), inA, 8);
+      memcpy(vec_src + (i * 8), inB, 8);
+      targs++;
+   }
+}
+
+#define VX_NOT_CMP_OP 0xffffffff
+static void print_vector_fp_result(unsigned int cc, vx_fp_test_t * test_group, int i, Bool print_vec_out)
+{
+   int a_idx, b_idx, k;
+   char * name = malloc(20);
+   int dp = test_group->precision == DOUBLE_TEST ? 1 : 0;
+   int loops = dp ? 2 : 4;
+   fp_test_args_t * targs = &test_group->targs[i];
+   unsigned long long * frA_dp, * frB_dp, * dst_dp;
+   unsigned int * frA_sp, *frB_sp, * dst_sp;
+   strcpy(name, test_group->name);
+   printf("#%d: %s%s ", dp? i/2 : i/4, name, (do_dot ? "." : ""));
+   for (k = 0; k < loops; k++) {
+      a_idx = targs->fra_idx;
+      b_idx = targs->frb_idx;
+      if (k)
+         printf(" AND ");
+      if (dp) {
+         frA_dp = (unsigned long long *)&spec_fargs[a_idx];
+         frB_dp = (unsigned long long *)&spec_fargs[b_idx];
+         printf("%016llx %s %016llx", *frA_dp, test_group->op, *frB_dp);
+      } else {
+         frA_sp = (unsigned int *)&spec_sp_fargs[a_idx];
+         frB_sp = (unsigned int *)&spec_sp_fargs[b_idx];
+         printf("%08x %s %08x", *frA_sp, test_group->op, *frB_sp);
+      }
+      targs++;
+   }
+   if (cc != VX_NOT_CMP_OP)
+      printf(" ? cc=%x", cc);
+
+   if (print_vec_out) {
+      if (dp) {
+         dst_dp = (unsigned long long *) &vec_out;
+         printf(" => %016llx %016llx\n", dst_dp[0], dst_dp[1]);
+      } else {
+         dst_sp = (unsigned int *) &vec_out;
+         printf(" => %08x %08x %08x %08x\n", dst_sp[0], dst_sp[1], dst_sp[2], dst_sp[3]);
+      }
+   } else {
+      printf("\n");
+   }
+   free(name);
+}
+
+
+
+static void test_vsx_one_fp_arg(void)
+{
+   test_func_t func;
+   int k;
+   k = 0;
+   build_special_fargs_table();
+
+   while ((func = vsx_one_fp_arg_tests[k].test_func)) {
+      int idx, i;
+      vx_fp_test_t test_group = vsx_one_fp_arg_tests[k];
+      Bool estimate = (test_group.type == VX_ESTIMATE);
+      Bool dp = (test_group.precision == DOUBLE_TEST) ? True : False;
+      Bool is_sqrt = (strstr(test_group.name, "sqrt")) ? True : False;
+      Bool is_scalar = (strstr(test_group.name, "xs")) ? True : False;
+      Bool sparse_sp = False;
+      int stride = dp ? 2 : 4;
+      int loops = is_scalar ? 1 : stride;
+      stride = is_scalar ? 1: stride;
+
+      /* For conversions of single to double, the 128-bit input register is sparsely populated:
+       *    |___ SP___|_Unused_|___SP___|__Unused__|   // for vector op
+       *                     or
+       *    |___ SP___|_Unused_|_Unused_|__Unused__|   // for scalar op
+       *
+       * For the vector op case, we need to adjust stride from '4' to '2', since
+       * we'll only be loading two values per loop into the input register.
+       */
+      if (!dp && !is_scalar && test_group.type == VX_CONV_TO_DOUBLE) {
+         sparse_sp = True;
+         stride = 2;
+      }
+
+      for (i = 0; i < test_group.num_tests; i+=stride) {
+         unsigned int * pv;
+         void * inB;
+
+         pv = (unsigned int *)&vec_out;
+         // clear vec_out
+         for (idx = 0; idx < 4; idx++, pv++)
+            *pv = 0;
+
+         if (dp) {
+            int j;
+            unsigned long long * frB_dp, *dst_dp;
+            for (j = 0; j < loops; j++) {
+               inB = (void *)&spec_fargs[i + j];
+               // copy double precision FP into vector element i
+               memcpy(((void *)&vec_inB) + (j * 8), inB, 8);
+            }
+            // execute test insn
+            (*func)();
+            dst_dp = (unsigned long long *) &vec_out;
+            printf("#%d: %s ", i/stride, test_group.name);
+            for (j = 0; j < loops; j++) {
+               if (j)
+                  printf("; ");
+               frB_dp = (unsigned long long *)&spec_fargs[i + j];
+               printf("%s(%016llx)", test_group.op, *frB_dp);
+               if (estimate) {
+                  Bool res = check_estimate(DOUBLE_TEST, is_sqrt, i + j, j);
+                  printf(" ==> %s)", res ? "PASS" : "FAIL");
+                  /* For debugging . . .
+                   printf(" ==> %s (res=%016llx)", res ? "PASS" : "FAIL", dst_dp[j]);
+                   */
+               } else {
+                  vx_fp_test_type type = test_group.type;
+                  switch (type) {
+                     case VX_SCALAR_CONV_TO_WORD:
+                        printf(" = %016llx", dst_dp[j] & 0x00000000ffffffffULL);
+                        break;
+                     case VX_CONV_TO_SINGLE:
+                        printf(" = %016llx", dst_dp[j] & 0xffffffff00000000ULL);
+                        break;
+                     default:  // For VX_CONV_TO_DOUBLE and non-convert instructions . . .
+                        printf(" = %016llx", dst_dp[j]);
+                  }
+               }
+            }
+            printf("\n");
+         } else {
+            int j, skip_slot;
+            unsigned int * frB_sp, * dst_sp = NULL;
+            unsigned long long * dst_dp = NULL;
+            if (sparse_sp) {
+               skip_slot = 1;
+               loops = 2;
+            } else {
+               skip_slot = 0;
+            }
+            for (j = 0; j < loops; j++) {
+               inB = (void *)&spec_sp_fargs[i + j];
+               // copy single precision FP into vector element i
+               if (skip_slot && j > 0)
+                  memcpy(((void *)&vec_inB) + ((j + j) * 4), inB, 4);
+               else
+                  memcpy(((void *)&vec_inB) + (j * 4), inB, 4);
+            }
+            // execute test insn
+            (*func)();
+            if (test_group.type == VX_CONV_TO_DOUBLE)
+               dst_dp = (unsigned long long *) &vec_out;
+            else
+               dst_sp = (unsigned int *) &vec_out;
+            // print result
+            printf("#%d: %s ", i/stride, test_group.name);
+            for (j = 0; j < loops; j++) {
+               if (j)
+                  printf("; ");
+               frB_sp = (unsigned int *)&spec_sp_fargs[i + j];
+               printf("%s(%08x)", test_group.op, *frB_sp);
+               if (estimate) {
+                  Bool res = check_estimate(SINGLE_TEST, is_sqrt, i + j, j);
+                  printf(" ==> %s)", res ? "PASS" : "FAIL");
+               } else {
+                  if (test_group.type == VX_CONV_TO_DOUBLE)
+                        printf(" = %016llx", dst_dp[j]);
+                  else
+                  /* Special case: Current VEX implementation for fsqrts (single precision)
+                   * uses the same implementation as that used for double precision fsqrt.
+                   * However, I've found that for xvsqrtsp, the result from that implementation
+                   * may be off by the two LSBs.  Generally, even this small inaccuracy can cause the
+                   * output to appear very different if you end up with a carry.  But for the given
+                   * inputs in this testcase, we can simply mask out these bits.
+                   */
+                     printf(" = %08x", is_sqrt ? (dst_sp[j] & 0xfffffffc) : dst_sp[j]);
+               }
+            }
+            printf("\n");
+         }
+      }
+      k++;
+      printf( "\n" );
+   }
+}
+
+static void test_int_to_fp_convert(void)
+{
+   test_func_t func;
+   int k;
+   k = 0;
+
+   while ((func = intToFp_tests[k].test_func)) {
+      int idx, i;
+      vx_intToFp_test_t test_group = intToFp_tests[k];
+      Bool dp = (test_group.precision == DOUBLE_TEST) ? True : False;
+      Bool sparse_sp = False;
+      int stride = dp ? 2 : 4;
+      int loops = stride;
+
+      /* For conversions of single to double, the 128-bit input register is sparsely populated:
+       *    |___ int___|_Unused_|___int___|__Unused__|   // for vector op
+       *                     or
+       * We need to adjust stride from '4' to '2', since we'll only be loading
+       * two values per loop into the input register.
+       */
+      if (!dp && test_group.type == VX_CONV_TO_DOUBLE) {
+         sparse_sp = True;
+         stride = 2;
+      }
+
+      for (i = 0; i < test_group.num_tests; i+=stride) {
+         unsigned int * pv;
+         void * inB;
+
+         pv = (unsigned int *)&vec_out;
+         // clear vec_out
+         for (idx = 0; idx < 4; idx++, pv++)
+            *pv = 0;
+
+         if (dp) {
+            int j;
+            unsigned long long  *dst_dw, * targs = test_group.targs;
+            for (j = 0; j < loops; j++) {
+               inB = (void *)&targs[i + j];
+               // copy doubleword into vector element i
+               memcpy(((void *)&vec_inB) + (j * 8), inB, 8);
+            }
+            // execute test insn
+            (*func)();
+            dst_dw = (unsigned long long *) &vec_out;
+            printf("#%d: %s ", i/stride, test_group.name);
+            for (j = 0; j < loops; j++) {
+               if (j)
+                  printf("; ");
+               printf("conv(%016llx)", targs[i + j]);
+
+               if (test_group.type == VX_CONV_TO_SINGLE)
+                  printf(" = %016llx", dst_dw[j] & 0xffffffff00000000ULL);
+               else
+                  printf(" = %016llx", dst_dw[j]);
+            }
+            printf("\n");
+         } else {
+            int j, skip_slot;
+            unsigned int * dst_sp = NULL;
+            unsigned int * targs = test_group.targs;
+            unsigned long long * dst_dp = NULL;
+            if (sparse_sp) {
+               skip_slot = 1;
+               loops = 2;
+            } else {
+               skip_slot = 0;
+            }
+            for (j = 0; j < loops; j++) {
+               inB = (void *)&targs[i + j];
+               // copy single word into vector element i
+               if (skip_slot && j > 0)
+                  memcpy(((void *)&vec_inB) + ((j + j) * 4), inB, 4);
+               else
+                  memcpy(((void *)&vec_inB) + (j * 4), inB, 4);
+            }
+            // execute test insn
+            (*func)();
+            if (test_group.type == VX_CONV_TO_DOUBLE)
+               dst_dp = (unsigned long long *) &vec_out;
+            else
+               dst_sp = (unsigned int *) &vec_out;
+            // print result
+            printf("#%d: %s ", i/stride, test_group.name);
+            for (j = 0; j < loops; j++) {
+               if (j)
+                  printf("; ");
+               printf("conv(%08x)", targs[i + j]);
+               if (test_group.type == VX_CONV_TO_DOUBLE)
+                  printf(" = %016llx", dst_dp[j]);
+               else
+                  printf(" = %08x", dst_sp[j]);
+            }
+            printf("\n");
+         }
+      }
+      k++;
+      printf( "\n" );
+   }
+}
+
+
+
+// The div doubleword test data
+signed long long div_dw_tdata[13][2] = {
+                                       { 4, -4 },
+                                       { 4, -3 },
+                                       { 4, 4 },
+                                       { 4, -5 },
+                                       { 3, 8 },
+                                       { 0x8000000000000000, 0xa },
+                                       { 0x50c, -1 },
+                                       { 0x50c, -4096 },
+                                       { 0x1234fedc, 0x8000a873 },
+                                       { 0xabcd87651234fedc, 0xa123b893 },
+                                       { 0x123456789abdc, 0 },
+                                       { 0, 2 },
+                                       { 0x77, 0xa3499 }
+};
+#define dw_tdata_len (sizeof(div_dw_tdata)/sizeof(signed long long)/2)
+
+// The div word test data
+unsigned int div_w_tdata[6][2] = {
+                              { 0, 2 },
+                              { 2, 0 },
+                              { 0x7abc1234, 0xf0000000 },
+                              { 0xfabc1234, 5 },
+                              { 77, 66 },
+                              { 5, 0xfabc1234 },
+};
+#define w_tdata_len (sizeof(div_w_tdata)/sizeof(unsigned int)/2)
+
+typedef struct div_ext_test
+{
+   test_func_t test_func;
+   const char *name;
+   int num_tests;
+   div_type_t div_type;
+   precision_type_t precision;
+} div_ext_test_t;
+
+static div_ext_test_t div_tests[] = {
+#ifdef __powerpc64__
+                                   { &test_divdeu, "divdeu", dw_tdata_len, DIV_BASE, DOUBLE_TEST },
+                                   { &test_divdeu, "divdeuo", dw_tdata_len, DIV_OE, DOUBLE_TEST },
+#endif
+                                   { &test_divwe, "divwe", w_tdata_len, DIV_BASE, SINGLE_TEST },
+                                   { &test_divwe, "divweo", w_tdata_len, DIV_OE, SINGLE_TEST },
+                                   { NULL, NULL, 0, 0, 0 }
+};
+
+static void test_div_extensions(void)
+{
+   test_func_t func;
+   int k;
+   k = 0;
+
+   while ((func = div_tests[k].test_func)) {
+      int i, repeat = 1;
+      div_ext_test_t test_group = div_tests[k];
+      do_dot = False;
+
+again:
+      for (i = 0; i < test_group.num_tests; i++) {
+         unsigned int condreg;
+
+         if (test_group.div_type == DIV_OE)
+            do_OE = True;
+         else
+            do_OE = False;
+
+         if (test_group.precision == DOUBLE_TEST) {
+            r14 = div_dw_tdata[i][0];
+            r15 = div_dw_tdata[i][1];
+         } else {
+            r14 = div_w_tdata[i][0];
+            r15 = div_w_tdata[i][1];
+         }
+         // execute test insn
+         (*func)();
+         condreg = (div_flags & 0xf0000000) >> 28;
+         printf("#%d: %s%s: ", i, test_group.name, do_dot ? "." : "");
+         if (test_group.precision == DOUBLE_TEST) {
+            printf("0x%016llx0000000000000000 / 0x%016llx = 0x%016llx;",
+                   div_dw_tdata[i][0], div_dw_tdata[i][1], (signed long long) r17);
+         } else {
+            printf("0x%08x00000000 / 0x%08x = 0x%08x;",
+                   div_w_tdata[i][0], div_w_tdata[i][1], (unsigned int) r17);
+         }
+         printf(" CR=%x; XER=%x\n", condreg, div_xer);
+      }
+      printf("\n");
+      if (repeat) {
+         repeat = 0;
+         do_dot = True;
+         goto again;
+      }
+      k++;
+      printf( "\n" );
+   }
+}
+
+
+static void test_vx_tdivORtsqrt(void)
+{
+   test_func_t func;
+   int k, crx;
+   unsigned int flags;
+   k = 0;
+   do_dot = False;
+   build_special_fargs_table();
+
+   while ((func = vx_tdivORtsqrt_tests[k].test_func)) {
+      int idx, i;
+      vx_fp_test_t test_group = vx_tdivORtsqrt_tests[k];
+      Bool dp = (test_group.precision == DOUBLE_TEST) ? True : False;
+      Bool is_scalar = (strstr(test_group.name, "xs")) ? True : False;
+      Bool two_args = test_group.targs ?  True : False;
+      int stride = dp ? 2 : 4;
+      int loops = is_scalar ? 1 : stride;
+      stride = is_scalar ? 1: stride;
+
+      for (i = 0; i < test_group.num_tests; i+=stride) {
+         unsigned int * pv;
+         void * inB;
+
+         pv = (unsigned int *)&vec_out;
+         // clear vec_out
+         for (idx = 0; idx < 4; idx++, pv++)
+            *pv = 0;
+
+         if (dp) {
+            int j;
+            unsigned long long * frB_dp;
+            if (two_args) {
+               setup_dp_fp_args(&test_group.targs[i], False);
+            } else {
+               for (j = 0; j < loops; j++) {
+                  inB = (void *)&spec_fargs[i + j];
+                  // copy double precision FP into vector element i
+                  memcpy(((void *)&vec_inB) + (j * 8), inB, 8);
+               }
+            }
+            // execute test insn
+            // Must do set/get of CRs immediately before/after calling the asm func
+            // to avoid CRs being modified by other instructions.
+            SET_FPSCR_ZERO;
+            SET_CR_XER_ZERO;
+            (*func)();
+            GET_CR(flags);
+            // assumes using CR1
+            crx = (flags & 0x0f000000) >> 24;
+            if (two_args) {
+               print_vector_fp_result(crx, &test_group, i, False/*do not print vec_out*/);
+            } else {
+               printf("#%d: %s ", i/stride, test_group.name);
+               for (j = 0; j < loops; j++) {
+                  if (j)
+                     printf("; ");
+                  frB_dp = (unsigned long long *)&spec_fargs[i + j];
+                  printf("%s(%016llx)", test_group.op, *frB_dp);
+               }
+               printf( " ? %x (CRx)\n", crx);
+            }
+         } else {
+            int j;
+            unsigned int * frB_sp;
+            if (two_args) {
+               setup_sp_fp_args(&test_group.targs[i], False);
+            } else {
+               for (j = 0; j < loops; j++) {
+                  inB = (void *)&spec_sp_fargs[i + j];
+                  // copy single precision FP into vector element i
+                  memcpy(((void *)&vec_inB) + (j * 4), inB, 4);
+               }
+            }
+            // execute test insn
+            SET_FPSCR_ZERO;
+            SET_CR_XER_ZERO;
+            (*func)();
+            GET_CR(flags);
+            crx = (flags & 0x0f000000) >> 24;
+            // print result
+            if (two_args) {
+               print_vector_fp_result(crx, &test_group, i, False/*do not print vec_out*/);
+            } else {
+               printf("#%d: %s ", i/stride, test_group.name);
+               for (j = 0; j < loops; j++) {
+                  if (j)
+                     printf("; ");
+                  frB_sp = (unsigned int *)&spec_sp_fargs[i + j];
+                  printf("%s(%08x)", test_group.op, *frB_sp);
+               }
+               printf( " ? %x (CRx)\n", crx);
+            }
+         }
+      }
+      k++;
+      printf( "\n" );
+   }
+}
+
+
+static void test_ftsqrt(void)
+{
+   int i, crx;
+   unsigned int flags;
+   unsigned long long * frbp;
+   build_special_fargs_table();
+
+
+   for (i = 0; i < nb_special_fargs; i++) {
+      f14 = spec_fargs[i];
+      frbp = (unsigned long long *)&spec_fargs[i];
+      SET_FPSCR_ZERO;
+      SET_CR_XER_ZERO;
+      __asm__ __volatile__ ("ftsqrt           cr1, %0" : : "d" (f14));
+      GET_CR(flags);
+      crx = (flags & 0x0f000000) >> 24;
+      printf( "ftsqrt: %016llx ? %x (CRx)\n", *frbp, crx);
+   }
+   printf( "\n" );
+}
+
+static void
+test_popcntw(void)
+{
+#ifdef __powerpc64__
+   uint64_t res;
+   unsigned long long src = 0x9182736405504536ULL;
+   r14 = src;
+   __asm__ __volatile__ ("popcntw          %0, %1" : "=r" (res): "r" (r14));
+   printf("popcntw: 0x%llx => 0x%016llx\n", (unsigned long long)src, (unsigned long long)res);
+#else
+   uint32_t res;
+   unsigned int src = 0x9182730E;
+   r14 = src;
+   __asm__ __volatile__ ("popcntw          %0, %1" : "=r" (res): "r" (r14));
+   printf("popcntw: 0x%x => 0x%08x\n", src, (int)res);
+#endif
+   printf( "\n" );
+}
+
+
+static test_table_t
+         all_tests[] =
+{
+
+                    { &test_vsx_one_fp_arg,
+                      "Test VSX vector and scalar single argument instructions"} ,
+                    { &test_int_to_fp_convert,
+                      "Test VSX vector integer to float conversion instructions" },
+                    { &test_div_extensions,
+                       "Test div extensions" },
+                    { &test_ftsqrt,
+                       "Test ftsqrt instruction" },
+                    { &test_vx_tdivORtsqrt,
+                       "Test vector and scalar tdiv and tsqrt instructions" },
+                    { &test_popcntw,
+                       "Test popcntw instruction" },
+                    { NULL, NULL }
+};
+#endif // HAS_VSX
+
+int main(int argc, char *argv[])
+{
+#ifdef HAS_VSX
+
+   test_table_t aTest;
+   test_func_t func;
+   int i = 0;
+
+   while ((func = all_tests[i].test_category)) {
+      aTest = all_tests[i];
+      printf( "%s\n", aTest.name );
+      (*func)();
+      i++;
+   }
+   if (spec_fargs)
+     free(spec_fargs);
+   if (spec_sp_fargs)
+     free(spec_sp_fargs);
+
+#endif // HAS _VSX
+
+   return 0;
+}
--- valgrind/none/tests/ppc32/test_isa_2_06_part3.stdout.exp	(revision 0)
+++ valgrind/none/tests/ppc32/test_isa_2_06_part3.stdout.exp	(revision 12007)
@@ -0,0 +1,605 @@
+Test VSX vector and scalar single argument instructions
+#0: xvredp 1/x(3fd8000000000000) ==> PASS); 1/x(404f000000000000) ==> PASS)
+#1: xvredp 1/x(0018000000b77501) ==> PASS); 1/x(7fe800000000051b) ==> PASS)
+#2: xvredp 1/x(0123214569900000) ==> PASS); 1/x(0000000000000000) ==> PASS)
+#3: xvredp 1/x(8000000000000000) ==> PASS); 1/x(7ff0000000000000) ==> PASS)
+#4: xvredp 1/x(fff0000000000000) ==> PASS); 1/x(7ff7ffffffffffff) ==> PASS)
+#5: xvredp 1/x(fff7ffffffffffff) ==> PASS); 1/x(7ff8000000000000) ==> PASS)
+#6: xvredp 1/x(fff8000000000000) ==> PASS); 1/x(8008340000078000) ==> PASS)
+#7: xvredp 1/x(c0d0650f5a07b353) ==> PASS); 1/x(41232585a9900000) ==> PASS)
+#8: xvredp 1/x(41382511a2000000) ==> PASS); 1/x(40312ef5a9300000) ==> PASS)
+
+#0: xsredp 1/x(3fd8000000000000) ==> PASS)
+#1: xsredp 1/x(404f000000000000) ==> PASS)
+#2: xsredp 1/x(0018000000b77501) ==> PASS)
+#3: xsredp 1/x(7fe800000000051b) ==> PASS)
+#4: xsredp 1/x(0123214569900000) ==> PASS)
+#5: xsredp 1/x(0000000000000000) ==> PASS)
+#6: xsredp 1/x(8000000000000000) ==> PASS)
+#7: xsredp 1/x(7ff0000000000000) ==> PASS)
+#8: xsredp 1/x(fff0000000000000) ==> PASS)
+#9: xsredp 1/x(7ff7ffffffffffff) ==> PASS)
+#10: xsredp 1/x(fff7ffffffffffff) ==> PASS)
+#11: xsredp 1/x(7ff8000000000000) ==> PASS)
+#12: xsredp 1/x(fff8000000000000) ==> PASS)
+#13: xsredp 1/x(8008340000078000) ==> PASS)
+#14: xsredp 1/x(c0d0650f5a07b353) ==> PASS)
+#15: xsredp 1/x(41232585a9900000) ==> PASS)
+#16: xsredp 1/x(41382511a2000000) ==> PASS)
+#17: xsredp 1/x(40312ef5a9300000) ==> PASS)
+
+#0: xvrsqrtedp 1/x-sqrt(3fd8000000000000) ==> PASS); 1/x-sqrt(404f000000000000) ==> PASS)
+#1: xvrsqrtedp 1/x-sqrt(0018000000b77501) ==> PASS); 1/x-sqrt(7fe800000000051b) ==> PASS)
+#2: xvrsqrtedp 1/x-sqrt(0123214569900000) ==> PASS); 1/x-sqrt(0000000000000000) ==> PASS)
+#3: xvrsqrtedp 1/x-sqrt(8000000000000000) ==> PASS); 1/x-sqrt(7ff0000000000000) ==> PASS)
+#4: xvrsqrtedp 1/x-sqrt(fff0000000000000) ==> PASS); 1/x-sqrt(7ff7ffffffffffff) ==> PASS)
+#5: xvrsqrtedp 1/x-sqrt(fff7ffffffffffff) ==> PASS); 1/x-sqrt(7ff8000000000000) ==> PASS)
+#6: xvrsqrtedp 1/x-sqrt(fff8000000000000) ==> PASS); 1/x-sqrt(8008340000078000) ==> PASS)
+#7: xvrsqrtedp 1/x-sqrt(c0d0650f5a07b353) ==> PASS); 1/x-sqrt(41232585a9900000) ==> PASS)
+#8: xvrsqrtedp 1/x-sqrt(41382511a2000000) ==> PASS); 1/x-sqrt(40312ef5a9300000) ==> PASS)
+
+#0: xsrsqrtedp 1/x-sqrt(3fd8000000000000) ==> PASS)
+#1: xsrsqrtedp 1/x-sqrt(404f000000000000) ==> PASS)
+#2: xsrsqrtedp 1/x-sqrt(0018000000b77501) ==> PASS)
+#3: xsrsqrtedp 1/x-sqrt(7fe800000000051b) ==> PASS)
+#4: xsrsqrtedp 1/x-sqrt(0123214569900000) ==> PASS)
+#5: xsrsqrtedp 1/x-sqrt(0000000000000000) ==> PASS)
+#6: xsrsqrtedp 1/x-sqrt(8000000000000000) ==> PASS)
+#7: xsrsqrtedp 1/x-sqrt(7ff0000000000000) ==> PASS)
+#8: xsrsqrtedp 1/x-sqrt(fff0000000000000) ==> PASS)
+#9: xsrsqrtedp 1/x-sqrt(7ff7ffffffffffff) ==> PASS)
+#10: xsrsqrtedp 1/x-sqrt(fff7ffffffffffff) ==> PASS)
+#11: xsrsqrtedp 1/x-sqrt(7ff8000000000000) ==> PASS)
+#12: xsrsqrtedp 1/x-sqrt(fff8000000000000) ==> PASS)
+#13: xsrsqrtedp 1/x-sqrt(8008340000078000) ==> PASS)
+#14: xsrsqrtedp 1/x-sqrt(c0d0650f5a07b353) ==> PASS)
+#15: xsrsqrtedp 1/x-sqrt(41232585a9900000) ==> PASS)
+#16: xsrsqrtedp 1/x-sqrt(41382511a2000000) ==> PASS)
+#17: xsrsqrtedp 1/x-sqrt(40312ef5a9300000) ==> PASS)
+
+#0: xvrsqrtesp 1/x-sqrt(3ec00000) ==> PASS); 1/x-sqrt(42780000) ==> PASS); 1/x-sqrt(00000000) ==> PASS); 1/x-sqrt(7f800000) ==> PASS)
+#1: xvrsqrtesp 1/x-sqrt(00000000) ==> PASS); 1/x-sqrt(00000000) ==> PASS); 1/x-sqrt(80000000) ==> PASS); 1/x-sqrt(7f800000) ==> PASS)
+#2: xvrsqrtesp 1/x-sqrt(ff800000) ==> PASS); 1/x-sqrt(7fffffff) ==> PASS); 1/x-sqrt(ffffffff) ==> PASS); 1/x-sqrt(7fc00000) ==> PASS)
+#3: xvrsqrtesp 1/x-sqrt(ffc00000) ==> PASS); 1/x-sqrt(80000000) ==> PASS); 1/x-sqrt(c683287b) ==> PASS); 1/x-sqrt(49192c2d) ==> PASS)
+#4: xvrsqrtesp 1/x-sqrt(49c1288d) ==> PASS); 1/x-sqrt(418977ad) ==> PASS); 1/x-sqrt(428a5faf) ==> PASS); 1/x-sqrt(44bb5fcc) ==> PASS)
+
+#0: xvsqrtdp sqrt(3fd8000000000000) = 3fe3988e1409212e; sqrt(404f000000000000) = 401f7efbeb8d4f12
+#1: xvsqrtdp sqrt(0018000000b77501) = 2003988e14540690; sqrt(7fe800000000051b) = 5febb67ae8584f9d
+#2: xvsqrtdp sqrt(0123214569900000) = 2088bde98d60ebe6; sqrt(0000000000000000) = 0000000000000000
+#3: xvsqrtdp sqrt(8000000000000000) = 8000000000000000; sqrt(7ff0000000000000) = 7ff0000000000000
+#4: xvsqrtdp sqrt(fff0000000000000) = 7ff8000000000000; sqrt(7ff7ffffffffffff) = 7fffffffffffffff
+#5: xvsqrtdp sqrt(fff7ffffffffffff) = ffffffffffffffff; sqrt(7ff8000000000000) = 7ff8000000000000
+#6: xvsqrtdp sqrt(fff8000000000000) = fff8000000000000; sqrt(8008340000078000) = 7ff8000000000000
+#7: xvsqrtdp sqrt(c0d0650f5a07b353) = 7ff8000000000000; sqrt(41232585a9900000) = 4088c0a9258a4a8b
+#8: xvsqrtdp sqrt(41382511a2000000) = 4093a7aa60f34e85; sqrt(40312ef5a9300000) = 401094c71dec3a9c
+
+#0: xvsqrtsp sqrt(3ec00000) = 3f1cc470; sqrt(42780000) = 40fbf7dc; sqrt(00000000) = 00000000; sqrt(7f800000) = 7f800000
+#1: xvsqrtsp sqrt(00000000) = 00000000; sqrt(00000000) = 00000000; sqrt(80000000) = 80000000; sqrt(7f800000) = 7f800000
+#2: xvsqrtsp sqrt(ff800000) = 7fc00000; sqrt(7fffffff) = 7ffffffc; sqrt(ffffffff) = fffffffc; sqrt(7fc00000) = 7fc00000
+#3: xvsqrtsp sqrt(ffc00000) = ffc00000; sqrt(80000000) = 80000000; sqrt(c683287b) = 7fc00000; sqrt(49192c2d) = 44460548
+#4: xvsqrtsp sqrt(49c1288d) = 449d3d50; sqrt(418977ad) = 4084a638; sqrt(428a5faf) = 410515f8; sqrt(44bb5fcc) = 421ade08
+
+#0: xscvdpsp conv(3fd8000000000000) = 3ec0000000000000
+#1: xscvdpsp conv(404f000000000000) = 4278000000000000
+#2: xscvdpsp conv(0018000000b77501) = 0000000000000000
+#3: xscvdpsp conv(7fe800000000051b) = 7f80000000000000
+#4: xscvdpsp conv(0123214569900000) = 0000000000000000
+#5: xscvdpsp conv(0000000000000000) = 0000000000000000
+#6: xscvdpsp conv(8000000000000000) = 8000000000000000
+#7: xscvdpsp conv(7ff0000000000000) = 7f80000000000000
+#8: xscvdpsp conv(fff0000000000000) = ff80000000000000
+#9: xscvdpsp conv(7ff7ffffffffffff) = 7fffffff00000000
+#10: xscvdpsp conv(fff7ffffffffffff) = ffffffff00000000
+#11: xscvdpsp conv(7ff8000000000000) = 7fc0000000000000
+#12: xscvdpsp conv(fff8000000000000) = ffc0000000000000
+#13: xscvdpsp conv(8008340000078000) = 8000000000000000
+#14: xscvdpsp conv(c0d0650f5a07b353) = c683287b00000000
+#15: xscvdpsp conv(41232585a9900000) = 49192c2d00000000
+#16: xscvdpsp conv(41382511a2000000) = 49c1288d00000000
+#17: xscvdpsp conv(40312ef5a9300000) = 418977ad00000000
+#18: xscvdpsp conv(40514bf5d2300000) = 428a5faf00000000
+#19: xscvdpsp conv(40976bf982440000) = 44bb5fcc00000000
+
+#0: xscvdpuxws conv(3fd8000000000000) = 0000000000000000
+#1: xscvdpuxws conv(404f000000000000) = 000000000000003e
+#2: xscvdpuxws conv(0018000000b77501) = 0000000000000000
+#3: xscvdpuxws conv(7fe800000000051b) = 00000000ffffffff
+#4: xscvdpuxws conv(0123214569900000) = 0000000000000000
+#5: xscvdpuxws conv(0000000000000000) = 0000000000000000
+#6: xscvdpuxws conv(8000000000000000) = 0000000000000000
+#7: xscvdpuxws conv(7ff0000000000000) = 00000000ffffffff
+#8: xscvdpuxws conv(fff0000000000000) = 0000000000000000
+#9: xscvdpuxws conv(7ff7ffffffffffff) = 0000000000000000
+#10: xscvdpuxws conv(fff7ffffffffffff) = 0000000000000000
+#11: xscvdpuxws conv(7ff8000000000000) = 0000000000000000
+#12: xscvdpuxws conv(fff8000000000000) = 0000000000000000
+#13: xscvdpuxws conv(8008340000078000) = 0000000000000000
+#14: xscvdpuxws conv(c0d0650f5a07b353) = 0000000000000000
+#15: xscvdpuxws conv(41232585a9900000) = 00000000000992c2
+#16: xscvdpuxws conv(41382511a2000000) = 0000000000182511
+#17: xscvdpuxws conv(40312ef5a9300000) = 0000000000000011
+#18: xscvdpuxws conv(40514bf5d2300000) = 0000000000000045
+#19: xscvdpuxws conv(40976bf982440000) = 00000000000005da
+
+#0: xscvspdp conv(3ec00000) = 3fd8000000000000
+#1: xscvspdp conv(42780000) = 404f000000000000
+#2: xscvspdp conv(00000000) = 0000000000000000
+#3: xscvspdp conv(7f800000) = 7ff0000000000000
+#4: xscvspdp conv(00000000) = 0000000000000000
+#5: xscvspdp conv(00000000) = 0000000000000000
+#6: xscvspdp conv(80000000) = 8000000000000000
+#7: xscvspdp conv(7f800000) = 7ff0000000000000
+#8: xscvspdp conv(ff800000) = fff0000000000000
+#9: xscvspdp conv(7fffffff) = 7fffffffe0000000
+#10: xscvspdp conv(ffffffff) = ffffffffe0000000
+#11: xscvspdp conv(7fc00000) = 7ff8000000000000
+#12: xscvspdp conv(ffc00000) = fff8000000000000
+#13: xscvspdp conv(80000000) = 8000000000000000
+#14: xscvspdp conv(c683287b) = c0d0650f60000000
+#15: xscvspdp conv(49192c2d) = 41232585a0000000
+#16: xscvspdp conv(49c1288d) = 41382511a0000000
+#17: xscvspdp conv(418977ad) = 40312ef5a0000000
+#18: xscvspdp conv(428a5faf) = 40514bf5e0000000
+#19: xscvspdp conv(44bb5fcc) = 40976bf980000000
+
+#0: xvcvdpsp conv(3fd8000000000000) = 3ec0000000000000; conv(404f000000000000) = 4278000000000000
+#1: xvcvdpsp conv(0018000000b77501) = 0000000000000000; conv(7fe800000000051b) = 7f80000000000000
+#2: xvcvdpsp conv(0123214569900000) = 0000000000000000; conv(0000000000000000) = 0000000000000000
+#3: xvcvdpsp conv(8000000000000000) = 8000000000000000; conv(7ff0000000000000) = 7f80000000000000
+#4: xvcvdpsp conv(fff0000000000000) = ff80000000000000; conv(7ff7ffffffffffff) = 7fffffff00000000
+#5: xvcvdpsp conv(fff7ffffffffffff) = ffffffff00000000; conv(7ff8000000000000) = 7fc0000000000000
+#6: xvcvdpsp conv(fff8000000000000) = ffc0000000000000; conv(8008340000078000) = 8000000000000000
+#7: xvcvdpsp conv(c0d0650f5a07b353) = c683287b00000000; conv(41232585a9900000) = 49192c2d00000000
+#8: xvcvdpsp conv(41382511a2000000) = 49c1288d00000000; conv(40312ef5a9300000) = 418977ad00000000
+#9: xvcvdpsp conv(40514bf5d2300000) = 428a5faf00000000; conv(40976bf982440000) = 44bb5fcc00000000
+
+#0: xvcvdpuxds conv(3fd8000000000000) = 0000000000000000; conv(404f000000000000) = 000000000000003e
+#1: xvcvdpuxds conv(0018000000b77501) = 0000000000000000; conv(7fe800000000051b) = ffffffffffffffff
+#2: xvcvdpuxds conv(0123214569900000) = 0000000000000000; conv(0000000000000000) = 0000000000000000
+#3: xvcvdpuxds conv(8000000000000000) = 0000000000000000; conv(7ff0000000000000) = ffffffffffffffff
+#4: xvcvdpuxds conv(fff0000000000000) = 0000000000000000; conv(7ff7ffffffffffff) = 0000000000000000
+#5: xvcvdpuxds conv(fff7ffffffffffff) = 0000000000000000; conv(7ff8000000000000) = 0000000000000000
+#6: xvcvdpuxds conv(fff8000000000000) = 0000000000000000; conv(8008340000078000) = 0000000000000000
+#7: xvcvdpuxds conv(c0d0650f5a07b353) = 0000000000000000; conv(41232585a9900000) = 00000000000992c2
+#8: xvcvdpuxds conv(41382511a2000000) = 0000000000182511; conv(40312ef5a9300000) = 0000000000000011
+#9: xvcvdpuxds conv(40514bf5d2300000) = 0000000000000045; conv(40976bf982440000) = 00000000000005da
+
+#0: xvcvdpuxws conv(3fd8000000000000) = 0000000000000000; conv(404f000000000000) = 0000003e00000000
+#1: xvcvdpuxws conv(0018000000b77501) = 0000000000000000; conv(7fe800000000051b) = ffffffff00000000
+#2: xvcvdpuxws conv(0123214569900000) = 0000000000000000; conv(0000000000000000) = 0000000000000000
+#3: xvcvdpuxws conv(8000000000000000) = 0000000000000000; conv(7ff0000000000000) = ffffffff00000000
+#4: xvcvdpuxws conv(fff0000000000000) = 0000000000000000; conv(7ff7ffffffffffff) = 0000000000000000
+#5: xvcvdpuxws conv(fff7ffffffffffff) = 0000000000000000; conv(7ff8000000000000) = 0000000000000000
+#6: xvcvdpuxws conv(fff8000000000000) = 0000000000000000; conv(8008340000078000) = 0000000000000000
+#7: xvcvdpuxws conv(c0d0650f5a07b353) = 0000000000000000; conv(41232585a9900000) = 000992c200000000
+#8: xvcvdpuxws conv(41382511a2000000) = 0018251100000000; conv(40312ef5a9300000) = 0000001100000000
+#9: xvcvdpuxws conv(40514bf5d2300000) = 0000004500000000; conv(40976bf982440000) = 000005da00000000
+
+#0: xvcvspdp conv(3ec00000) = 3fd8000000000000; conv(42780000) = 404f000000000000
+#1: xvcvspdp conv(00000000) = 0000000000000000; conv(7f800000) = 7ff0000000000000
+#2: xvcvspdp conv(00000000) = 0000000000000000; conv(00000000) = 0000000000000000
+#3: xvcvspdp conv(80000000) = 8000000000000000; conv(7f800000) = 7ff0000000000000
+#4: xvcvspdp conv(ff800000) = fff0000000000000; conv(7fffffff) = 7fffffffe0000000
+#5: xvcvspdp conv(ffffffff) = ffffffffe0000000; conv(7fc00000) = 7ff8000000000000
+#6: xvcvspdp conv(ffc00000) = fff8000000000000; conv(80000000) = 8000000000000000
+#7: xvcvspdp conv(c683287b) = c0d0650f60000000; conv(49192c2d) = 41232585a0000000
+#8: xvcvspdp conv(49c1288d) = 41382511a0000000; conv(418977ad) = 40312ef5a0000000
+#9: xvcvspdp conv(428a5faf) = 40514bf5e0000000; conv(44bb5fcc) = 40976bf980000000
+
+#0: xvcvspsxds conv(3ec00000) = 0000000000000000; conv(42780000) = 000000000000003e
+#1: xvcvspsxds conv(00000000) = 0000000000000000; conv(7f800000) = 7fffffffffffffff
+#2: xvcvspsxds conv(00000000) = 0000000000000000; conv(00000000) = 0000000000000000
+#3: xvcvspsxds conv(80000000) = 0000000000000000; conv(7f800000) = 7fffffffffffffff
+#4: xvcvspsxds conv(ff800000) = 8000000000000000; conv(7fffffff) = 8000000000000000
+#5: xvcvspsxds conv(ffffffff) = 8000000000000000; conv(7fc00000) = 8000000000000000
+#6: xvcvspsxds conv(ffc00000) = 8000000000000000; conv(80000000) = 0000000000000000
+#7: xvcvspsxds conv(c683287b) = ffffffffffffbe6c; conv(49192c2d) = 00000000000992c2
+#8: xvcvspsxds conv(49c1288d) = 0000000000182511; conv(418977ad) = 0000000000000011
+#9: xvcvspsxds conv(428a5faf) = 0000000000000045; conv(44bb5fcc) = 00000000000005da
+
+#0: xvcvdpsxds conv(3fd8000000000000) = 0000000000000000; conv(404f000000000000) = 000000000000003e
+#1: xvcvdpsxds conv(0018000000b77501) = 0000000000000000; conv(7fe800000000051b) = 7fffffffffffffff
+#2: xvcvdpsxds conv(0123214569900000) = 0000000000000000; conv(0000000000000000) = 0000000000000000
+#3: xvcvdpsxds conv(8000000000000000) = 0000000000000000; conv(7ff0000000000000) = 7fffffffffffffff
+#4: xvcvdpsxds conv(fff0000000000000) = 8000000000000000; conv(7ff7ffffffffffff) = 8000000000000000
+#5: xvcvdpsxds conv(fff7ffffffffffff) = 8000000000000000; conv(7ff8000000000000) = 8000000000000000
+#6: xvcvdpsxds conv(fff8000000000000) = 8000000000000000; conv(8008340000078000) = 0000000000000000
+#7: xvcvdpsxds conv(c0d0650f5a07b353) = ffffffffffffbe6c; conv(41232585a9900000) = 00000000000992c2
+#8: xvcvdpsxds conv(41382511a2000000) = 0000000000182511; conv(40312ef5a9300000) = 0000000000000011
+#9: xvcvdpsxds conv(40514bf5d2300000) = 0000000000000045; conv(40976bf982440000) = 00000000000005da
+
+#0: xvcvspuxds conv(3ec00000) = 0000000000000000; conv(42780000) = 000000000000003e
+#1: xvcvspuxds conv(00000000) = 0000000000000000; conv(7f800000) = ffffffffffffffff
+#2: xvcvspuxds conv(00000000) = 0000000000000000; conv(00000000) = 0000000000000000
+#3: xvcvspuxds conv(80000000) = 0000000000000000; conv(7f800000) = ffffffffffffffff
+#4: xvcvspuxds conv(ff800000) = 0000000000000000; conv(7fffffff) = 0000000000000000
+#5: xvcvspuxds conv(ffffffff) = 0000000000000000; conv(7fc00000) = 0000000000000000
+#6: xvcvspuxds conv(ffc00000) = 0000000000000000; conv(80000000) = 0000000000000000
+#7: xvcvspuxds conv(c683287b) = 0000000000000000; conv(49192c2d) = 00000000000992c2
+#8: xvcvspuxds conv(49c1288d) = 0000000000182511; conv(418977ad) = 0000000000000011
+#9: xvcvspuxds conv(428a5faf) = 0000000000000045; conv(44bb5fcc) = 00000000000005da
+
+#0: xvcvspuxws conv(3ec00000) = 00000000; conv(42780000) = 0000003e; conv(00000000) = 00000000; conv(7f800000) = ffffffff
+#1: xvcvspuxws conv(00000000) = 00000000; conv(00000000) = 00000000; conv(80000000) = 00000000; conv(7f800000) = ffffffff
+#2: xvcvspuxws conv(ff800000) = 00000000; conv(7fffffff) = 00000000; conv(ffffffff) = 00000000; conv(7fc00000) = 00000000
+#3: xvcvspuxws conv(ffc00000) = 00000000; conv(80000000) = 00000000; conv(c683287b) = 00000000; conv(49192c2d) = 000992c2
+#4: xvcvspuxws conv(49c1288d) = 00182511; conv(418977ad) = 00000011; conv(428a5faf) = 00000045; conv(44bb5fcc) = 000005da
+
+#0: xsrdpic round(3fd8000000000000) = 0000000000000000
+#1: xsrdpic round(404f000000000000) = 404f000000000000
+#2: xsrdpic round(0018000000b77501) = 0000000000000000
+#3: xsrdpic round(7fe800000000051b) = 7fe800000000051b
+#4: xsrdpic round(0123214569900000) = 0000000000000000
+#5: xsrdpic round(0000000000000000) = 0000000000000000
+#6: xsrdpic round(8000000000000000) = 8000000000000000
+#7: xsrdpic round(7ff0000000000000) = 7ff0000000000000
+#8: xsrdpic round(fff0000000000000) = fff0000000000000
+#9: xsrdpic round(7ff7ffffffffffff) = 7fffffffffffffff
+#10: xsrdpic round(fff7ffffffffffff) = ffffffffffffffff
+#11: xsrdpic round(7ff8000000000000) = 7ff8000000000000
+#12: xsrdpic round(fff8000000000000) = fff8000000000000
+#13: xsrdpic round(8008340000078000) = 8000000000000000
+#14: xsrdpic round(c0d0650f5a07b353) = c0d0650000000000
+#15: xsrdpic round(41232585a9900000) = 4123258600000000
+#16: xsrdpic round(41382511a2000000) = 4138251200000000
+#17: xsrdpic round(40312ef5a9300000) = 4031000000000000
+#18: xsrdpic round(40514bf5d2300000) = 4051400000000000
+#19: xsrdpic round(40976bf982440000) = 40976c0000000000
+
+#0: xsrdpiz round(3fd8000000000000) = 0000000000000000
+#1: xsrdpiz round(404f000000000000) = 404f000000000000
+#2: xsrdpiz round(0018000000b77501) = 0000000000000000
+#3: xsrdpiz round(7fe800000000051b) = 7fe800000000051b
+#4: xsrdpiz round(0123214569900000) = 0000000000000000
+#5: xsrdpiz round(0000000000000000) = 0000000000000000
+#6: xsrdpiz round(8000000000000000) = 8000000000000000
+#7: xsrdpiz round(7ff0000000000000) = 7ff0000000000000
+#8: xsrdpiz round(fff0000000000000) = fff0000000000000
+#9: xsrdpiz round(7ff7ffffffffffff) = 7fffffffffffffff
+#10: xsrdpiz round(fff7ffffffffffff) = ffffffffffffffff
+#11: xsrdpiz round(7ff8000000000000) = 7ff8000000000000
+#12: xsrdpiz round(fff8000000000000) = fff8000000000000
+#13: xsrdpiz round(8008340000078000) = 8000000000000000
+#14: xsrdpiz round(c0d0650f5a07b353) = c0d0650000000000
+#15: xsrdpiz round(41232585a9900000) = 4123258400000000
+#16: xsrdpiz round(41382511a2000000) = 4138251100000000
+#17: xsrdpiz round(40312ef5a9300000) = 4031000000000000
+#18: xsrdpiz round(40514bf5d2300000) = 4051400000000000
+#19: xsrdpiz round(40976bf982440000) = 4097680000000000
+
+#0: xsrdpi round(3fd8000000000000) = 0000000000000000
+#1: xsrdpi round(404f000000000000) = 404f000000000000
+#2: xsrdpi round(0018000000b77501) = 0000000000000000
+#3: xsrdpi round(7fe800000000051b) = 7fe800000000051b
+#4: xsrdpi round(0123214569900000) = 0000000000000000
+#5: xsrdpi round(0000000000000000) = 0000000000000000
+#6: xsrdpi round(8000000000000000) = 8000000000000000
+#7: xsrdpi round(7ff0000000000000) = 7ff0000000000000
+#8: xsrdpi round(fff0000000000000) = fff0000000000000
+#9: xsrdpi round(7ff7ffffffffffff) = 7fffffffffffffff
+#10: xsrdpi round(fff7ffffffffffff) = ffffffffffffffff
+#11: xsrdpi round(7ff8000000000000) = 7ff8000000000000
+#12: xsrdpi round(fff8000000000000) = fff8000000000000
+#13: xsrdpi round(8008340000078000) = 8000000000000000
+#14: xsrdpi round(c0d0650f5a07b353) = c0d0650000000000
+#15: xsrdpi round(41232585a9900000) = 4123258600000000
+#16: xsrdpi round(41382511a2000000) = 4138251200000000
+#17: xsrdpi round(40312ef5a9300000) = 4031000000000000
+#18: xsrdpi round(40514bf5d2300000) = 4051400000000000
+#19: xsrdpi round(40976bf982440000) = 40976c0000000000
+
+#0: xvabsdp abs(3fd8000000000000) = 3fd8000000000000; abs(404f000000000000) = 404f000000000000
+#1: xvabsdp abs(0018000000b77501) = 0018000000b77501; abs(7fe800000000051b) = 7fe800000000051b
+#2: xvabsdp abs(0123214569900000) = 0123214569900000; abs(0000000000000000) = 0000000000000000
+#3: xvabsdp abs(8000000000000000) = 0000000000000000; abs(7ff0000000000000) = 7ff0000000000000
+#4: xvabsdp abs(fff0000000000000) = 7ff0000000000000; abs(7ff7ffffffffffff) = 7ff7ffffffffffff
+#5: xvabsdp abs(fff7ffffffffffff) = 7ff7ffffffffffff; abs(7ff8000000000000) = 7ff8000000000000
+#6: xvabsdp abs(fff8000000000000) = 7ff8000000000000; abs(8008340000078000) = 0008340000078000
+#7: xvabsdp abs(c0d0650f5a07b353) = 40d0650f5a07b353; abs(41232585a9900000) = 41232585a9900000
+#8: xvabsdp abs(41382511a2000000) = 41382511a2000000; abs(40312ef5a9300000) = 40312ef5a9300000
+#9: xvabsdp abs(40514bf5d2300000) = 40514bf5d2300000; abs(40976bf982440000) = 40976bf982440000
+
+#0: xvnabsdp nabs(3fd8000000000000) = bfd8000000000000; nabs(404f000000000000) = c04f000000000000
+#1: xvnabsdp nabs(0018000000b77501) = 8018000000b77501; nabs(7fe800000000051b) = ffe800000000051b
+#2: xvnabsdp nabs(0123214569900000) = 8123214569900000; nabs(0000000000000000) = 8000000000000000
+#3: xvnabsdp nabs(8000000000000000) = 8000000000000000; nabs(7ff0000000000000) = fff0000000000000
+#4: xvnabsdp nabs(fff0000000000000) = fff0000000000000; nabs(7ff7ffffffffffff) = fff7ffffffffffff
+#5: xvnabsdp nabs(fff7ffffffffffff) = fff7ffffffffffff; nabs(7ff8000000000000) = fff8000000000000
+#6: xvnabsdp nabs(fff8000000000000) = fff8000000000000; nabs(8008340000078000) = 8008340000078000
+#7: xvnabsdp nabs(c0d0650f5a07b353) = c0d0650f5a07b353; nabs(41232585a9900000) = c1232585a9900000
+#8: xvnabsdp nabs(41382511a2000000) = c1382511a2000000; nabs(40312ef5a9300000) = c0312ef5a9300000
+#9: xvnabsdp nabs(40514bf5d2300000) = c0514bf5d2300000; nabs(40976bf982440000) = c0976bf982440000
+
+#0: xvnegdp neg(3fd8000000000000) = bfd8000000000000; neg(404f000000000000) = c04f000000000000
+#1: xvnegdp neg(0018000000b77501) = 8018000000b77501; neg(7fe800000000051b) = ffe800000000051b
+#2: xvnegdp neg(0123214569900000) = 8123214569900000; neg(0000000000000000) = 8000000000000000
+#3: xvnegdp neg(8000000000000000) = 0000000000000000; neg(7ff0000000000000) = fff0000000000000
+#4: xvnegdp neg(fff0000000000000) = 7ff0000000000000; neg(7ff7ffffffffffff) = fff7ffffffffffff
+#5: xvnegdp neg(fff7ffffffffffff) = 7ff7ffffffffffff; neg(7ff8000000000000) = fff8000000000000
+#6: xvnegdp neg(fff8000000000000) = 7ff8000000000000; neg(8008340000078000) = 0008340000078000
+#7: xvnegdp neg(c0d0650f5a07b353) = 40d0650f5a07b353; neg(41232585a9900000) = c1232585a9900000
+#8: xvnegdp neg(41382511a2000000) = c1382511a2000000; neg(40312ef5a9300000) = c0312ef5a9300000
+#9: xvnegdp neg(40514bf5d2300000) = c0514bf5d2300000; neg(40976bf982440000) = c0976bf982440000
+
+#0: xvabssp abs(3ec00000) = 3ec00000; abs(42780000) = 42780000; abs(00000000) = 00000000; abs(7f800000) = 7f800000
+#1: xvabssp abs(00000000) = 00000000; abs(00000000) = 00000000; abs(80000000) = 00000000; abs(7f800000) = 7f800000
+#2: xvabssp abs(ff800000) = 7f800000; abs(7fffffff) = 7fffffff; abs(ffffffff) = 7fffffff; abs(7fc00000) = 7fc00000
+#3: xvabssp abs(ffc00000) = 7fc00000; abs(80000000) = 00000000; abs(c683287b) = 4683287b; abs(49192c2d) = 49192c2d
+#4: xvabssp abs(49c1288d) = 49c1288d; abs(418977ad) = 418977ad; abs(428a5faf) = 428a5faf; abs(44bb5fcc) = 44bb5fcc
+
+#0: xvnabssp nabs(3ec00000) = bec00000; nabs(42780000) = c2780000; nabs(00000000) = 80000000; nabs(7f800000) = ff800000
+#1: xvnabssp nabs(00000000) = 80000000; nabs(00000000) = 80000000; nabs(80000000) = 80000000; nabs(7f800000) = ff800000
+#2: xvnabssp nabs(ff800000) = ff800000; nabs(7fffffff) = ffffffff; nabs(ffffffff) = ffffffff; nabs(7fc00000) = ffc00000
+#3: xvnabssp nabs(ffc00000) = ffc00000; nabs(80000000) = 80000000; nabs(c683287b) = c683287b; nabs(49192c2d) = c9192c2d
+#4: xvnabssp nabs(49c1288d) = c9c1288d; nabs(418977ad) = c18977ad; nabs(428a5faf) = c28a5faf; nabs(44bb5fcc) = c4bb5fcc
+
+#0: xvrdpi round(3fd8000000000000) = 0000000000000000; round(404f000000000000) = 404f000000000000
+#1: xvrdpi round(0018000000b77501) = 0000000000000000; round(7fe800000000051b) = 7fe800000000051b
+#2: xvrdpi round(0123214569900000) = 0000000000000000; round(0000000000000000) = 0000000000000000
+#3: xvrdpi round(8000000000000000) = 8000000000000000; round(7ff0000000000000) = 7ff0000000000000
+#4: xvrdpi round(fff0000000000000) = fff0000000000000; round(7ff7ffffffffffff) = 7fffffffffffffff
+#5: xvrdpi round(fff7ffffffffffff) = ffffffffffffffff; round(7ff8000000000000) = 7ff8000000000000
+#6: xvrdpi round(fff8000000000000) = fff8000000000000; round(8008340000078000) = 8000000000000000
+#7: xvrdpi round(c0d0650f5a07b353) = c0d0650000000000; round(41232585a9900000) = 4123258600000000
+#8: xvrdpi round(41382511a2000000) = 4138251200000000; round(40312ef5a9300000) = 4031000000000000
+#9: xvrdpi round(40514bf5d2300000) = 4051400000000000; round(40976bf982440000) = 40976c0000000000
+
+#0: xvrdpic round(3fd8000000000000) = 0000000000000000; round(404f000000000000) = 404f000000000000
+#1: xvrdpic round(0018000000b77501) = 0000000000000000; round(7fe800000000051b) = 7fe800000000051b
+#2: xvrdpic round(0123214569900000) = 0000000000000000; round(0000000000000000) = 0000000000000000
+#3: xvrdpic round(8000000000000000) = 8000000000000000; round(7ff0000000000000) = 7ff0000000000000
+#4: xvrdpic round(fff0000000000000) = fff0000000000000; round(7ff7ffffffffffff) = 7fffffffffffffff
+#5: xvrdpic round(fff7ffffffffffff) = ffffffffffffffff; round(7ff8000000000000) = 7ff8000000000000
+#6: xvrdpic round(fff8000000000000) = fff8000000000000; round(8008340000078000) = 8000000000000000
+#7: xvrdpic round(c0d0650f5a07b353) = c0d0650000000000; round(41232585a9900000) = 4123258600000000
+#8: xvrdpic round(41382511a2000000) = 4138251200000000; round(40312ef5a9300000) = 4031000000000000
+#9: xvrdpic round(40514bf5d2300000) = 4051400000000000; round(40976bf982440000) = 40976c0000000000
+
+#0: xvrdpim round(3fd8000000000000) = 0000000000000000; round(404f000000000000) = 404f000000000000
+#1: xvrdpim round(0018000000b77501) = 0000000000000000; round(7fe800000000051b) = 7fe800000000051b
+#2: xvrdpim round(0123214569900000) = 0000000000000000; round(0000000000000000) = 0000000000000000
+#3: xvrdpim round(8000000000000000) = 8000000000000000; round(7ff0000000000000) = 7ff0000000000000
+#4: xvrdpim round(fff0000000000000) = fff0000000000000; round(7ff7ffffffffffff) = 7fffffffffffffff
+#5: xvrdpim round(fff7ffffffffffff) = ffffffffffffffff; round(7ff8000000000000) = 7ff8000000000000
+#6: xvrdpim round(fff8000000000000) = fff8000000000000; round(8008340000078000) = bff0000000000000
+#7: xvrdpim round(c0d0650f5a07b353) = c0d0654000000000; round(41232585a9900000) = 4123258400000000
+#8: xvrdpim round(41382511a2000000) = 4138251100000000; round(40312ef5a9300000) = 4031000000000000
+#9: xvrdpim round(40514bf5d2300000) = 4051400000000000; round(40976bf982440000) = 4097680000000000
+
+#0: xvrdpip round(3fd8000000000000) = 3ff0000000000000; round(404f000000000000) = 404f000000000000
+#1: xvrdpip round(0018000000b77501) = 3ff0000000000000; round(7fe800000000051b) = 7fe800000000051b
+#2: xvrdpip round(0123214569900000) = 3ff0000000000000; round(0000000000000000) = 0000000000000000
+#3: xvrdpip round(8000000000000000) = 8000000000000000; round(7ff0000000000000) = 7ff0000000000000
+#4: xvrdpip round(fff0000000000000) = fff0000000000000; round(7ff7ffffffffffff) = 7fffffffffffffff
+#5: xvrdpip round(fff7ffffffffffff) = ffffffffffffffff; round(7ff8000000000000) = 7ff8000000000000
+#6: xvrdpip round(fff8000000000000) = fff8000000000000; round(8008340000078000) = 8000000000000000
+#7: xvrdpip round(c0d0650f5a07b353) = c0d0650000000000; round(41232585a9900000) = 4123258600000000
+#8: xvrdpip round(41382511a2000000) = 4138251200000000; round(40312ef5a9300000) = 4032000000000000
+#9: xvrdpip round(40514bf5d2300000) = 4051800000000000; round(40976bf982440000) = 40976c0000000000
+
+#0: xvrdpiz round(3fd8000000000000) = 0000000000000000; round(404f000000000000) = 404f000000000000
+#1: xvrdpiz round(0018000000b77501) = 0000000000000000; round(7fe800000000051b) = 7fe800000000051b
+#2: xvrdpiz round(0123214569900000) = 0000000000000000; round(0000000000000000) = 0000000000000000
+#3: xvrdpiz round(8000000000000000) = 8000000000000000; round(7ff0000000000000) = 7ff0000000000000
+#4: xvrdpiz round(fff0000000000000) = fff0000000000000; round(7ff7ffffffffffff) = 7fffffffffffffff
+#5: xvrdpiz round(fff7ffffffffffff) = ffffffffffffffff; round(7ff8000000000000) = 7ff8000000000000
+#6: xvrdpiz round(fff8000000000000) = fff8000000000000; round(8008340000078000) = 8000000000000000
+#7: xvrdpiz round(c0d0650f5a07b353) = c0d0650000000000; round(41232585a9900000) = 4123258400000000
+#8: xvrdpiz round(41382511a2000000) = 4138251100000000; round(40312ef5a9300000) = 4031000000000000
+#9: xvrdpiz round(40514bf5d2300000) = 4051400000000000; round(40976bf982440000) = 4097680000000000
+
+#0: xvrspi round(3ec00000) = 00000000; round(42780000) = 42780000; round(00000000) = 00000000; round(7f800000) = 7f800000
+#1: xvrspi round(00000000) = 00000000; round(00000000) = 00000000; round(80000000) = 80000000; round(7f800000) = 7f800000
+#2: xvrspi round(ff800000) = ff800000; round(7fffffff) = 7fffffff; round(ffffffff) = ffffffff; round(7fc00000) = 7fc00000
+#3: xvrspi round(ffc00000) = ffc00000; round(80000000) = 80000000; round(c683287b) = c6832800; round(49192c2d) = 49192c30
+#4: xvrspi round(49c1288d) = 49c12890; round(418977ad) = 41880000; round(428a5faf) = 428a0000; round(44bb5fcc) = 44bb6000
+
+#0: xvrspic round(3ec00000) = 00000000; round(42780000) = 42780000; round(00000000) = 00000000; round(7f800000) = 7f800000
+#1: xvrspic round(00000000) = 00000000; round(00000000) = 00000000; round(80000000) = 80000000; round(7f800000) = 7f800000
+#2: xvrspic round(ff800000) = ff800000; round(7fffffff) = 7fffffff; round(ffffffff) = ffffffff; round(7fc00000) = 7fc00000
+#3: xvrspic round(ffc00000) = ffc00000; round(80000000) = 80000000; round(c683287b) = c6832800; round(49192c2d) = 49192c30
+#4: xvrspic round(49c1288d) = 49c12890; round(418977ad) = 41880000; round(428a5faf) = 428a0000; round(44bb5fcc) = 44bb6000
+
+#0: xvrspim round(3ec00000) = 00000000; round(42780000) = 42780000; round(00000000) = 00000000; round(7f800000) = 7f800000
+#1: xvrspim round(00000000) = 00000000; round(00000000) = 00000000; round(80000000) = 80000000; round(7f800000) = 7f800000
+#2: xvrspim round(ff800000) = ff800000; round(7fffffff) = 7fffffff; round(ffffffff) = ffffffff; round(7fc00000) = 7fc00000
+#3: xvrspim round(ffc00000) = ffc00000; round(80000000) = 80000000; round(c683287b) = c6832a00; round(49192c2d) = 49192c20
+#4: xvrspim round(49c1288d) = 49c12888; round(418977ad) = 41880000; round(428a5faf) = 428a0000; round(44bb5fcc) = 44bb4000
+
+#0: xvrspip round(3ec00000) = 3f800000; round(42780000) = 42780000; round(00000000) = 00000000; round(7f800000) = 7f800000
+#1: xvrspip round(00000000) = 00000000; round(00000000) = 00000000; round(80000000) = 80000000; round(7f800000) = 7f800000
+#2: xvrspip round(ff800000) = ff800000; round(7fffffff) = 7fffffff; round(ffffffff) = ffffffff; round(7fc00000) = 7fc00000
+#3: xvrspip round(ffc00000) = ffc00000; round(80000000) = 80000000; round(c683287b) = c6832800; round(49192c2d) = 49192c30
+#4: xvrspip round(49c1288d) = 49c12890; round(418977ad) = 41900000; round(428a5faf) = 428c0000; round(44bb5fcc) = 44bb6000
+
+#0: xvrspiz round(3ec00000) = 00000000; round(42780000) = 42780000; round(00000000) = 00000000; round(7f800000) = 7f800000
+#1: xvrspiz round(00000000) = 00000000; round(00000000) = 00000000; round(80000000) = 80000000; round(7f800000) = 7f800000
+#2: xvrspiz round(ff800000) = ff800000; round(7fffffff) = 7fffffff; round(ffffffff) = ffffffff; round(7fc00000) = 7fc00000
+#3: xvrspiz round(ffc00000) = ffc00000; round(80000000) = 80000000; round(c683287b) = c6832800; round(49192c2d) = 49192c20
+#4: xvrspiz round(49c1288d) = 49c12888; round(418977ad) = 41880000; round(428a5faf) = 428a0000; round(44bb5fcc) = 44bb4000
+
+Test VSX vector integer to float conversion instructions
+#0: xvcvsxddp conv(0000000000000000) = 0000000000000000; conv(ffffffff00000000) = c1f0000000000000
+#1: xvcvsxddp conv(00000000ffffffff) = 41efffffffe00000; conv(ffffffffffffffff) = bff0000000000000
+#2: xvcvsxddp conv(89abcde123456789) = c3dd950c87b72ea6; conv(0102030405060708) = 4370203040506070
+#3: xvcvsxddp conv(00000000a0b1c2d3) = 41e416385a600000; conv(1111222233334444) = 43b1112222333344
+
+#0: xvcvuxddp conv(0000000000000000) = 0000000000000000; conv(ffffffff00000000) = 43efffffffe00000
+#1: xvcvuxddp conv(00000000ffffffff) = 41efffffffe00000; conv(ffffffffffffffff) = 43f0000000000000
+#2: xvcvuxddp conv(89abcde123456789) = 43e13579bc2468ad; conv(0102030405060708) = 4370203040506070
+#3: xvcvuxddp conv(00000000a0b1c2d3) = 41e416385a600000; conv(1111222233334444) = 43b1112222333344
+
+#0: xvcvsxdsp conv(0000000000000000) = 0000000000000000; conv(ffffffff00000000) = cf80000000000000
+#1: xvcvsxdsp conv(00000000ffffffff) = 4f80000000000000; conv(ffffffffffffffff) = bf80000000000000
+#2: xvcvsxdsp conv(89abcde123456789) = deeca86400000000; conv(0102030405060708) = 5b81018200000000
+#3: xvcvsxdsp conv(00000000a0b1c2d3) = 4f20b1c300000000; conv(1111222233334444) = 5d88891100000000
+
+#0: xvcvuxdsp conv(0000000000000000) = 0000000000000000; conv(ffffffff00000000) = 5f80000000000000
+#1: xvcvuxdsp conv(00000000ffffffff) = 4f80000000000000; conv(ffffffffffffffff) = 5f80000000000000
+#2: xvcvuxdsp conv(89abcde123456789) = 5f09abce00000000; conv(0102030405060708) = 5b81018200000000
+#3: xvcvuxdsp conv(00000000a0b1c2d3) = 4f20b1c300000000; conv(1111222233334444) = 5d88891100000000
+
+#0: xvcvsxwdp conv(00000000) = 0000000000000000; conv(ffff0000) = c0f0000000000000
+#1: xvcvsxwdp conv(0000ffff) = 40efffe000000000; conv(ffffffff) = bff0000000000000
+#2: xvcvsxwdp conv(89a73522) = c1dd9632b7800000; conv(01020304) = 4170203040000000
+#3: xvcvsxwdp conv(0000abcd) = 40e579a000000000; conv(11223344) = 41b1223344000000
+
+#0: xvcvuxwdp conv(00000000) = 0000000000000000; conv(ffff0000) = 41efffe000000000
+#1: xvcvuxwdp conv(0000ffff) = 40efffe000000000; conv(ffffffff) = 41efffffffe00000
+#2: xvcvuxwdp conv(89a73522) = 41e134e6a4400000; conv(01020304) = 4170203040000000
+#3: xvcvuxwdp conv(0000abcd) = 40e579a000000000; conv(11223344) = 41b1223344000000
+
+#0: xvcvsxwsp conv(00000000) = 00000000; conv(ffff0000) = c7800000; conv(0000ffff) = 477fff00; conv(ffffffff) = bf800000
+#1: xvcvsxwsp conv(89a73522) = ceecb196; conv(01020304) = 4b810182; conv(0000abcd) = 472bcd00; conv(11223344) = 4d89119a
+
+#0: xvcvuxwsp conv(00000000) = 00000000; conv(ffff0000) = 4f7fff00; conv(0000ffff) = 477fff00; conv(ffffffff) = 4f800000
+#1: xvcvuxwsp conv(89a73522) = 4f09a735; conv(01020304) = 4b810182; conv(0000abcd) = 472bcd00; conv(11223344) = 4d89119a
+
+Test div extensions
+#0: divwe: 0x0000000000000000 / 0x00000002 = 0x00000000; CR=0; XER=0
+#1: divwe: 0x0000000200000000 / 0x00000000 = 0x00000000; CR=0; XER=0
+#2: divwe: 0x7abc123400000000 / 0xf0000000 = 0x00000000; CR=0; XER=0
+#3: divwe: 0xfabc123400000000 / 0x00000005 = 0x00000000; CR=0; XER=0
+#4: divwe: 0x0000004d00000000 / 0x00000042 = 0x00000000; CR=0; XER=0
+#5: divwe: 0x0000000500000000 / 0xfabc1234 = 0xffffff0d; CR=0; XER=0
+
+#0: divwe.: 0x0000000000000000 / 0x00000002 = 0x00000000; CR=2; XER=0
+#1: divwe.: 0x0000000200000000 / 0x00000000 = 0x00000000; CR=2; XER=0
+#2: divwe.: 0x7abc123400000000 / 0xf0000000 = 0x00000000; CR=2; XER=0
+#3: divwe.: 0xfabc123400000000 / 0x00000005 = 0x00000000; CR=2; XER=0
+#4: divwe.: 0x0000004d00000000 / 0x00000042 = 0x00000000; CR=2; XER=0
+#5: divwe.: 0x0000000500000000 / 0xfabc1234 = 0xffffff0d; CR=8; XER=0
+
+
+#0: divweo: 0x0000000000000000 / 0x00000002 = 0x00000000; CR=0; XER=0
+#1: divweo: 0x0000000200000000 / 0x00000000 = 0x00000000; CR=0; XER=c0000000
+#2: divweo: 0x7abc123400000000 / 0xf0000000 = 0x00000000; CR=0; XER=c0000000
+#3: divweo: 0xfabc123400000000 / 0x00000005 = 0x00000000; CR=0; XER=c0000000
+#4: divweo: 0x0000004d00000000 / 0x00000042 = 0x00000000; CR=0; XER=c0000000
+#5: divweo: 0x0000000500000000 / 0xfabc1234 = 0xffffff0d; CR=0; XER=0
+
+#0: divweo.: 0x0000000000000000 / 0x00000002 = 0x00000000; CR=2; XER=0
+#1: divweo.: 0x0000000200000000 / 0x00000000 = 0x00000000; CR=3; XER=c0000000
+#2: divweo.: 0x7abc123400000000 / 0xf0000000 = 0x00000000; CR=3; XER=c0000000
+#3: divweo.: 0xfabc123400000000 / 0x00000005 = 0x00000000; CR=3; XER=c0000000
+#4: divweo.: 0x0000004d00000000 / 0x00000042 = 0x00000000; CR=3; XER=c0000000
+#5: divweo.: 0x0000000500000000 / 0xfabc1234 = 0xffffff0d; CR=8; XER=0
+
+
+Test ftsqrt instruction
+ftsqrt: 3fd8000000000000 ? 8 (CRx)
+ftsqrt: 404f000000000000 ? 8 (CRx)
+ftsqrt: 0018000000b77501 ? a (CRx)
+ftsqrt: 7fe800000000051b ? 8 (CRx)
+ftsqrt: 0123214569900000 ? a (CRx)
+ftsqrt: 0000000000000000 ? e (CRx)
+ftsqrt: 8000000000000000 ? e (CRx)
+ftsqrt: 7ff0000000000000 ? e (CRx)
+ftsqrt: fff0000000000000 ? e (CRx)
+ftsqrt: 7ff7ffffffffffff ? a (CRx)
+ftsqrt: fff7ffffffffffff ? a (CRx)
+ftsqrt: 7ff8000000000000 ? a (CRx)
+ftsqrt: fff8000000000000 ? a (CRx)
+ftsqrt: 8008340000078000 ? e (CRx)
+ftsqrt: c0d0650f5a07b353 ? a (CRx)
+ftsqrt: 41232585a9900000 ? 8 (CRx)
+ftsqrt: 41382511a2000000 ? 8 (CRx)
+ftsqrt: 40312ef5a9300000 ? 8 (CRx)
+ftsqrt: 40514bf5d2300000 ? 8 (CRx)
+ftsqrt: 40976bf982440000 ? 8 (CRx)
+
+Test vector and scalar tdiv and tsqrt instructions
+#0: xstsqrtdp test-sqrt(3fd8000000000000) ? 8 (CRx)
+#1: xstsqrtdp test-sqrt(404f000000000000) ? 8 (CRx)
+#2: xstsqrtdp test-sqrt(0018000000b77501) ? a (CRx)
+#3: xstsqrtdp test-sqrt(7fe800000000051b) ? 8 (CRx)
+#4: xstsqrtdp test-sqrt(0123214569900000) ? a (CRx)
+#5: xstsqrtdp test-sqrt(0000000000000000) ? e (CRx)
+#6: xstsqrtdp test-sqrt(8000000000000000) ? e (CRx)
+#7: xstsqrtdp test-sqrt(7ff0000000000000) ? e (CRx)
+#8: xstsqrtdp test-sqrt(fff0000000000000) ? e (CRx)
+#9: xstsqrtdp test-sqrt(7ff7ffffffffffff) ? a (CRx)
+#10: xstsqrtdp test-sqrt(fff7ffffffffffff) ? a (CRx)
+#11: xstsqrtdp test-sqrt(7ff8000000000000) ? a (CRx)
+#12: xstsqrtdp test-sqrt(fff8000000000000) ? a (CRx)
+#13: xstsqrtdp test-sqrt(8008340000078000) ? e (CRx)
+#14: xstsqrtdp test-sqrt(c0d0650f5a07b353) ? a (CRx)
+#15: xstsqrtdp test-sqrt(41232585a9900000) ? 8 (CRx)
+#16: xstsqrtdp test-sqrt(41382511a2000000) ? 8 (CRx)
+#17: xstsqrtdp test-sqrt(40312ef5a9300000) ? 8 (CRx)
+#18: xstsqrtdp test-sqrt(40514bf5d2300000) ? 8 (CRx)
+#19: xstsqrtdp test-sqrt(40976bf982440000) ? 8 (CRx)
+
+#0: xvtsqrtdp test-sqrt(3fd8000000000000); test-sqrt(404f000000000000) ? 8 (CRx)
+#1: xvtsqrtdp test-sqrt(0018000000b77501); test-sqrt(7fe800000000051b) ? a (CRx)
+#2: xvtsqrtdp test-sqrt(0123214569900000); test-sqrt(0000000000000000) ? e (CRx)
+#3: xvtsqrtdp test-sqrt(8000000000000000); test-sqrt(7ff0000000000000) ? e (CRx)
+#4: xvtsqrtdp test-sqrt(fff0000000000000); test-sqrt(7ff7ffffffffffff) ? e (CRx)
+#5: xvtsqrtdp test-sqrt(fff7ffffffffffff); test-sqrt(7ff8000000000000) ? a (CRx)
+#6: xvtsqrtdp test-sqrt(fff8000000000000); test-sqrt(8008340000078000) ? e (CRx)
+#7: xvtsqrtdp test-sqrt(c0d0650f5a07b353); test-sqrt(41232585a9900000) ? a (CRx)
+#8: xvtsqrtdp test-sqrt(41382511a2000000); test-sqrt(40312ef5a9300000) ? 8 (CRx)
+#9: xvtsqrtdp test-sqrt(40514bf5d2300000); test-sqrt(40976bf982440000) ? 8 (CRx)
+
+#0: xvtsqrtsp test-sqrt(3ec00000); test-sqrt(42780000); test-sqrt(00000000); test-sqrt(7f800000) ? e (CRx)
+#1: xvtsqrtsp test-sqrt(00000000); test-sqrt(00000000); test-sqrt(80000000); test-sqrt(7f800000) ? e (CRx)
+#2: xvtsqrtsp test-sqrt(ff800000); test-sqrt(7fffffff); test-sqrt(ffffffff); test-sqrt(7fc00000) ? e (CRx)
+#3: xvtsqrtsp test-sqrt(ffc00000); test-sqrt(80000000); test-sqrt(c683287b); test-sqrt(49192c2d) ? e (CRx)
+#4: xvtsqrtsp test-sqrt(49c1288d); test-sqrt(418977ad); test-sqrt(428a5faf); test-sqrt(44bb5fcc) ? 8 (CRx)
+
+#0: xvtdivdp fff0000000000000 test-div fff0000000000000 AND fff0000000000000 test-div c0d0650f5a07b353 ? cc=e
+#1: xvtdivdp 41232585a9900000 test-div 41382511a2000000 AND fff0000000000000 test-div 0000000000000000 ? cc=e
+#2: xvtdivdp fff0000000000000 test-div 0123214569900000 AND fff0000000000000 test-div 7ff0000000000000 ? cc=e
+#3: xvtdivdp fff0000000000000 test-div 7ff7ffffffffffff AND fff0000000000000 test-div 7ff8000000000000 ? cc=e
+#4: xvtdivdp c0d0650f5a07b353 test-div fff0000000000000 AND c0d0650f5a07b353 test-div c0d0650f5a07b353 ? cc=e
+#5: xvtdivdp c0d0650f5a07b353 test-div 8000000000000000 AND c0d0650f5a07b353 test-div 0000000000000000 ? cc=e
+#6: xvtdivdp c0d0650f5a07b353 test-div 0123214569900000 AND c0d0650f5a07b353 test-div 7ff0000000000000 ? cc=e
+#7: xvtdivdp c0d0650f5a07b353 test-div 7ff7ffffffffffff AND c0d0650f5a07b353 test-div 7ff8000000000000 ? cc=a
+#8: xvtdivdp 8000000000000000 test-div fff0000000000000 AND 8000000000000000 test-div c0d0650f5a07b353 ? cc=e
+#9: xvtdivdp 8000000000000000 test-div 8000000000000000 AND 8000000000000000 test-div 0000000000000000 ? cc=e
+#10: xvtdivdp 8000000000000000 test-div 0123214569900000 AND 8000000000000000 test-div 7ff0000000000000 ? cc=e
+#11: xvtdivdp 8000000000000000 test-div 7ff7ffffffffffff AND 8000000000000000 test-div 7ff8000000000000 ? cc=a
+#12: xvtdivdp 0000000000000000 test-div fff0000000000000 AND 0000000000000000 test-div c0d0650f5a07b353 ? cc=e
+#13: xvtdivdp 0000000000000000 test-div 8000000000000000 AND 0000000000000000 test-div 0000000000000000 ? cc=e
+#14: xvtdivdp 0000000000000000 test-div 0123214569900000 AND 0000000000000000 test-div 7ff0000000000000 ? cc=e
+#15: xvtdivdp 0000000000000000 test-div 7ff7ffffffffffff AND 0000000000000000 test-div 7ff8000000000000 ? cc=a
+#16: xvtdivdp 0123214569900000 test-div fff0000000000000 AND 0123214569900000 test-div c0d0650f5a07b353 ? cc=e
+#17: xvtdivdp 0123214569900000 test-div 8000000000000000 AND 0123214569900000 test-div 0000000000000000 ? cc=e
+#18: xvtdivdp 0123214569900000 test-div 404f000000000000 AND 0123214569900000 test-div 7ff0000000000000 ? cc=e
+#19: xvtdivdp 0123214569900000 test-div 7ff7ffffffffffff AND 0123214569900000 test-div 7ff8000000000000 ? cc=a
+#20: xvtdivdp 7ff0000000000000 test-div fff0000000000000 AND 7ff0000000000000 test-div c0d0650f5a07b353 ? cc=e
+#21: xvtdivdp 7ff0000000000000 test-div 8000000000000000 AND 7ff0000000000000 test-div 0000000000000000 ? cc=e
+#22: xvtdivdp 7ff0000000000000 test-div 0123214569900000 AND 7ff0000000000000 test-div 7ff0000000000000 ? cc=e
+#23: xvtdivdp 7ff0000000000000 test-div 7ff7ffffffffffff AND 7ff0000000000000 test-div 7ff8000000000000 ? cc=e
+#24: xvtdivdp fff7ffffffffffff test-div fff0000000000000 AND fff7ffffffffffff test-div c0d0650f5a07b353 ? cc=e
+#25: xvtdivdp fff8000000000000 test-div 8000000000000000 AND fff8000000000000 test-div 0000000000000000 ? cc=e
+#26: xvtdivdp fff7ffffffffffff test-div 0123214569900000 AND fff7ffffffffffff test-div 7ff0000000000000 ? cc=e
+#27: xvtdivdp fff7ffffffffffff test-div 7ff7ffffffffffff AND fff7ffffffffffff test-div 7ff8000000000000 ? cc=a
+#28: xvtdivdp fff8000000000000 test-div fff0000000000000 AND fff8000000000000 test-div c0d0650f5a07b353 ? cc=e
+#29: xvtdivdp fff8000000000000 test-div 8000000000000000 AND 41232585a9900000 test-div 41382511a2000000 ? cc=e
+#30: xvtdivdp 41232585a9900000 test-div 41382511a2000000 AND 7ff7ffffffffffff test-div 7ff8000000000000 ? cc=a
+#31: xvtdivdp 7ff8000000000000 test-div 7ff8000000000000 AND 7ff8000000000000 test-div fff8000000000000 ? cc=a
+#32: xvtdivdp 41382511a2000000 test-div 40514bf5d2300000 AND 40312ef5a9300000 test-div 41382511a2000000 ? cc=8
+#33: xvtdivdp 40976bf982440000 test-div 40976bf982440000 AND 40976bf982440000 test-div 40514bf5d2300000 ? cc=8
+
+#0: xvtdivsp ff800000 test-div ff800000 AND ff800000 test-div c683287b AND 49192c2d test-div 49c1288d AND ff800000 test-div 00000000 ? cc=e
+#1: xvtdivsp ff800000 test-div 00000000 AND ff800000 test-div 7f800000 AND ff800000 test-div 7fffffff AND ff800000 test-div 7fc00000 ? cc=e
+#2: xvtdivsp c683287b test-div ff800000 AND c683287b test-div c683287b AND c683287b test-div 80000000 AND c683287b test-div 00000000 ? cc=e
+#3: xvtdivsp c683287b test-div 00000000 AND c683287b test-div 7f800000 AND c683287b test-div 7fffffff AND c683287b test-div 7fc00000 ? cc=e
+#4: xvtdivsp 80000000 test-div ff800000 AND 80000000 test-div c683287b AND 80000000 test-div 80000000 AND 80000000 test-div 00000000 ? cc=e
+#5: xvtdivsp 80000000 test-div 00000000 AND 80000000 test-div 7f800000 AND 80000000 test-div 7fffffff AND 80000000 test-div 7fc00000 ? cc=e
+#6: xvtdivsp 00000000 test-div ff800000 AND 00000000 test-div c683287b AND 00000000 test-div 80000000 AND 00000000 test-div 00000000 ? cc=e
+#7: xvtdivsp 00000000 test-div 00000000 AND 00000000 test-div 7f800000 AND 00000000 test-div 7fffffff AND 00000000 test-div 7fc00000 ? cc=e
+#8: xvtdivsp 00000000 test-div ff800000 AND 00000000 test-div c683287b AND 00000000 test-div 80000000 AND 00000000 test-div 00000000 ? cc=e
+#9: xvtdivsp 00000000 test-div 42780000 AND 00000000 test-div 7f800000 AND 00000000 test-div 7fffffff AND 00000000 test-div 7fc00000 ? cc=e
+#10: xvtdivsp 7f800000 test-div ff800000 AND 7f800000 test-div c683287b AND 7f800000 test-div 80000000 AND 7f800000 test-div 00000000 ? cc=e
+#11: xvtdivsp 7f800000 test-div 00000000 AND 7f800000 test-div 7f800000 AND 7f800000 test-div 7fffffff AND 7f800000 test-div 7fc00000 ? cc=e
+#12: xvtdivsp ffffffff test-div ff800000 AND ffffffff test-div c683287b AND ffc00000 test-div 80000000 AND ffc00000 test-div 00000000 ? cc=e
+#13: xvtdivsp ffffffff test-div 00000000 AND ffffffff test-div 7f800000 AND ffffffff test-div 7fffffff AND ffffffff test-div 7fc00000 ? cc=e
+#14: xvtdivsp ffc00000 test-div ff800000 AND ffc00000 test-div c683287b AND ffc00000 test-div 80000000 AND 49192c2d test-div 49c1288d ? cc=e
+#15: xvtdivsp 49192c2d test-div 49c1288d AND 7fffffff test-div 7fc00000 AND 7fc00000 test-div 7fc00000 AND 7fc00000 test-div ffc00000 ? cc=a
+#16: xvtdivsp 49c1288d test-div 428a5faf AND 418977ad test-div 49c1288d AND 44bb5fcc test-div 44bb5fcc AND 44bb5fcc test-div 428a5faf ? cc=8
+
+Test popcntw instruction
+popcntw: 0x9182730e => 0x0000000d
+
--- valgrind/none/tests/ppc32/test_isa_2_06_part3.stderr.exp	(revision 0)
+++ valgrind/none/tests/ppc32/test_isa_2_06_part3.stderr.exp	(revision 12007)
@@ -0,0 +1,2 @@
+
+
--- valgrind/none/tests/ppc32/test_isa_2_06_part3.vgtest	(revision 0)
+++ valgrind/none/tests/ppc32/test_isa_2_06_part3.vgtest	(revision 12007)
@@ -0,0 +1,2 @@
+prereq: ../../../tests/check_isa-2_06_cap
+prog: test_isa_2_06_part3
--- valgrind/none/tests/ppc32/Makefile.am	(revision 12005)
+++ valgrind/none/tests/ppc32/Makefile.am	(revision 12007)
@@ -28,7 +28,8 @@ EXTRA_DIST = \
 	power5+_round.stderr.exp power5+_round.stdout.exp power5+_round.vgtest \
 	power6_bcmp.stderr.exp power6_bcmp.stdout.exp power6_bcmp.vgtest \
 	test_isa_2_06_part1.stderr.exp  test_isa_2_06_part1.stdout.exp  test_isa_2_06_part1.vgtest \
-	test_isa_2_06_part2.stderr.exp  test_isa_2_06_part2.stdout.exp  test_isa_2_06_part2.vgtest
+	test_isa_2_06_part2.stderr.exp  test_isa_2_06_part2.stdout.exp  test_isa_2_06_part2.vgtest \
+	test_isa_2_06_part3.stderr.exp  test_isa_2_06_part3.stdout.exp  test_isa_2_06_part3.vgtest
 
 check_PROGRAMS = \
 	bug129390-ppc32 \
@@ -36,7 +37,8 @@ check_PROGRAMS = \
 	ldstrev lsw jm-insns mftocrf mcrfs round test_fx test_gx \
 	testVMX twi tw xlc_dbl_u32 power5+_round power6_bcmp \
 	test_isa_2_06_part1 \
-	test_isa_2_06_part2
+	test_isa_2_06_part2 \
+	test_isa_2_06_part3
 
 AM_CFLAGS    += @FLAG_M32@
 AM_CXXFLAGS  += @FLAG_M32@
@@ -68,3 +70,6 @@ test_isa_2_06_part1_CFLAGS = $(AM_CFLAGS
 test_isa_2_06_part2_CFLAGS = $(AM_CFLAGS) -Winline -Wall -O -g -mregnames $(VSX_FLAG) \
 			@FLAG_M32@ $(ALTIVEC_FLAG) $(BUILD_FLAG_VSX)
 
+test_isa_2_06_part3_CFLAGS = $(AM_CFLAGS) -Winline -Wall -O -lm -g -mregnames $(VSX_FLAG) \
+			@FLAG_M32@ $(ALTIVEC_FLAG) $(BUILD_FLAG_VSX)
+
--- valgrind/none/tests/ppc64/test_isa_2_06_part3.stdout.exp	(revision 0)
+++ valgrind/none/tests/ppc64/test_isa_2_06_part3.stdout.exp	(revision 12007)
@@ -0,0 +1,663 @@
+Test VSX vector and scalar single argument instructions
+#0: xvredp 1/x(3fd8000000000000) ==> PASS); 1/x(404f000000000000) ==> PASS)
+#1: xvredp 1/x(0018000000b77501) ==> PASS); 1/x(7fe800000000051b) ==> PASS)
+#2: xvredp 1/x(0123214569900000) ==> PASS); 1/x(0000000000000000) ==> PASS)
+#3: xvredp 1/x(8000000000000000) ==> PASS); 1/x(7ff0000000000000) ==> PASS)
+#4: xvredp 1/x(fff0000000000000) ==> PASS); 1/x(7ff7ffffffffffff) ==> PASS)
+#5: xvredp 1/x(fff7ffffffffffff) ==> PASS); 1/x(7ff8000000000000) ==> PASS)
+#6: xvredp 1/x(fff8000000000000) ==> PASS); 1/x(8008340000078000) ==> PASS)
+#7: xvredp 1/x(c0d0650f5a07b353) ==> PASS); 1/x(41232585a9900000) ==> PASS)
+#8: xvredp 1/x(41382511a2000000) ==> PASS); 1/x(40312ef5a9300000) ==> PASS)
+
+#0: xsredp 1/x(3fd8000000000000) ==> PASS)
+#1: xsredp 1/x(404f000000000000) ==> PASS)
+#2: xsredp 1/x(0018000000b77501) ==> PASS)
+#3: xsredp 1/x(7fe800000000051b) ==> PASS)
+#4: xsredp 1/x(0123214569900000) ==> PASS)
+#5: xsredp 1/x(0000000000000000) ==> PASS)
+#6: xsredp 1/x(8000000000000000) ==> PASS)
+#7: xsredp 1/x(7ff0000000000000) ==> PASS)
+#8: xsredp 1/x(fff0000000000000) ==> PASS)
+#9: xsredp 1/x(7ff7ffffffffffff) ==> PASS)
+#10: xsredp 1/x(fff7ffffffffffff) ==> PASS)
+#11: xsredp 1/x(7ff8000000000000) ==> PASS)
+#12: xsredp 1/x(fff8000000000000) ==> PASS)
+#13: xsredp 1/x(8008340000078000) ==> PASS)
+#14: xsredp 1/x(c0d0650f5a07b353) ==> PASS)
+#15: xsredp 1/x(41232585a9900000) ==> PASS)
+#16: xsredp 1/x(41382511a2000000) ==> PASS)
+#17: xsredp 1/x(40312ef5a9300000) ==> PASS)
+
+#0: xvrsqrtedp 1/x-sqrt(3fd8000000000000) ==> PASS); 1/x-sqrt(404f000000000000) ==> PASS)
+#1: xvrsqrtedp 1/x-sqrt(0018000000b77501) ==> PASS); 1/x-sqrt(7fe800000000051b) ==> PASS)
+#2: xvrsqrtedp 1/x-sqrt(0123214569900000) ==> PASS); 1/x-sqrt(0000000000000000) ==> PASS)
+#3: xvrsqrtedp 1/x-sqrt(8000000000000000) ==> PASS); 1/x-sqrt(7ff0000000000000) ==> PASS)
+#4: xvrsqrtedp 1/x-sqrt(fff0000000000000) ==> PASS); 1/x-sqrt(7ff7ffffffffffff) ==> PASS)
+#5: xvrsqrtedp 1/x-sqrt(fff7ffffffffffff) ==> PASS); 1/x-sqrt(7ff8000000000000) ==> PASS)
+#6: xvrsqrtedp 1/x-sqrt(fff8000000000000) ==> PASS); 1/x-sqrt(8008340000078000) ==> PASS)
+#7: xvrsqrtedp 1/x-sqrt(c0d0650f5a07b353) ==> PASS); 1/x-sqrt(41232585a9900000) ==> PASS)
+#8: xvrsqrtedp 1/x-sqrt(41382511a2000000) ==> PASS); 1/x-sqrt(40312ef5a9300000) ==> PASS)
+
+#0: xsrsqrtedp 1/x-sqrt(3fd8000000000000) ==> PASS)
+#1: xsrsqrtedp 1/x-sqrt(404f000000000000) ==> PASS)
+#2: xsrsqrtedp 1/x-sqrt(0018000000b77501) ==> PASS)
+#3: xsrsqrtedp 1/x-sqrt(7fe800000000051b) ==> PASS)
+#4: xsrsqrtedp 1/x-sqrt(0123214569900000) ==> PASS)
+#5: xsrsqrtedp 1/x-sqrt(0000000000000000) ==> PASS)
+#6: xsrsqrtedp 1/x-sqrt(8000000000000000) ==> PASS)
+#7: xsrsqrtedp 1/x-sqrt(7ff0000000000000) ==> PASS)
+#8: xsrsqrtedp 1/x-sqrt(fff0000000000000) ==> PASS)
+#9: xsrsqrtedp 1/x-sqrt(7ff7ffffffffffff) ==> PASS)
+#10: xsrsqrtedp 1/x-sqrt(fff7ffffffffffff) ==> PASS)
+#11: xsrsqrtedp 1/x-sqrt(7ff8000000000000) ==> PASS)
+#12: xsrsqrtedp 1/x-sqrt(fff8000000000000) ==> PASS)
+#13: xsrsqrtedp 1/x-sqrt(8008340000078000) ==> PASS)
+#14: xsrsqrtedp 1/x-sqrt(c0d0650f5a07b353) ==> PASS)
+#15: xsrsqrtedp 1/x-sqrt(41232585a9900000) ==> PASS)
+#16: xsrsqrtedp 1/x-sqrt(41382511a2000000) ==> PASS)
+#17: xsrsqrtedp 1/x-sqrt(40312ef5a9300000) ==> PASS)
+
+#0: xvrsqrtesp 1/x-sqrt(3ec00000) ==> PASS); 1/x-sqrt(42780000) ==> PASS); 1/x-sqrt(00000000) ==> PASS); 1/x-sqrt(7f800000) ==> PASS)
+#1: xvrsqrtesp 1/x-sqrt(00000000) ==> PASS); 1/x-sqrt(00000000) ==> PASS); 1/x-sqrt(80000000) ==> PASS); 1/x-sqrt(7f800000) ==> PASS)
+#2: xvrsqrtesp 1/x-sqrt(ff800000) ==> PASS); 1/x-sqrt(7fffffff) ==> PASS); 1/x-sqrt(ffffffff) ==> PASS); 1/x-sqrt(7fc00000) ==> PASS)
+#3: xvrsqrtesp 1/x-sqrt(ffc00000) ==> PASS); 1/x-sqrt(80000000) ==> PASS); 1/x-sqrt(c683287b) ==> PASS); 1/x-sqrt(49192c2d) ==> PASS)
+#4: xvrsqrtesp 1/x-sqrt(49c1288d) ==> PASS); 1/x-sqrt(418977ad) ==> PASS); 1/x-sqrt(428a5faf) ==> PASS); 1/x-sqrt(44bb5fcc) ==> PASS)
+
+#0: xvsqrtdp sqrt(3fd8000000000000) = 3fe3988e1409212e; sqrt(404f000000000000) = 401f7efbeb8d4f12
+#1: xvsqrtdp sqrt(0018000000b77501) = 2003988e14540690; sqrt(7fe800000000051b) = 5febb67ae8584f9d
+#2: xvsqrtdp sqrt(0123214569900000) = 2088bde98d60ebe6; sqrt(0000000000000000) = 0000000000000000
+#3: xvsqrtdp sqrt(8000000000000000) = 8000000000000000; sqrt(7ff0000000000000) = 7ff0000000000000
+#4: xvsqrtdp sqrt(fff0000000000000) = 7ff8000000000000; sqrt(7ff7ffffffffffff) = 7fffffffffffffff
+#5: xvsqrtdp sqrt(fff7ffffffffffff) = ffffffffffffffff; sqrt(7ff8000000000000) = 7ff8000000000000
+#6: xvsqrtdp sqrt(fff8000000000000) = fff8000000000000; sqrt(8008340000078000) = 7ff8000000000000
+#7: xvsqrtdp sqrt(c0d0650f5a07b353) = 7ff8000000000000; sqrt(41232585a9900000) = 4088c0a9258a4a8b
+#8: xvsqrtdp sqrt(41382511a2000000) = 4093a7aa60f34e85; sqrt(40312ef5a9300000) = 401094c71dec3a9c
+
+#0: xvsqrtsp sqrt(3ec00000) = 3f1cc470; sqrt(42780000) = 40fbf7dc; sqrt(00000000) = 00000000; sqrt(7f800000) = 7f800000
+#1: xvsqrtsp sqrt(00000000) = 00000000; sqrt(00000000) = 00000000; sqrt(80000000) = 80000000; sqrt(7f800000) = 7f800000
+#2: xvsqrtsp sqrt(ff800000) = 7fc00000; sqrt(7fffffff) = 7ffffffc; sqrt(ffffffff) = fffffffc; sqrt(7fc00000) = 7fc00000
+#3: xvsqrtsp sqrt(ffc00000) = ffc00000; sqrt(80000000) = 80000000; sqrt(c683287b) = 7fc00000; sqrt(49192c2d) = 44460548
+#4: xvsqrtsp sqrt(49c1288d) = 449d3d50; sqrt(418977ad) = 4084a638; sqrt(428a5faf) = 410515f8; sqrt(44bb5fcc) = 421ade08
+
+#0: xscvdpsp conv(3fd8000000000000) = 3ec0000000000000
+#1: xscvdpsp conv(404f000000000000) = 4278000000000000
+#2: xscvdpsp conv(0018000000b77501) = 0000000000000000
+#3: xscvdpsp conv(7fe800000000051b) = 7f80000000000000
+#4: xscvdpsp conv(0123214569900000) = 0000000000000000
+#5: xscvdpsp conv(0000000000000000) = 0000000000000000
+#6: xscvdpsp conv(8000000000000000) = 8000000000000000
+#7: xscvdpsp conv(7ff0000000000000) = 7f80000000000000
+#8: xscvdpsp conv(fff0000000000000) = ff80000000000000
+#9: xscvdpsp conv(7ff7ffffffffffff) = 7fffffff00000000
+#10: xscvdpsp conv(fff7ffffffffffff) = ffffffff00000000
+#11: xscvdpsp conv(7ff8000000000000) = 7fc0000000000000
+#12: xscvdpsp conv(fff8000000000000) = ffc0000000000000
+#13: xscvdpsp conv(8008340000078000) = 8000000000000000
+#14: xscvdpsp conv(c0d0650f5a07b353) = c683287b00000000
+#15: xscvdpsp conv(41232585a9900000) = 49192c2d00000000
+#16: xscvdpsp conv(41382511a2000000) = 49c1288d00000000
+#17: xscvdpsp conv(40312ef5a9300000) = 418977ad00000000
+#18: xscvdpsp conv(40514bf5d2300000) = 428a5faf00000000
+#19: xscvdpsp conv(40976bf982440000) = 44bb5fcc00000000
+
+#0: xscvdpuxws conv(3fd8000000000000) = 0000000000000000
+#1: xscvdpuxws conv(404f000000000000) = 000000000000003e
+#2: xscvdpuxws conv(0018000000b77501) = 0000000000000000
+#3: xscvdpuxws conv(7fe800000000051b) = 00000000ffffffff
+#4: xscvdpuxws conv(0123214569900000) = 0000000000000000
+#5: xscvdpuxws conv(0000000000000000) = 0000000000000000
+#6: xscvdpuxws conv(8000000000000000) = 0000000000000000
+#7: xscvdpuxws conv(7ff0000000000000) = 00000000ffffffff
+#8: xscvdpuxws conv(fff0000000000000) = 0000000000000000
+#9: xscvdpuxws conv(7ff7ffffffffffff) = 0000000000000000
+#10: xscvdpuxws conv(fff7ffffffffffff) = 0000000000000000
+#11: xscvdpuxws conv(7ff8000000000000) = 0000000000000000
+#12: xscvdpuxws conv(fff8000000000000) = 0000000000000000
+#13: xscvdpuxws conv(8008340000078000) = 0000000000000000
+#14: xscvdpuxws conv(c0d0650f5a07b353) = 0000000000000000
+#15: xscvdpuxws conv(41232585a9900000) = 00000000000992c2
+#16: xscvdpuxws conv(41382511a2000000) = 0000000000182511
+#17: xscvdpuxws conv(40312ef5a9300000) = 0000000000000011
+#18: xscvdpuxws conv(40514bf5d2300000) = 0000000000000045
+#19: xscvdpuxws conv(40976bf982440000) = 00000000000005da
+
+#0: xscvspdp conv(3ec00000) = 3fd8000000000000
+#1: xscvspdp conv(42780000) = 404f000000000000
+#2: xscvspdp conv(00000000) = 0000000000000000
+#3: xscvspdp conv(7f800000) = 7ff0000000000000
+#4: xscvspdp conv(00000000) = 0000000000000000
+#5: xscvspdp conv(00000000) = 0000000000000000
+#6: xscvspdp conv(80000000) = 8000000000000000
+#7: xscvspdp conv(7f800000) = 7ff0000000000000
+#8: xscvspdp conv(ff800000) = fff0000000000000
+#9: xscvspdp conv(7fffffff) = 7fffffffe0000000
+#10: xscvspdp conv(ffffffff) = ffffffffe0000000
+#11: xscvspdp conv(7fc00000) = 7ff8000000000000
+#12: xscvspdp conv(ffc00000) = fff8000000000000
+#13: xscvspdp conv(80000000) = 8000000000000000
+#14: xscvspdp conv(c683287b) = c0d0650f60000000
+#15: xscvspdp conv(49192c2d) = 41232585a0000000
+#16: xscvspdp conv(49c1288d) = 41382511a0000000
+#17: xscvspdp conv(418977ad) = 40312ef5a0000000
+#18: xscvspdp conv(428a5faf) = 40514bf5e0000000
+#19: xscvspdp conv(44bb5fcc) = 40976bf980000000
+
+#0: xvcvdpsp conv(3fd8000000000000) = 3ec0000000000000; conv(404f000000000000) = 4278000000000000
+#1: xvcvdpsp conv(0018000000b77501) = 0000000000000000; conv(7fe800000000051b) = 7f80000000000000
+#2: xvcvdpsp conv(0123214569900000) = 0000000000000000; conv(0000000000000000) = 0000000000000000
+#3: xvcvdpsp conv(8000000000000000) = 8000000000000000; conv(7ff0000000000000) = 7f80000000000000
+#4: xvcvdpsp conv(fff0000000000000) = ff80000000000000; conv(7ff7ffffffffffff) = 7fffffff00000000
+#5: xvcvdpsp conv(fff7ffffffffffff) = ffffffff00000000; conv(7ff8000000000000) = 7fc0000000000000
+#6: xvcvdpsp conv(fff8000000000000) = ffc0000000000000; conv(8008340000078000) = 8000000000000000
+#7: xvcvdpsp conv(c0d0650f5a07b353) = c683287b00000000; conv(41232585a9900000) = 49192c2d00000000
+#8: xvcvdpsp conv(41382511a2000000) = 49c1288d00000000; conv(40312ef5a9300000) = 418977ad00000000
+#9: xvcvdpsp conv(40514bf5d2300000) = 428a5faf00000000; conv(40976bf982440000) = 44bb5fcc00000000
+
+#0: xvcvdpuxds conv(3fd8000000000000) = 0000000000000000; conv(404f000000000000) = 000000000000003e
+#1: xvcvdpuxds conv(0018000000b77501) = 0000000000000000; conv(7fe800000000051b) = ffffffffffffffff
+#2: xvcvdpuxds conv(0123214569900000) = 0000000000000000; conv(0000000000000000) = 0000000000000000
+#3: xvcvdpuxds conv(8000000000000000) = 0000000000000000; conv(7ff0000000000000) = ffffffffffffffff
+#4: xvcvdpuxds conv(fff0000000000000) = 0000000000000000; conv(7ff7ffffffffffff) = 0000000000000000
+#5: xvcvdpuxds conv(fff7ffffffffffff) = 0000000000000000; conv(7ff8000000000000) = 0000000000000000
+#6: xvcvdpuxds conv(fff8000000000000) = 0000000000000000; conv(8008340000078000) = 0000000000000000
+#7: xvcvdpuxds conv(c0d0650f5a07b353) = 0000000000000000; conv(41232585a9900000) = 00000000000992c2
+#8: xvcvdpuxds conv(41382511a2000000) = 0000000000182511; conv(40312ef5a9300000) = 0000000000000011
+#9: xvcvdpuxds conv(40514bf5d2300000) = 0000000000000045; conv(40976bf982440000) = 00000000000005da
+
+#0: xvcvdpuxws conv(3fd8000000000000) = 0000000000000000; conv(404f000000000000) = 0000003e00000000
+#1: xvcvdpuxws conv(0018000000b77501) = 0000000000000000; conv(7fe800000000051b) = ffffffff00000000
+#2: xvcvdpuxws conv(0123214569900000) = 0000000000000000; conv(0000000000000000) = 0000000000000000
+#3: xvcvdpuxws conv(8000000000000000) = 0000000000000000; conv(7ff0000000000000) = ffffffff00000000
+#4: xvcvdpuxws conv(fff0000000000000) = 0000000000000000; conv(7ff7ffffffffffff) = 0000000000000000
+#5: xvcvdpuxws conv(fff7ffffffffffff) = 0000000000000000; conv(7ff8000000000000) = 0000000000000000
+#6: xvcvdpuxws conv(fff8000000000000) = 0000000000000000; conv(8008340000078000) = 0000000000000000
+#7: xvcvdpuxws conv(c0d0650f5a07b353) = 0000000000000000; conv(41232585a9900000) = 000992c200000000
+#8: xvcvdpuxws conv(41382511a2000000) = 0018251100000000; conv(40312ef5a9300000) = 0000001100000000
+#9: xvcvdpuxws conv(40514bf5d2300000) = 0000004500000000; conv(40976bf982440000) = 000005da00000000
+
+#0: xvcvspdp conv(3ec00000) = 3fd8000000000000; conv(42780000) = 404f000000000000
+#1: xvcvspdp conv(00000000) = 0000000000000000; conv(7f800000) = 7ff0000000000000
+#2: xvcvspdp conv(00000000) = 0000000000000000; conv(00000000) = 0000000000000000
+#3: xvcvspdp conv(80000000) = 8000000000000000; conv(7f800000) = 7ff0000000000000
+#4: xvcvspdp conv(ff800000) = fff0000000000000; conv(7fffffff) = 7fffffffe0000000
+#5: xvcvspdp conv(ffffffff) = ffffffffe0000000; conv(7fc00000) = 7ff8000000000000
+#6: xvcvspdp conv(ffc00000) = fff8000000000000; conv(80000000) = 8000000000000000
+#7: xvcvspdp conv(c683287b) = c0d0650f60000000; conv(49192c2d) = 41232585a0000000
+#8: xvcvspdp conv(49c1288d) = 41382511a0000000; conv(418977ad) = 40312ef5a0000000
+#9: xvcvspdp conv(428a5faf) = 40514bf5e0000000; conv(44bb5fcc) = 40976bf980000000
+
+#0: xvcvspsxds conv(3ec00000) = 0000000000000000; conv(42780000) = 000000000000003e
+#1: xvcvspsxds conv(00000000) = 0000000000000000; conv(7f800000) = 7fffffffffffffff
+#2: xvcvspsxds conv(00000000) = 0000000000000000; conv(00000000) = 0000000000000000
+#3: xvcvspsxds conv(80000000) = 0000000000000000; conv(7f800000) = 7fffffffffffffff
+#4: xvcvspsxds conv(ff800000) = 8000000000000000; conv(7fffffff) = 8000000000000000
+#5: xvcvspsxds conv(ffffffff) = 8000000000000000; conv(7fc00000) = 8000000000000000
+#6: xvcvspsxds conv(ffc00000) = 8000000000000000; conv(80000000) = 0000000000000000
+#7: xvcvspsxds conv(c683287b) = ffffffffffffbe6c; conv(49192c2d) = 00000000000992c2
+#8: xvcvspsxds conv(49c1288d) = 0000000000182511; conv(418977ad) = 0000000000000011
+#9: xvcvspsxds conv(428a5faf) = 0000000000000045; conv(44bb5fcc) = 00000000000005da
+
+#0: xvcvdpsxds conv(3fd8000000000000) = 0000000000000000; conv(404f000000000000) = 000000000000003e
+#1: xvcvdpsxds conv(0018000000b77501) = 0000000000000000; conv(7fe800000000051b) = 7fffffffffffffff
+#2: xvcvdpsxds conv(0123214569900000) = 0000000000000000; conv(0000000000000000) = 0000000000000000
+#3: xvcvdpsxds conv(8000000000000000) = 0000000000000000; conv(7ff0000000000000) = 7fffffffffffffff
+#4: xvcvdpsxds conv(fff0000000000000) = 8000000000000000; conv(7ff7ffffffffffff) = 8000000000000000
+#5: xvcvdpsxds conv(fff7ffffffffffff) = 8000000000000000; conv(7ff8000000000000) = 8000000000000000
+#6: xvcvdpsxds conv(fff8000000000000) = 8000000000000000; conv(8008340000078000) = 0000000000000000
+#7: xvcvdpsxds conv(c0d0650f5a07b353) = ffffffffffffbe6c; conv(41232585a9900000) = 00000000000992c2
+#8: xvcvdpsxds conv(41382511a2000000) = 0000000000182511; conv(40312ef5a9300000) = 0000000000000011
+#9: xvcvdpsxds conv(40514bf5d2300000) = 0000000000000045; conv(40976bf982440000) = 00000000000005da
+
+#0: xvcvspuxds conv(3ec00000) = 0000000000000000; conv(42780000) = 000000000000003e
+#1: xvcvspuxds conv(00000000) = 0000000000000000; conv(7f800000) = ffffffffffffffff
+#2: xvcvspuxds conv(00000000) = 0000000000000000; conv(00000000) = 0000000000000000
+#3: xvcvspuxds conv(80000000) = 0000000000000000; conv(7f800000) = ffffffffffffffff
+#4: xvcvspuxds conv(ff800000) = 0000000000000000; conv(7fffffff) = 0000000000000000
+#5: xvcvspuxds conv(ffffffff) = 0000000000000000; conv(7fc00000) = 0000000000000000
+#6: xvcvspuxds conv(ffc00000) = 0000000000000000; conv(80000000) = 0000000000000000
+#7: xvcvspuxds conv(c683287b) = 0000000000000000; conv(49192c2d) = 00000000000992c2
+#8: xvcvspuxds conv(49c1288d) = 0000000000182511; conv(418977ad) = 0000000000000011
+#9: xvcvspuxds conv(428a5faf) = 0000000000000045; conv(44bb5fcc) = 00000000000005da
+
+#0: xvcvspuxws conv(3ec00000) = 00000000; conv(42780000) = 0000003e; conv(00000000) = 00000000; conv(7f800000) = ffffffff
+#1: xvcvspuxws conv(00000000) = 00000000; conv(00000000) = 00000000; conv(80000000) = 00000000; conv(7f800000) = ffffffff
+#2: xvcvspuxws conv(ff800000) = 00000000; conv(7fffffff) = 00000000; conv(ffffffff) = 00000000; conv(7fc00000) = 00000000
+#3: xvcvspuxws conv(ffc00000) = 00000000; conv(80000000) = 00000000; conv(c683287b) = 00000000; conv(49192c2d) = 000992c2
+#4: xvcvspuxws conv(49c1288d) = 00182511; conv(418977ad) = 00000011; conv(428a5faf) = 00000045; conv(44bb5fcc) = 000005da
+
+#0: xsrdpic round(3fd8000000000000) = 0000000000000000
+#1: xsrdpic round(404f000000000000) = 404f000000000000
+#2: xsrdpic round(0018000000b77501) = 0000000000000000
+#3: xsrdpic round(7fe800000000051b) = 7fe800000000051b
+#4: xsrdpic round(0123214569900000) = 0000000000000000
+#5: xsrdpic round(0000000000000000) = 0000000000000000
+#6: xsrdpic round(8000000000000000) = 8000000000000000
+#7: xsrdpic round(7ff0000000000000) = 7ff0000000000000
+#8: xsrdpic round(fff0000000000000) = fff0000000000000
+#9: xsrdpic round(7ff7ffffffffffff) = 7fffffffffffffff
+#10: xsrdpic round(fff7ffffffffffff) = ffffffffffffffff
+#11: xsrdpic round(7ff8000000000000) = 7ff8000000000000
+#12: xsrdpic round(fff8000000000000) = fff8000000000000
+#13: xsrdpic round(8008340000078000) = 8000000000000000
+#14: xsrdpic round(c0d0650f5a07b353) = c0d0650000000000
+#15: xsrdpic round(41232585a9900000) = 4123258600000000
+#16: xsrdpic round(41382511a2000000) = 4138251200000000
+#17: xsrdpic round(40312ef5a9300000) = 4031000000000000
+#18: xsrdpic round(40514bf5d2300000) = 4051400000000000
+#19: xsrdpic round(40976bf982440000) = 40976c0000000000
+
+#0: xsrdpiz round(3fd8000000000000) = 0000000000000000
+#1: xsrdpiz round(404f000000000000) = 404f000000000000
+#2: xsrdpiz round(0018000000b77501) = 0000000000000000
+#3: xsrdpiz round(7fe800000000051b) = 7fe800000000051b
+#4: xsrdpiz round(0123214569900000) = 0000000000000000
+#5: xsrdpiz round(0000000000000000) = 0000000000000000
+#6: xsrdpiz round(8000000000000000) = 8000000000000000
+#7: xsrdpiz round(7ff0000000000000) = 7ff0000000000000
+#8: xsrdpiz round(fff0000000000000) = fff0000000000000
+#9: xsrdpiz round(7ff7ffffffffffff) = 7fffffffffffffff
+#10: xsrdpiz round(fff7ffffffffffff) = ffffffffffffffff
+#11: xsrdpiz round(7ff8000000000000) = 7ff8000000000000
+#12: xsrdpiz round(fff8000000000000) = fff8000000000000
+#13: xsrdpiz round(8008340000078000) = 8000000000000000
+#14: xsrdpiz round(c0d0650f5a07b353) = c0d0650000000000
+#15: xsrdpiz round(41232585a9900000) = 4123258400000000
+#16: xsrdpiz round(41382511a2000000) = 4138251100000000
+#17: xsrdpiz round(40312ef5a9300000) = 4031000000000000
+#18: xsrdpiz round(40514bf5d2300000) = 4051400000000000
+#19: xsrdpiz round(40976bf982440000) = 4097680000000000
+
+#0: xsrdpi round(3fd8000000000000) = 0000000000000000
+#1: xsrdpi round(404f000000000000) = 404f000000000000
+#2: xsrdpi round(0018000000b77501) = 0000000000000000
+#3: xsrdpi round(7fe800000000051b) = 7fe800000000051b
+#4: xsrdpi round(0123214569900000) = 0000000000000000
+#5: xsrdpi round(0000000000000000) = 0000000000000000
+#6: xsrdpi round(8000000000000000) = 8000000000000000
+#7: xsrdpi round(7ff0000000000000) = 7ff0000000000000
+#8: xsrdpi round(fff0000000000000) = fff0000000000000
+#9: xsrdpi round(7ff7ffffffffffff) = 7fffffffffffffff
+#10: xsrdpi round(fff7ffffffffffff) = ffffffffffffffff
+#11: xsrdpi round(7ff8000000000000) = 7ff8000000000000
+#12: xsrdpi round(fff8000000000000) = fff8000000000000
+#13: xsrdpi round(8008340000078000) = 8000000000000000
+#14: xsrdpi round(c0d0650f5a07b353) = c0d0650000000000
+#15: xsrdpi round(41232585a9900000) = 4123258600000000
+#16: xsrdpi round(41382511a2000000) = 4138251200000000
+#17: xsrdpi round(40312ef5a9300000) = 4031000000000000
+#18: xsrdpi round(40514bf5d2300000) = 4051400000000000
+#19: xsrdpi round(40976bf982440000) = 40976c0000000000
+
+#0: xvabsdp abs(3fd8000000000000) = 3fd8000000000000; abs(404f000000000000) = 404f000000000000
+#1: xvabsdp abs(0018000000b77501) = 0018000000b77501; abs(7fe800000000051b) = 7fe800000000051b
+#2: xvabsdp abs(0123214569900000) = 0123214569900000; abs(0000000000000000) = 0000000000000000
+#3: xvabsdp abs(8000000000000000) = 0000000000000000; abs(7ff0000000000000) = 7ff0000000000000
+#4: xvabsdp abs(fff0000000000000) = 7ff0000000000000; abs(7ff7ffffffffffff) = 7ff7ffffffffffff
+#5: xvabsdp abs(fff7ffffffffffff) = 7ff7ffffffffffff; abs(7ff8000000000000) = 7ff8000000000000
+#6: xvabsdp abs(fff8000000000000) = 7ff8000000000000; abs(8008340000078000) = 0008340000078000
+#7: xvabsdp abs(c0d0650f5a07b353) = 40d0650f5a07b353; abs(41232585a9900000) = 41232585a9900000
+#8: xvabsdp abs(41382511a2000000) = 41382511a2000000; abs(40312ef5a9300000) = 40312ef5a9300000
+#9: xvabsdp abs(40514bf5d2300000) = 40514bf5d2300000; abs(40976bf982440000) = 40976bf982440000
+
+#0: xvnabsdp nabs(3fd8000000000000) = bfd8000000000000; nabs(404f000000000000) = c04f000000000000
+#1: xvnabsdp nabs(0018000000b77501) = 8018000000b77501; nabs(7fe800000000051b) = ffe800000000051b
+#2: xvnabsdp nabs(0123214569900000) = 8123214569900000; nabs(0000000000000000) = 8000000000000000
+#3: xvnabsdp nabs(8000000000000000) = 8000000000000000; nabs(7ff0000000000000) = fff0000000000000
+#4: xvnabsdp nabs(fff0000000000000) = fff0000000000000; nabs(7ff7ffffffffffff) = fff7ffffffffffff
+#5: xvnabsdp nabs(fff7ffffffffffff) = fff7ffffffffffff; nabs(7ff8000000000000) = fff8000000000000
+#6: xvnabsdp nabs(fff8000000000000) = fff8000000000000; nabs(8008340000078000) = 8008340000078000
+#7: xvnabsdp nabs(c0d0650f5a07b353) = c0d0650f5a07b353; nabs(41232585a9900000) = c1232585a9900000
+#8: xvnabsdp nabs(41382511a2000000) = c1382511a2000000; nabs(40312ef5a9300000) = c0312ef5a9300000
+#9: xvnabsdp nabs(40514bf5d2300000) = c0514bf5d2300000; nabs(40976bf982440000) = c0976bf982440000
+
+#0: xvnegdp neg(3fd8000000000000) = bfd8000000000000; neg(404f000000000000) = c04f000000000000
+#1: xvnegdp neg(0018000000b77501) = 8018000000b77501; neg(7fe800000000051b) = ffe800000000051b
+#2: xvnegdp neg(0123214569900000) = 8123214569900000; neg(0000000000000000) = 8000000000000000
+#3: xvnegdp neg(8000000000000000) = 0000000000000000; neg(7ff0000000000000) = fff0000000000000
+#4: xvnegdp neg(fff0000000000000) = 7ff0000000000000; neg(7ff7ffffffffffff) = fff7ffffffffffff
+#5: xvnegdp neg(fff7ffffffffffff) = 7ff7ffffffffffff; neg(7ff8000000000000) = fff8000000000000
+#6: xvnegdp neg(fff8000000000000) = 7ff8000000000000; neg(8008340000078000) = 0008340000078000
+#7: xvnegdp neg(c0d0650f5a07b353) = 40d0650f5a07b353; neg(41232585a9900000) = c1232585a9900000
+#8: xvnegdp neg(41382511a2000000) = c1382511a2000000; neg(40312ef5a9300000) = c0312ef5a9300000
+#9: xvnegdp neg(40514bf5d2300000) = c0514bf5d2300000; neg(40976bf982440000) = c0976bf982440000
+
+#0: xvabssp abs(3ec00000) = 3ec00000; abs(42780000) = 42780000; abs(00000000) = 00000000; abs(7f800000) = 7f800000
+#1: xvabssp abs(00000000) = 00000000; abs(00000000) = 00000000; abs(80000000) = 00000000; abs(7f800000) = 7f800000
+#2: xvabssp abs(ff800000) = 7f800000; abs(7fffffff) = 7fffffff; abs(ffffffff) = 7fffffff; abs(7fc00000) = 7fc00000
+#3: xvabssp abs(ffc00000) = 7fc00000; abs(80000000) = 00000000; abs(c683287b) = 4683287b; abs(49192c2d) = 49192c2d
+#4: xvabssp abs(49c1288d) = 49c1288d; abs(418977ad) = 418977ad; abs(428a5faf) = 428a5faf; abs(44bb5fcc) = 44bb5fcc
+
+#0: xvnabssp nabs(3ec00000) = bec00000; nabs(42780000) = c2780000; nabs(00000000) = 80000000; nabs(7f800000) = ff800000
+#1: xvnabssp nabs(00000000) = 80000000; nabs(00000000) = 80000000; nabs(80000000) = 80000000; nabs(7f800000) = ff800000
+#2: xvnabssp nabs(ff800000) = ff800000; nabs(7fffffff) = ffffffff; nabs(ffffffff) = ffffffff; nabs(7fc00000) = ffc00000
+#3: xvnabssp nabs(ffc00000) = ffc00000; nabs(80000000) = 80000000; nabs(c683287b) = c683287b; nabs(49192c2d) = c9192c2d
+#4: xvnabssp nabs(49c1288d) = c9c1288d; nabs(418977ad) = c18977ad; nabs(428a5faf) = c28a5faf; nabs(44bb5fcc) = c4bb5fcc
+
+#0: xvrdpi round(3fd8000000000000) = 0000000000000000; round(404f000000000000) = 404f000000000000
+#1: xvrdpi round(0018000000b77501) = 0000000000000000; round(7fe800000000051b) = 7fe800000000051b
+#2: xvrdpi round(0123214569900000) = 0000000000000000; round(0000000000000000) = 0000000000000000
+#3: xvrdpi round(8000000000000000) = 8000000000000000; round(7ff0000000000000) = 7ff0000000000000
+#4: xvrdpi round(fff0000000000000) = fff0000000000000; round(7ff7ffffffffffff) = 7fffffffffffffff
+#5: xvrdpi round(fff7ffffffffffff) = ffffffffffffffff; round(7ff8000000000000) = 7ff8000000000000
+#6: xvrdpi round(fff8000000000000) = fff8000000000000; round(8008340000078000) = 8000000000000000
+#7: xvrdpi round(c0d0650f5a07b353) = c0d0650000000000; round(41232585a9900000) = 4123258600000000
+#8: xvrdpi round(41382511a2000000) = 4138251200000000; round(40312ef5a9300000) = 4031000000000000
+#9: xvrdpi round(40514bf5d2300000) = 4051400000000000; round(40976bf982440000) = 40976c0000000000
+
+#0: xvrdpic round(3fd8000000000000) = 0000000000000000; round(404f000000000000) = 404f000000000000
+#1: xvrdpic round(0018000000b77501) = 0000000000000000; round(7fe800000000051b) = 7fe800000000051b
+#2: xvrdpic round(0123214569900000) = 0000000000000000; round(0000000000000000) = 0000000000000000
+#3: xvrdpic round(8000000000000000) = 8000000000000000; round(7ff0000000000000) = 7ff0000000000000
+#4: xvrdpic round(fff0000000000000) = fff0000000000000; round(7ff7ffffffffffff) = 7fffffffffffffff
+#5: xvrdpic round(fff7ffffffffffff) = ffffffffffffffff; round(7ff8000000000000) = 7ff8000000000000
+#6: xvrdpic round(fff8000000000000) = fff8000000000000; round(8008340000078000) = 8000000000000000
+#7: xvrdpic round(c0d0650f5a07b353) = c0d0650000000000; round(41232585a9900000) = 4123258600000000
+#8: xvrdpic round(41382511a2000000) = 4138251200000000; round(40312ef5a9300000) = 4031000000000000
+#9: xvrdpic round(40514bf5d2300000) = 4051400000000000; round(40976bf982440000) = 40976c0000000000
+
+#0: xvrdpim round(3fd8000000000000) = 0000000000000000; round(404f000000000000) = 404f000000000000
+#1: xvrdpim round(0018000000b77501) = 0000000000000000; round(7fe800000000051b) = 7fe800000000051b
+#2: xvrdpim round(0123214569900000) = 0000000000000000; round(0000000000000000) = 0000000000000000
+#3: xvrdpim round(8000000000000000) = 8000000000000000; round(7ff0000000000000) = 7ff0000000000000
+#4: xvrdpim round(fff0000000000000) = fff0000000000000; round(7ff7ffffffffffff) = 7fffffffffffffff
+#5: xvrdpim round(fff7ffffffffffff) = ffffffffffffffff; round(7ff8000000000000) = 7ff8000000000000
+#6: xvrdpim round(fff8000000000000) = fff8000000000000; round(8008340000078000) = bff0000000000000
+#7: xvrdpim round(c0d0650f5a07b353) = c0d0654000000000; round(41232585a9900000) = 4123258400000000
+#8: xvrdpim round(41382511a2000000) = 4138251100000000; round(40312ef5a9300000) = 4031000000000000
+#9: xvrdpim round(40514bf5d2300000) = 4051400000000000; round(40976bf982440000) = 4097680000000000
+
+#0: xvrdpip round(3fd8000000000000) = 3ff0000000000000; round(404f000000000000) = 404f000000000000
+#1: xvrdpip round(0018000000b77501) = 3ff0000000000000; round(7fe800000000051b) = 7fe800000000051b
+#2: xvrdpip round(0123214569900000) = 3ff0000000000000; round(0000000000000000) = 0000000000000000
+#3: xvrdpip round(8000000000000000) = 8000000000000000; round(7ff0000000000000) = 7ff0000000000000
+#4: xvrdpip round(fff0000000000000) = fff0000000000000; round(7ff7ffffffffffff) = 7fffffffffffffff
+#5: xvrdpip round(fff7ffffffffffff) = ffffffffffffffff; round(7ff8000000000000) = 7ff8000000000000
+#6: xvrdpip round(fff8000000000000) = fff8000000000000; round(8008340000078000) = 8000000000000000
+#7: xvrdpip round(c0d0650f5a07b353) = c0d0650000000000; round(41232585a9900000) = 4123258600000000
+#8: xvrdpip round(41382511a2000000) = 4138251200000000; round(40312ef5a9300000) = 4032000000000000
+#9: xvrdpip round(40514bf5d2300000) = 4051800000000000; round(40976bf982440000) = 40976c0000000000
+
+#0: xvrdpiz round(3fd8000000000000) = 0000000000000000; round(404f000000000000) = 404f000000000000
+#1: xvrdpiz round(0018000000b77501) = 0000000000000000; round(7fe800000000051b) = 7fe800000000051b
+#2: xvrdpiz round(0123214569900000) = 0000000000000000; round(0000000000000000) = 0000000000000000
+#3: xvrdpiz round(8000000000000000) = 8000000000000000; round(7ff0000000000000) = 7ff0000000000000
+#4: xvrdpiz round(fff0000000000000) = fff0000000000000; round(7ff7ffffffffffff) = 7fffffffffffffff
+#5: xvrdpiz round(fff7ffffffffffff) = ffffffffffffffff; round(7ff8000000000000) = 7ff8000000000000
+#6: xvrdpiz round(fff8000000000000) = fff8000000000000; round(8008340000078000) = 8000000000000000
+#7: xvrdpiz round(c0d0650f5a07b353) = c0d0650000000000; round(41232585a9900000) = 4123258400000000
+#8: xvrdpiz round(41382511a2000000) = 4138251100000000; round(40312ef5a9300000) = 4031000000000000
+#9: xvrdpiz round(40514bf5d2300000) = 4051400000000000; round(40976bf982440000) = 4097680000000000
+
+#0: xvrspi round(3ec00000) = 00000000; round(42780000) = 42780000; round(00000000) = 00000000; round(7f800000) = 7f800000
+#1: xvrspi round(00000000) = 00000000; round(00000000) = 00000000; round(80000000) = 80000000; round(7f800000) = 7f800000
+#2: xvrspi round(ff800000) = ff800000; round(7fffffff) = 7fffffff; round(ffffffff) = ffffffff; round(7fc00000) = 7fc00000
+#3: xvrspi round(ffc00000) = ffc00000; round(80000000) = 80000000; round(c683287b) = c6832800; round(49192c2d) = 49192c30
+#4: xvrspi round(49c1288d) = 49c12890; round(418977ad) = 41880000; round(428a5faf) = 428a0000; round(44bb5fcc) = 44bb6000
+
+#0: xvrspic round(3ec00000) = 00000000; round(42780000) = 42780000; round(00000000) = 00000000; round(7f800000) = 7f800000
+#1: xvrspic round(00000000) = 00000000; round(00000000) = 00000000; round(80000000) = 80000000; round(7f800000) = 7f800000
+#2: xvrspic round(ff800000) = ff800000; round(7fffffff) = 7fffffff; round(ffffffff) = ffffffff; round(7fc00000) = 7fc00000
+#3: xvrspic round(ffc00000) = ffc00000; round(80000000) = 80000000; round(c683287b) = c6832800; round(49192c2d) = 49192c30
+#4: xvrspic round(49c1288d) = 49c12890; round(418977ad) = 41880000; round(428a5faf) = 428a0000; round(44bb5fcc) = 44bb6000
+
+#0: xvrspim round(3ec00000) = 00000000; round(42780000) = 42780000; round(00000000) = 00000000; round(7f800000) = 7f800000
+#1: xvrspim round(00000000) = 00000000; round(00000000) = 00000000; round(80000000) = 80000000; round(7f800000) = 7f800000
+#2: xvrspim round(ff800000) = ff800000; round(7fffffff) = 7fffffff; round(ffffffff) = ffffffff; round(7fc00000) = 7fc00000
+#3: xvrspim round(ffc00000) = ffc00000; round(80000000) = 80000000; round(c683287b) = c6832a00; round(49192c2d) = 49192c20
+#4: xvrspim round(49c1288d) = 49c12888; round(418977ad) = 41880000; round(428a5faf) = 428a0000; round(44bb5fcc) = 44bb4000
+
+#0: xvrspip round(3ec00000) = 3f800000; round(42780000) = 42780000; round(00000000) = 00000000; round(7f800000) = 7f800000
+#1: xvrspip round(00000000) = 00000000; round(00000000) = 00000000; round(80000000) = 80000000; round(7f800000) = 7f800000
+#2: xvrspip round(ff800000) = ff800000; round(7fffffff) = 7fffffff; round(ffffffff) = ffffffff; round(7fc00000) = 7fc00000
+#3: xvrspip round(ffc00000) = ffc00000; round(80000000) = 80000000; round(c683287b) = c6832800; round(49192c2d) = 49192c30
+#4: xvrspip round(49c1288d) = 49c12890; round(418977ad) = 41900000; round(428a5faf) = 428c0000; round(44bb5fcc) = 44bb6000
+
+#0: xvrspiz round(3ec00000) = 00000000; round(42780000) = 42780000; round(00000000) = 00000000; round(7f800000) = 7f800000
+#1: xvrspiz round(00000000) = 00000000; round(00000000) = 00000000; round(80000000) = 80000000; round(7f800000) = 7f800000
+#2: xvrspiz round(ff800000) = ff800000; round(7fffffff) = 7fffffff; round(ffffffff) = ffffffff; round(7fc00000) = 7fc00000
+#3: xvrspiz round(ffc00000) = ffc00000; round(80000000) = 80000000; round(c683287b) = c6832800; round(49192c2d) = 49192c20
+#4: xvrspiz round(49c1288d) = 49c12888; round(418977ad) = 41880000; round(428a5faf) = 428a0000; round(44bb5fcc) = 44bb4000
+
+Test VSX vector integer to float conversion instructions
+#0: xvcvsxddp conv(0000000000000000) = 0000000000000000; conv(ffffffff00000000) = c1f0000000000000
+#1: xvcvsxddp conv(00000000ffffffff) = 41efffffffe00000; conv(ffffffffffffffff) = bff0000000000000
+#2: xvcvsxddp conv(89abcde123456789) = c3dd950c87b72ea6; conv(0102030405060708) = 4370203040506070
+#3: xvcvsxddp conv(00000000a0b1c2d3) = 41e416385a600000; conv(1111222233334444) = 43b1112222333344
+
+#0: xvcvuxddp conv(0000000000000000) = 0000000000000000; conv(ffffffff00000000) = 43efffffffe00000
+#1: xvcvuxddp conv(00000000ffffffff) = 41efffffffe00000; conv(ffffffffffffffff) = 43f0000000000000
+#2: xvcvuxddp conv(89abcde123456789) = 43e13579bc2468ad; conv(0102030405060708) = 4370203040506070
+#3: xvcvuxddp conv(00000000a0b1c2d3) = 41e416385a600000; conv(1111222233334444) = 43b1112222333344
+
+#0: xvcvsxdsp conv(0000000000000000) = 0000000000000000; conv(ffffffff00000000) = cf80000000000000
+#1: xvcvsxdsp conv(00000000ffffffff) = 4f80000000000000; conv(ffffffffffffffff) = bf80000000000000
+#2: xvcvsxdsp conv(89abcde123456789) = deeca86400000000; conv(0102030405060708) = 5b81018200000000
+#3: xvcvsxdsp conv(00000000a0b1c2d3) = 4f20b1c300000000; conv(1111222233334444) = 5d88891100000000
+
+#0: xvcvuxdsp conv(0000000000000000) = 0000000000000000; conv(ffffffff00000000) = 5f80000000000000
+#1: xvcvuxdsp conv(00000000ffffffff) = 4f80000000000000; conv(ffffffffffffffff) = 5f80000000000000
+#2: xvcvuxdsp conv(89abcde123456789) = 5f09abce00000000; conv(0102030405060708) = 5b81018200000000
+#3: xvcvuxdsp conv(00000000a0b1c2d3) = 4f20b1c300000000; conv(1111222233334444) = 5d88891100000000
+
+#0: xvcvsxwdp conv(00000000) = 0000000000000000; conv(ffff0000) = c0f0000000000000
+#1: xvcvsxwdp conv(0000ffff) = 40efffe000000000; conv(ffffffff) = bff0000000000000
+#2: xvcvsxwdp conv(89a73522) = c1dd9632b7800000; conv(01020304) = 4170203040000000
+#3: xvcvsxwdp conv(0000abcd) = 40e579a000000000; conv(11223344) = 41b1223344000000
+
+#0: xvcvuxwdp conv(00000000) = 0000000000000000; conv(ffff0000) = 41efffe000000000
+#1: xvcvuxwdp conv(0000ffff) = 40efffe000000000; conv(ffffffff) = 41efffffffe00000
+#2: xvcvuxwdp conv(89a73522) = 41e134e6a4400000; conv(01020304) = 4170203040000000
+#3: xvcvuxwdp conv(0000abcd) = 40e579a000000000; conv(11223344) = 41b1223344000000
+
+#0: xvcvsxwsp conv(00000000) = 00000000; conv(ffff0000) = c7800000; conv(0000ffff) = 477fff00; conv(ffffffff) = bf800000
+#1: xvcvsxwsp conv(89a73522) = ceecb196; conv(01020304) = 4b810182; conv(0000abcd) = 472bcd00; conv(11223344) = 4d89119a
+
+#0: xvcvuxwsp conv(00000000) = 00000000; conv(ffff0000) = 4f7fff00; conv(0000ffff) = 477fff00; conv(ffffffff) = 4f800000
+#1: xvcvuxwsp conv(89a73522) = 4f09a735; conv(01020304) = 4b810182; conv(0000abcd) = 472bcd00; conv(11223344) = 4d89119a
+
+Test div extensions
+#0: divdeu: 0x00000000000000040000000000000000 / 0xfffffffffffffffc = 0x0000000000000004; CR=0; XER=0
+#1: divdeu: 0x00000000000000040000000000000000 / 0xfffffffffffffffd = 0x0000000000000004; CR=0; XER=0
+#2: divdeu: 0x00000000000000040000000000000000 / 0x0000000000000004 = 0x0000000000000000; CR=0; XER=0
+#3: divdeu: 0x00000000000000040000000000000000 / 0xfffffffffffffffb = 0x0000000000000004; CR=0; XER=0
+#4: divdeu: 0x00000000000000030000000000000000 / 0x0000000000000008 = 0x6000000000000000; CR=0; XER=0
+#5: divdeu: 0x80000000000000000000000000000000 / 0x000000000000000a = 0x0000000000000000; CR=0; XER=0
+#6: divdeu: 0x000000000000050c0000000000000000 / 0xffffffffffffffff = 0x000000000000050c; CR=0; XER=0
+#7: divdeu: 0x000000000000050c0000000000000000 / 0xfffffffffffff000 = 0x000000000000050c; CR=0; XER=0
+#8: divdeu: 0x000000001234fedc0000000000000000 / 0x000000008000a873 = 0x2469cdcc6ad4ce20; CR=0; XER=0
+#9: divdeu: 0xabcd87651234fedc0000000000000000 / 0x00000000a123b893 = 0x0000000000000000; CR=0; XER=0
+#10: divdeu: 0x000123456789abdc0000000000000000 / 0x0000000000000000 = 0x0000000000000000; CR=0; XER=0
+#11: divdeu: 0x00000000000000000000000000000000 / 0x0000000000000002 = 0x0000000000000000; CR=0; XER=0
+#12: divdeu: 0x00000000000000770000000000000000 / 0x00000000000a3499 = 0x000ba911a321dcca; CR=0; XER=0
+
+#0: divdeu.: 0x00000000000000040000000000000000 / 0xfffffffffffffffc = 0x0000000000000004; CR=4; XER=0
+#1: divdeu.: 0x00000000000000040000000000000000 / 0xfffffffffffffffd = 0x0000000000000004; CR=4; XER=0
+#2: divdeu.: 0x00000000000000040000000000000000 / 0x0000000000000004 = 0x0000000000000000; CR=2; XER=0
+#3: divdeu.: 0x00000000000000040000000000000000 / 0xfffffffffffffffb = 0x0000000000000004; CR=4; XER=0
+#4: divdeu.: 0x00000000000000030000000000000000 / 0x0000000000000008 = 0x6000000000000000; CR=4; XER=0
+#5: divdeu.: 0x80000000000000000000000000000000 / 0x000000000000000a = 0x0000000000000000; CR=2; XER=0
+#6: divdeu.: 0x000000000000050c0000000000000000 / 0xffffffffffffffff = 0x000000000000050c; CR=4; XER=0
+#7: divdeu.: 0x000000000000050c0000000000000000 / 0xfffffffffffff000 = 0x000000000000050c; CR=4; XER=0
+#8: divdeu.: 0x000000001234fedc0000000000000000 / 0x000000008000a873 = 0x2469cdcc6ad4ce20; CR=4; XER=0
+#9: divdeu.: 0xabcd87651234fedc0000000000000000 / 0x00000000a123b893 = 0x0000000000000000; CR=2; XER=0
+#10: divdeu.: 0x000123456789abdc0000000000000000 / 0x0000000000000000 = 0x0000000000000000; CR=2; XER=0
+#11: divdeu.: 0x00000000000000000000000000000000 / 0x0000000000000002 = 0x0000000000000000; CR=2; XER=0
+#12: divdeu.: 0x00000000000000770000000000000000 / 0x00000000000a3499 = 0x000ba911a321dcca; CR=4; XER=0
+
+
+#0: divdeuo: 0x00000000000000040000000000000000 / 0xfffffffffffffffc = 0x0000000000000004; CR=0; XER=0
+#1: divdeuo: 0x00000000000000040000000000000000 / 0xfffffffffffffffd = 0x0000000000000004; CR=0; XER=0
+#2: divdeuo: 0x00000000000000040000000000000000 / 0x0000000000000004 = 0x0000000000000000; CR=0; XER=c0000000
+#3: divdeuo: 0x00000000000000040000000000000000 / 0xfffffffffffffffb = 0x0000000000000004; CR=0; XER=0
+#4: divdeuo: 0x00000000000000030000000000000000 / 0x0000000000000008 = 0x6000000000000000; CR=0; XER=0
+#5: divdeuo: 0x80000000000000000000000000000000 / 0x000000000000000a = 0x0000000000000000; CR=0; XER=c0000000
+#6: divdeuo: 0x000000000000050c0000000000000000 / 0xffffffffffffffff = 0x000000000000050c; CR=0; XER=0
+#7: divdeuo: 0x000000000000050c0000000000000000 / 0xfffffffffffff000 = 0x000000000000050c; CR=0; XER=0
+#8: divdeuo: 0x000000001234fedc0000000000000000 / 0x000000008000a873 = 0x2469cdcc6ad4ce20; CR=0; XER=0
+#9: divdeuo: 0xabcd87651234fedc0000000000000000 / 0x00000000a123b893 = 0x0000000000000000; CR=0; XER=c0000000
+#10: divdeuo: 0x000123456789abdc0000000000000000 / 0x0000000000000000 = 0x0000000000000000; CR=0; XER=c0000000
+#11: divdeuo: 0x00000000000000000000000000000000 / 0x0000000000000002 = 0x0000000000000000; CR=0; XER=0
+#12: divdeuo: 0x00000000000000770000000000000000 / 0x00000000000a3499 = 0x000ba911a321dcca; CR=0; XER=0
+
+#0: divdeuo.: 0x00000000000000040000000000000000 / 0xfffffffffffffffc = 0x0000000000000004; CR=4; XER=0
+#1: divdeuo.: 0x00000000000000040000000000000000 / 0xfffffffffffffffd = 0x0000000000000004; CR=4; XER=0
+#2: divdeuo.: 0x00000000000000040000000000000000 / 0x0000000000000004 = 0x0000000000000000; CR=3; XER=c0000000
+#3: divdeuo.: 0x00000000000000040000000000000000 / 0xfffffffffffffffb = 0x0000000000000004; CR=4; XER=0
+#4: divdeuo.: 0x00000000000000030000000000000000 / 0x0000000000000008 = 0x6000000000000000; CR=4; XER=0
+#5: divdeuo.: 0x80000000000000000000000000000000 / 0x000000000000000a = 0x0000000000000000; CR=3; XER=c0000000
+#6: divdeuo.: 0x000000000000050c0000000000000000 / 0xffffffffffffffff = 0x000000000000050c; CR=4; XER=0
+#7: divdeuo.: 0x000000000000050c0000000000000000 / 0xfffffffffffff000 = 0x000000000000050c; CR=4; XER=0
+#8: divdeuo.: 0x000000001234fedc0000000000000000 / 0x000000008000a873 = 0x2469cdcc6ad4ce20; CR=4; XER=0
+#9: divdeuo.: 0xabcd87651234fedc0000000000000000 / 0x00000000a123b893 = 0x0000000000000000; CR=3; XER=c0000000
+#10: divdeuo.: 0x000123456789abdc0000000000000000 / 0x0000000000000000 = 0x0000000000000000; CR=3; XER=c0000000
+#11: divdeuo.: 0x00000000000000000000000000000000 / 0x0000000000000002 = 0x0000000000000000; CR=2; XER=0
+#12: divdeuo.: 0x00000000000000770000000000000000 / 0x00000000000a3499 = 0x000ba911a321dcca; CR=4; XER=0
+
+
+#0: divwe: 0x0000000000000000 / 0x00000002 = 0x00000000; CR=0; XER=0
+#1: divwe: 0x0000000200000000 / 0x00000000 = 0x00000000; CR=0; XER=0
+#2: divwe: 0x7abc123400000000 / 0xf0000000 = 0x00000000; CR=0; XER=0
+#3: divwe: 0xfabc123400000000 / 0x00000005 = 0x00000000; CR=0; XER=0
+#4: divwe: 0x0000004d00000000 / 0x00000042 = 0x00000000; CR=0; XER=0
+#5: divwe: 0x0000000500000000 / 0xfabc1234 = 0xffffff0d; CR=0; XER=0
+
+#0: divwe.: 0x0000000000000000 / 0x00000002 = 0x00000000; CR=2; XER=0
+#1: divwe.: 0x0000000200000000 / 0x00000000 = 0x00000000; CR=2; XER=0
+#2: divwe.: 0x7abc123400000000 / 0xf0000000 = 0x00000000; CR=2; XER=0
+#3: divwe.: 0xfabc123400000000 / 0x00000005 = 0x00000000; CR=2; XER=0
+#4: divwe.: 0x0000004d00000000 / 0x00000042 = 0x00000000; CR=2; XER=0
+#5: divwe.: 0x0000000500000000 / 0xfabc1234 = 0xffffff0d; CR=4; XER=0
+
+
+#0: divweo: 0x0000000000000000 / 0x00000002 = 0x00000000; CR=0; XER=0
+#1: divweo: 0x0000000200000000 / 0x00000000 = 0x00000000; CR=0; XER=c0000000
+#2: divweo: 0x7abc123400000000 / 0xf0000000 = 0x00000000; CR=0; XER=c0000000
+#3: divweo: 0xfabc123400000000 / 0x00000005 = 0x00000000; CR=0; XER=c0000000
+#4: divweo: 0x0000004d00000000 / 0x00000042 = 0x00000000; CR=0; XER=c0000000
+#5: divweo: 0x0000000500000000 / 0xfabc1234 = 0xffffff0d; CR=0; XER=0
+
+#0: divweo.: 0x0000000000000000 / 0x00000002 = 0x00000000; CR=2; XER=0
+#1: divweo.: 0x0000000200000000 / 0x00000000 = 0x00000000; CR=3; XER=c0000000
+#2: divweo.: 0x7abc123400000000 / 0xf0000000 = 0x00000000; CR=3; XER=c0000000
+#3: divweo.: 0xfabc123400000000 / 0x00000005 = 0x00000000; CR=3; XER=c0000000
+#4: divweo.: 0x0000004d00000000 / 0x00000042 = 0x00000000; CR=3; XER=c0000000
+#5: divweo.: 0x0000000500000000 / 0xfabc1234 = 0xffffff0d; CR=4; XER=0
+
+
+Test ftsqrt instruction
+ftsqrt: 3fd8000000000000 ? 8 (CRx)
+ftsqrt: 404f000000000000 ? 8 (CRx)
+ftsqrt: 0018000000b77501 ? a (CRx)
+ftsqrt: 7fe800000000051b ? 8 (CRx)
+ftsqrt: 0123214569900000 ? a (CRx)
+ftsqrt: 0000000000000000 ? e (CRx)
+ftsqrt: 8000000000000000 ? e (CRx)
+ftsqrt: 7ff0000000000000 ? e (CRx)
+ftsqrt: fff0000000000000 ? e (CRx)
+ftsqrt: 7ff7ffffffffffff ? a (CRx)
+ftsqrt: fff7ffffffffffff ? a (CRx)
+ftsqrt: 7ff8000000000000 ? a (CRx)
+ftsqrt: fff8000000000000 ? a (CRx)
+ftsqrt: 8008340000078000 ? e (CRx)
+ftsqrt: c0d0650f5a07b353 ? a (CRx)
+ftsqrt: 41232585a9900000 ? 8 (CRx)
+ftsqrt: 41382511a2000000 ? 8 (CRx)
+ftsqrt: 40312ef5a9300000 ? 8 (CRx)
+ftsqrt: 40514bf5d2300000 ? 8 (CRx)
+ftsqrt: 40976bf982440000 ? 8 (CRx)
+
+Test vector and scalar tdiv and tsqrt instructions
+#0: xstsqrtdp test-sqrt(3fd8000000000000) ? 8 (CRx)
+#1: xstsqrtdp test-sqrt(404f000000000000) ? 8 (CRx)
+#2: xstsqrtdp test-sqrt(0018000000b77501) ? a (CRx)
+#3: xstsqrtdp test-sqrt(7fe800000000051b) ? 8 (CRx)
+#4: xstsqrtdp test-sqrt(0123214569900000) ? a (CRx)
+#5: xstsqrtdp test-sqrt(0000000000000000) ? e (CRx)
+#6: xstsqrtdp test-sqrt(8000000000000000) ? e (CRx)
+#7: xstsqrtdp test-sqrt(7ff0000000000000) ? e (CRx)
+#8: xstsqrtdp test-sqrt(fff0000000000000) ? e (CRx)
+#9: xstsqrtdp test-sqrt(7ff7ffffffffffff) ? a (CRx)
+#10: xstsqrtdp test-sqrt(fff7ffffffffffff) ? a (CRx)
+#11: xstsqrtdp test-sqrt(7ff8000000000000) ? a (CRx)
+#12: xstsqrtdp test-sqrt(fff8000000000000) ? a (CRx)
+#13: xstsqrtdp test-sqrt(8008340000078000) ? e (CRx)
+#14: xstsqrtdp test-sqrt(c0d0650f5a07b353) ? a (CRx)
+#15: xstsqrtdp test-sqrt(41232585a9900000) ? 8 (CRx)
+#16: xstsqrtdp test-sqrt(41382511a2000000) ? 8 (CRx)
+#17: xstsqrtdp test-sqrt(40312ef5a9300000) ? 8 (CRx)
+#18: xstsqrtdp test-sqrt(40514bf5d2300000) ? 8 (CRx)
+#19: xstsqrtdp test-sqrt(40976bf982440000) ? 8 (CRx)
+
+#0: xvtsqrtdp test-sqrt(3fd8000000000000); test-sqrt(404f000000000000) ? 8 (CRx)
+#1: xvtsqrtdp test-sqrt(0018000000b77501); test-sqrt(7fe800000000051b) ? a (CRx)
+#2: xvtsqrtdp test-sqrt(0123214569900000); test-sqrt(0000000000000000) ? e (CRx)
+#3: xvtsqrtdp test-sqrt(8000000000000000); test-sqrt(7ff0000000000000) ? e (CRx)
+#4: xvtsqrtdp test-sqrt(fff0000000000000); test-sqrt(7ff7ffffffffffff) ? e (CRx)
+#5: xvtsqrtdp test-sqrt(fff7ffffffffffff); test-sqrt(7ff8000000000000) ? a (CRx)
+#6: xvtsqrtdp test-sqrt(fff8000000000000); test-sqrt(8008340000078000) ? e (CRx)
+#7: xvtsqrtdp test-sqrt(c0d0650f5a07b353); test-sqrt(41232585a9900000) ? a (CRx)
+#8: xvtsqrtdp test-sqrt(41382511a2000000); test-sqrt(40312ef5a9300000) ? 8 (CRx)
+#9: xvtsqrtdp test-sqrt(40514bf5d2300000); test-sqrt(40976bf982440000) ? 8 (CRx)
+
+#0: xvtsqrtsp test-sqrt(3ec00000); test-sqrt(42780000); test-sqrt(00000000); test-sqrt(7f800000) ? e (CRx)
+#1: xvtsqrtsp test-sqrt(00000000); test-sqrt(00000000); test-sqrt(80000000); test-sqrt(7f800000) ? e (CRx)
+#2: xvtsqrtsp test-sqrt(ff800000); test-sqrt(7fffffff); test-sqrt(ffffffff); test-sqrt(7fc00000) ? e (CRx)
+#3: xvtsqrtsp test-sqrt(ffc00000); test-sqrt(80000000); test-sqrt(c683287b); test-sqrt(49192c2d) ? e (CRx)
+#4: xvtsqrtsp test-sqrt(49c1288d); test-sqrt(418977ad); test-sqrt(428a5faf); test-sqrt(44bb5fcc) ? 8 (CRx)
+
+#0: xvtdivdp fff0000000000000 test-div fff0000000000000 AND fff0000000000000 test-div c0d0650f5a07b353 ? cc=e
+#1: xvtdivdp 41232585a9900000 test-div 41382511a2000000 AND fff0000000000000 test-div 0000000000000000 ? cc=e
+#2: xvtdivdp fff0000000000000 test-div 0123214569900000 AND fff0000000000000 test-div 7ff0000000000000 ? cc=e
+#3: xvtdivdp fff0000000000000 test-div 7ff7ffffffffffff AND fff0000000000000 test-div 7ff8000000000000 ? cc=e
+#4: xvtdivdp c0d0650f5a07b353 test-div fff0000000000000 AND c0d0650f5a07b353 test-div c0d0650f5a07b353 ? cc=e
+#5: xvtdivdp c0d0650f5a07b353 test-div 8000000000000000 AND c0d0650f5a07b353 test-div 0000000000000000 ? cc=e
+#6: xvtdivdp c0d0650f5a07b353 test-div 0123214569900000 AND c0d0650f5a07b353 test-div 7ff0000000000000 ? cc=e
+#7: xvtdivdp c0d0650f5a07b353 test-div 7ff7ffffffffffff AND c0d0650f5a07b353 test-div 7ff8000000000000 ? cc=a
+#8: xvtdivdp 8000000000000000 test-div fff0000000000000 AND 8000000000000000 test-div c0d0650f5a07b353 ? cc=e
+#9: xvtdivdp 8000000000000000 test-div 8000000000000000 AND 8000000000000000 test-div 0000000000000000 ? cc=e
+#10: xvtdivdp 8000000000000000 test-div 0123214569900000 AND 8000000000000000 test-div 7ff0000000000000 ? cc=e
+#11: xvtdivdp 8000000000000000 test-div 7ff7ffffffffffff AND 8000000000000000 test-div 7ff8000000000000 ? cc=a
+#12: xvtdivdp 0000000000000000 test-div fff0000000000000 AND 0000000000000000 test-div c0d0650f5a07b353 ? cc=e
+#13: xvtdivdp 0000000000000000 test-div 8000000000000000 AND 0000000000000000 test-div 0000000000000000 ? cc=e
+#14: xvtdivdp 0000000000000000 test-div 0123214569900000 AND 0000000000000000 test-div 7ff0000000000000 ? cc=e
+#15: xvtdivdp 0000000000000000 test-div 7ff7ffffffffffff AND 0000000000000000 test-div 7ff8000000000000 ? cc=a
+#16: xvtdivdp 0123214569900000 test-div fff0000000000000 AND 0123214569900000 test-div c0d0650f5a07b353 ? cc=e
+#17: xvtdivdp 0123214569900000 test-div 8000000000000000 AND 0123214569900000 test-div 0000000000000000 ? cc=e
+#18: xvtdivdp 0123214569900000 test-div 404f000000000000 AND 0123214569900000 test-div 7ff0000000000000 ? cc=e
+#19: xvtdivdp 0123214569900000 test-div 7ff7ffffffffffff AND 0123214569900000 test-div 7ff8000000000000 ? cc=a
+#20: xvtdivdp 7ff0000000000000 test-div fff0000000000000 AND 7ff0000000000000 test-div c0d0650f5a07b353 ? cc=e
+#21: xvtdivdp 7ff0000000000000 test-div 8000000000000000 AND 7ff0000000000000 test-div 0000000000000000 ? cc=e
+#22: xvtdivdp 7ff0000000000000 test-div 0123214569900000 AND 7ff0000000000000 test-div 7ff0000000000000 ? cc=e
+#23: xvtdivdp 7ff0000000000000 test-div 7ff7ffffffffffff AND 7ff0000000000000 test-div 7ff8000000000000 ? cc=e
+#24: xvtdivdp fff7ffffffffffff test-div fff0000000000000 AND fff7ffffffffffff test-div c0d0650f5a07b353 ? cc=e
+#25: xvtdivdp fff8000000000000 test-div 8000000000000000 AND fff8000000000000 test-div 0000000000000000 ? cc=e
+#26: xvtdivdp fff7ffffffffffff test-div 0123214569900000 AND fff7ffffffffffff test-div 7ff0000000000000 ? cc=e
+#27: xvtdivdp fff7ffffffffffff test-div 7ff7ffffffffffff AND fff7ffffffffffff test-div 7ff8000000000000 ? cc=a
+#28: xvtdivdp fff8000000000000 test-div fff0000000000000 AND fff8000000000000 test-div c0d0650f5a07b353 ? cc=e
+#29: xvtdivdp fff8000000000000 test-div 8000000000000000 AND 41232585a9900000 test-div 41382511a2000000 ? cc=e
+#30: xvtdivdp 41232585a9900000 test-div 41382511a2000000 AND 7ff7ffffffffffff test-div 7ff8000000000000 ? cc=a
+#31: xvtdivdp 7ff8000000000000 test-div 7ff8000000000000 AND 7ff8000000000000 test-div fff8000000000000 ? cc=a
+#32: xvtdivdp 41382511a2000000 test-div 40514bf5d2300000 AND 40312ef5a9300000 test-div 41382511a2000000 ? cc=8
+#33: xvtdivdp 40976bf982440000 test-div 40976bf982440000 AND 40976bf982440000 test-div 40514bf5d2300000 ? cc=8
+
+#0: xvtdivsp ff800000 test-div ff800000 AND ff800000 test-div c683287b AND 49192c2d test-div 49c1288d AND ff800000 test-div 00000000 ? cc=e
+#1: xvtdivsp ff800000 test-div 00000000 AND ff800000 test-div 7f800000 AND ff800000 test-div 7fffffff AND ff800000 test-div 7fc00000 ? cc=e
+#2: xvtdivsp c683287b test-div ff800000 AND c683287b test-div c683287b AND c683287b test-div 80000000 AND c683287b test-div 00000000 ? cc=e
+#3: xvtdivsp c683287b test-div 00000000 AND c683287b test-div 7f800000 AND c683287b test-div 7fffffff AND c683287b test-div 7fc00000 ? cc=e
+#4: xvtdivsp 80000000 test-div ff800000 AND 80000000 test-div c683287b AND 80000000 test-div 80000000 AND 80000000 test-div 00000000 ? cc=e
+#5: xvtdivsp 80000000 test-div 00000000 AND 80000000 test-div 7f800000 AND 80000000 test-div 7fffffff AND 80000000 test-div 7fc00000 ? cc=e
+#6: xvtdivsp 00000000 test-div ff800000 AND 00000000 test-div c683287b AND 00000000 test-div 80000000 AND 00000000 test-div 00000000 ? cc=e
+#7: xvtdivsp 00000000 test-div 00000000 AND 00000000 test-div 7f800000 AND 00000000 test-div 7fffffff AND 00000000 test-div 7fc00000 ? cc=e
+#8: xvtdivsp 00000000 test-div ff800000 AND 00000000 test-div c683287b AND 00000000 test-div 80000000 AND 00000000 test-div 00000000 ? cc=e
+#9: xvtdivsp 00000000 test-div 42780000 AND 00000000 test-div 7f800000 AND 00000000 test-div 7fffffff AND 00000000 test-div 7fc00000 ? cc=e
+#10: xvtdivsp 7f800000 test-div ff800000 AND 7f800000 test-div c683287b AND 7f800000 test-div 80000000 AND 7f800000 test-div 00000000 ? cc=e
+#11: xvtdivsp 7f800000 test-div 00000000 AND 7f800000 test-div 7f800000 AND 7f800000 test-div 7fffffff AND 7f800000 test-div 7fc00000 ? cc=e
+#12: xvtdivsp ffffffff test-div ff800000 AND ffffffff test-div c683287b AND ffc00000 test-div 80000000 AND ffc00000 test-div 00000000 ? cc=e
+#13: xvtdivsp ffffffff test-div 00000000 AND ffffffff test-div 7f800000 AND ffffffff test-div 7fffffff AND ffffffff test-div 7fc00000 ? cc=e
+#14: xvtdivsp ffc00000 test-div ff800000 AND ffc00000 test-div c683287b AND ffc00000 test-div 80000000 AND 49192c2d test-div 49c1288d ? cc=e
+#15: xvtdivsp 49192c2d test-div 49c1288d AND 7fffffff test-div 7fc00000 AND 7fc00000 test-div 7fc00000 AND 7fc00000 test-div ffc00000 ? cc=a
+#16: xvtdivsp 49c1288d test-div 428a5faf AND 418977ad test-div 49c1288d AND 44bb5fcc test-div 44bb5fcc AND 44bb5fcc test-div 428a5faf ? cc=8
+
+Test popcntw instruction
+popcntw: 0x9182736405504536 => 0x0000000d0000000b
+
--- valgrind/none/tests/ppc64/test_isa_2_06_part3.stderr.exp	(revision 0)
+++ valgrind/none/tests/ppc64/test_isa_2_06_part3.stderr.exp	(revision 12007)
@@ -0,0 +1,2 @@
+
+
--- valgrind/none/tests/ppc64/test_isa_2_06_part3.vgtest	(revision 0)
+++ valgrind/none/tests/ppc64/test_isa_2_06_part3.vgtest	(revision 12007)
@@ -0,0 +1,2 @@
+prereq: ../../../tests/check_isa-2_06_cap
+prog: test_isa_2_06_part3
--- valgrind/none/tests/ppc64/test_isa_2_06_part3.c	(revision 0)
+++ valgrind/none/tests/ppc64/test_isa_2_06_part3.c	(revision 12007)
@@ -0,0 +1 @@
+#include "../ppc32/test_isa_2_06_part3.c"
--- valgrind/none/tests/ppc64/Makefile.am	(revision 12005)
+++ valgrind/none/tests/ppc64/Makefile.am	(revision 12007)
@@ -16,11 +16,12 @@ EXTRA_DIST = \
 	power6_bcmp.stderr.exp power6_bcmp.stdout.exp power6_bcmp.vgtest \
 	power6_mf_gpr.stderr.exp power6_mf_gpr.stdout.exp power6_mf_gpr.vgtest \
 	test_isa_2_06_part1.stderr.exp  test_isa_2_06_part1.stdout.exp  test_isa_2_06_part1.vgtest \
-	test_isa_2_06_part2.stderr.exp  test_isa_2_06_part2.stdout.exp  test_isa_2_06_part2.vgtest
+	test_isa_2_06_part2.stderr.exp  test_isa_2_06_part2.stdout.exp  test_isa_2_06_part2.vgtest \
+	test_isa_2_06_part3.stderr.exp  test_isa_2_06_part3.stdout.exp  test_isa_2_06_part3.vgtest
 
 check_PROGRAMS = \
 	jm-insns lsw round std_reg_imm twi_tdi tw_td power6_bcmp power6_mf_gpr test_isa_2_06_part1 \
-	test_isa_2_06_part2
+	test_isa_2_06_part2 test_isa_2_06_part3
 
 AM_CFLAGS    += @FLAG_M64@
 AM_CXXFLAGS  += @FLAG_M64@
@@ -46,6 +47,9 @@ test_isa_2_06_part1_CFLAGS = $(AM_CFLAGS
 test_isa_2_06_part2_CFLAGS = $(AM_CFLAGS) -Winline -Wall -O -g -mregnames $(VSX_FLAG) \
 			@FLAG_M64@ $(ALTIVEC_FLAG) $(BUILD_FLAG_VSX)
 
+test_isa_2_06_part3_CFLAGS = $(AM_CFLAGS) -Winline -Wall -O -lm -g -mregnames $(VSX_FLAG) \
+			@FLAG_M64@ $(ALTIVEC_FLAG) $(BUILD_FLAG_VSX)
+
 jm_insns_CFLAGS = $(AM_CFLAGS) -Winline -Wall -O -g -mregnames -maltivec \
 			@FLAG_M64@ $(ALTIVEC_FLAG)
 
--- valgrind/none/tests/ppc32/Makefile.in	2012-03-05 09:54:26.000000000 +0100
+++ valgrind/none/tests/ppc32/Makefile.in	2012-03-05 09:57:32.154960798 +0100
@@ -52,7 +52,8 @@ check_PROGRAMS = bug129390-ppc32$(EXEEXT
 	test_fx$(EXEEXT) test_gx$(EXEEXT) testVMX$(EXEEXT) \
 	twi$(EXEEXT) tw$(EXEEXT) xlc_dbl_u32$(EXEEXT) \
 	power5+_round$(EXEEXT) power6_bcmp$(EXEEXT) \
-	test_isa_2_06_part1$(EXEEXT) test_isa_2_06_part2$(EXEEXT)
+	test_isa_2_06_part1$(EXEEXT) test_isa_2_06_part2$(EXEEXT) \
+	test_isa_2_06_part3$(EXEEXT)
 subdir = none/tests/ppc32
 ACLOCAL_M4 = $(top_srcdir)/aclocal.m4
 am__aclocal_m4_deps = $(top_srcdir)/configure.in
@@ -117,6 +118,12 @@ test_isa_2_06_part2_OBJECTS =  \
 test_isa_2_06_part2_LDADD = $(LDADD)
 test_isa_2_06_part2_LINK = $(CCLD) $(test_isa_2_06_part2_CFLAGS) \
 	$(CFLAGS) $(AM_LDFLAGS) $(LDFLAGS) -o $@
+test_isa_2_06_part3_SOURCES = test_isa_2_06_part3.c
+test_isa_2_06_part3_OBJECTS =  \
+	test_isa_2_06_part3-test_isa_2_06_part3.$(OBJEXT)
+test_isa_2_06_part3_LDADD = $(LDADD)
+test_isa_2_06_part3_LINK = $(CCLD) $(test_isa_2_06_part3_CFLAGS) \
+	$(CFLAGS) $(AM_LDFLAGS) $(LDFLAGS) -o $@
 tw_SOURCES = tw.c
 tw_OBJECTS = tw.$(OBJEXT)
 tw_LDADD = $(LDADD)
@@ -138,12 +145,13 @@ LINK = $(CCLD) $(AM_CFLAGS) $(CFLAGS) $(
 SOURCES = bug129390-ppc32.c bug139050-ppc32.c jm-insns.c ldstrev.c \
 	lsw.c mcrfs.c mftocrf.c power5+_round.c power6_bcmp.c round.c \
 	testVMX.c test_fx.c test_gx.c test_isa_2_06_part1.c \
-	test_isa_2_06_part2.c tw.c twi.c xlc_dbl_u32.c
+	test_isa_2_06_part2.c test_isa_2_06_part3.c tw.c twi.c \
+	xlc_dbl_u32.c
 DIST_SOURCES = bug129390-ppc32.c bug139050-ppc32.c jm-insns.c \
 	ldstrev.c lsw.c mcrfs.c mftocrf.c power5+_round.c \
 	power6_bcmp.c round.c testVMX.c test_fx.c test_gx.c \
-	test_isa_2_06_part1.c test_isa_2_06_part2.c tw.c twi.c \
-	xlc_dbl_u32.c
+	test_isa_2_06_part1.c test_isa_2_06_part2.c \
+	test_isa_2_06_part3.c tw.c twi.c xlc_dbl_u32.c
 ETAGS = etags
 CTAGS = ctags
 DISTFILES = $(DIST_COMMON) $(DIST_SOURCES) $(TEXINFOS) $(EXTRA_DIST)
@@ -454,7 +462,8 @@ EXTRA_DIST = \
 	power5+_round.stderr.exp power5+_round.stdout.exp power5+_round.vgtest \
 	power6_bcmp.stderr.exp power6_bcmp.stdout.exp power6_bcmp.vgtest \
 	test_isa_2_06_part1.stderr.exp  test_isa_2_06_part1.stdout.exp  test_isa_2_06_part1.vgtest \
-	test_isa_2_06_part2.stderr.exp  test_isa_2_06_part2.stdout.exp  test_isa_2_06_part2.vgtest
+	test_isa_2_06_part2.stderr.exp  test_isa_2_06_part2.stdout.exp  test_isa_2_06_part2.vgtest \
+	test_isa_2_06_part3.stderr.exp  test_isa_2_06_part3.stdout.exp  test_isa_2_06_part3.vgtest
 
 @HAS_ALTIVEC_FALSE@ALTIVEC_FLAG = 
 @HAS_ALTIVEC_TRUE@ALTIVEC_FLAG = -DHAS_ALTIVEC
@@ -474,6 +483,9 @@ test_isa_2_06_part1_CFLAGS = $(AM_CFLAGS
 test_isa_2_06_part2_CFLAGS = $(AM_CFLAGS) -Winline -Wall -O -g -mregnames $(VSX_FLAG) \
 			@FLAG_M32@ $(ALTIVEC_FLAG) $(BUILD_FLAG_VSX)
 
+test_isa_2_06_part3_CFLAGS = $(AM_CFLAGS) -Winline -Wall -O -lm -g -mregnames $(VSX_FLAG) \
+			@FLAG_M32@ $(ALTIVEC_FLAG) $(BUILD_FLAG_VSX)
+
 all: all-am
 
 .SUFFIXES:
@@ -556,6 +568,9 @@ test_isa_2_06_part1$(EXEEXT): $(test_isa
 test_isa_2_06_part2$(EXEEXT): $(test_isa_2_06_part2_OBJECTS) $(test_isa_2_06_part2_DEPENDENCIES) 
 	@rm -f test_isa_2_06_part2$(EXEEXT)
 	$(test_isa_2_06_part2_LINK) $(test_isa_2_06_part2_OBJECTS) $(test_isa_2_06_part2_LDADD) $(LIBS)
+test_isa_2_06_part3$(EXEEXT): $(test_isa_2_06_part3_OBJECTS) $(test_isa_2_06_part3_DEPENDENCIES) 
+	@rm -f test_isa_2_06_part3$(EXEEXT)
+	$(test_isa_2_06_part3_LINK) $(test_isa_2_06_part3_OBJECTS) $(test_isa_2_06_part3_LDADD) $(LIBS)
 tw$(EXEEXT): $(tw_OBJECTS) $(tw_DEPENDENCIES) 
 	@rm -f tw$(EXEEXT)
 	$(LINK) $(tw_OBJECTS) $(tw_LDADD) $(LIBS)
@@ -587,6 +602,7 @@ distclean-compile:
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/test_gx.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/test_isa_2_06_part1-test_isa_2_06_part1.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/test_isa_2_06_part2-test_isa_2_06_part2.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/test_isa_2_06_part3-test_isa_2_06_part3.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/tw.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/twi.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/xlc_dbl_u32.Po@am__quote@
@@ -661,6 +677,20 @@ test_isa_2_06_part2-test_isa_2_06_part2.
 @AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
 @am__fastdepCC_FALSE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(test_isa_2_06_part2_CFLAGS) $(CFLAGS) -c -o test_isa_2_06_part2-test_isa_2_06_part2.obj `if test -f 'test_isa_2_06_part2.c'; then $(CYGPATH_W) 'test_isa_2_06_part2.c'; else $(CYGPATH_W) '$(srcdir)/test_isa_2_06_part2.c'; fi`
 
+test_isa_2_06_part3-test_isa_2_06_part3.o: test_isa_2_06_part3.c
+@am__fastdepCC_TRUE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(test_isa_2_06_part3_CFLAGS) $(CFLAGS) -MT test_isa_2_06_part3-test_isa_2_06_part3.o -MD -MP -MF $(DEPDIR)/test_isa_2_06_part3-test_isa_2_06_part3.Tpo -c -o test_isa_2_06_part3-test_isa_2_06_part3.o `test -f 'test_isa_2_06_part3.c' || echo '$(srcdir)/'`test_isa_2_06_part3.c
+@am__fastdepCC_TRUE@	$(am__mv) $(DEPDIR)/test_isa_2_06_part3-test_isa_2_06_part3.Tpo $(DEPDIR)/test_isa_2_06_part3-test_isa_2_06_part3.Po
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='test_isa_2_06_part3.c' object='test_isa_2_06_part3-test_isa_2_06_part3.o' libtool=no @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@am__fastdepCC_FALSE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(test_isa_2_06_part3_CFLAGS) $(CFLAGS) -c -o test_isa_2_06_part3-test_isa_2_06_part3.o `test -f 'test_isa_2_06_part3.c' || echo '$(srcdir)/'`test_isa_2_06_part3.c
+
+test_isa_2_06_part3-test_isa_2_06_part3.obj: test_isa_2_06_part3.c
+@am__fastdepCC_TRUE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(test_isa_2_06_part3_CFLAGS) $(CFLAGS) -MT test_isa_2_06_part3-test_isa_2_06_part3.obj -MD -MP -MF $(DEPDIR)/test_isa_2_06_part3-test_isa_2_06_part3.Tpo -c -o test_isa_2_06_part3-test_isa_2_06_part3.obj `if test -f 'test_isa_2_06_part3.c'; then $(CYGPATH_W) 'test_isa_2_06_part3.c'; else $(CYGPATH_W) '$(srcdir)/test_isa_2_06_part3.c'; fi`
+@am__fastdepCC_TRUE@	$(am__mv) $(DEPDIR)/test_isa_2_06_part3-test_isa_2_06_part3.Tpo $(DEPDIR)/test_isa_2_06_part3-test_isa_2_06_part3.Po
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='test_isa_2_06_part3.c' object='test_isa_2_06_part3-test_isa_2_06_part3.obj' libtool=no @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@am__fastdepCC_FALSE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(test_isa_2_06_part3_CFLAGS) $(CFLAGS) -c -o test_isa_2_06_part3-test_isa_2_06_part3.obj `if test -f 'test_isa_2_06_part3.c'; then $(CYGPATH_W) 'test_isa_2_06_part3.c'; else $(CYGPATH_W) '$(srcdir)/test_isa_2_06_part3.c'; fi`
+
 ID: $(HEADERS) $(SOURCES) $(LISP) $(TAGS_FILES)
 	list='$(SOURCES) $(HEADERS) $(LISP) $(TAGS_FILES)'; \
 	unique=`for i in $$list; do \
--- valgrind/none/tests/ppc64/Makefile.in	2012-03-05 09:54:26.000000000 +0100
+++ valgrind/none/tests/ppc64/Makefile.in	2012-03-05 09:57:32.274960712 +0100
@@ -49,7 +49,8 @@ DIST_COMMON = $(dist_noinst_SCRIPTS) $(s
 check_PROGRAMS = jm-insns$(EXEEXT) lsw$(EXEEXT) round$(EXEEXT) \
 	std_reg_imm$(EXEEXT) twi_tdi$(EXEEXT) tw_td$(EXEEXT) \
 	power6_bcmp$(EXEEXT) power6_mf_gpr$(EXEEXT) \
-	test_isa_2_06_part1$(EXEEXT) test_isa_2_06_part2$(EXEEXT)
+	test_isa_2_06_part1$(EXEEXT) test_isa_2_06_part2$(EXEEXT) \
+	test_isa_2_06_part3$(EXEEXT)
 subdir = none/tests/ppc64
 ACLOCAL_M4 = $(top_srcdir)/aclocal.m4
 am__aclocal_m4_deps = $(top_srcdir)/configure.in
@@ -91,6 +92,12 @@ test_isa_2_06_part2_OBJECTS =  \
 test_isa_2_06_part2_LDADD = $(LDADD)
 test_isa_2_06_part2_LINK = $(CCLD) $(test_isa_2_06_part2_CFLAGS) \
 	$(CFLAGS) $(AM_LDFLAGS) $(LDFLAGS) -o $@
+test_isa_2_06_part3_SOURCES = test_isa_2_06_part3.c
+test_isa_2_06_part3_OBJECTS =  \
+	test_isa_2_06_part3-test_isa_2_06_part3.$(OBJEXT)
+test_isa_2_06_part3_LDADD = $(LDADD)
+test_isa_2_06_part3_LINK = $(CCLD) $(test_isa_2_06_part3_CFLAGS) \
+	$(CFLAGS) $(AM_LDFLAGS) $(LDFLAGS) -o $@
 tw_td_SOURCES = tw_td.c
 tw_td_OBJECTS = tw_td.$(OBJEXT)
 tw_td_LDADD = $(LDADD)
@@ -108,10 +115,10 @@ CCLD = $(CC)
 LINK = $(CCLD) $(AM_CFLAGS) $(CFLAGS) $(AM_LDFLAGS) $(LDFLAGS) -o $@
 SOURCES = jm-insns.c lsw.c power6_bcmp.c power6_mf_gpr.c round.c \
 	std_reg_imm.c test_isa_2_06_part1.c test_isa_2_06_part2.c \
-	tw_td.c twi_tdi.c
+	test_isa_2_06_part3.c tw_td.c twi_tdi.c
 DIST_SOURCES = jm-insns.c lsw.c power6_bcmp.c power6_mf_gpr.c round.c \
 	std_reg_imm.c test_isa_2_06_part1.c test_isa_2_06_part2.c \
-	tw_td.c twi_tdi.c
+	test_isa_2_06_part3.c tw_td.c twi_tdi.c
 ETAGS = etags
 CTAGS = ctags
 DISTFILES = $(DIST_COMMON) $(DIST_SOURCES) $(TEXINFOS) $(EXTRA_DIST)
@@ -412,7 +419,8 @@ EXTRA_DIST = \
 	power6_bcmp.stderr.exp power6_bcmp.stdout.exp power6_bcmp.vgtest \
 	power6_mf_gpr.stderr.exp power6_mf_gpr.stdout.exp power6_mf_gpr.vgtest \
 	test_isa_2_06_part1.stderr.exp  test_isa_2_06_part1.stdout.exp  test_isa_2_06_part1.vgtest \
-	test_isa_2_06_part2.stderr.exp  test_isa_2_06_part2.stdout.exp  test_isa_2_06_part2.vgtest
+	test_isa_2_06_part2.stderr.exp  test_isa_2_06_part2.stdout.exp  test_isa_2_06_part2.vgtest \
+	test_isa_2_06_part3.stderr.exp  test_isa_2_06_part3.stdout.exp  test_isa_2_06_part3.vgtest
 
 @HAS_ALTIVEC_FALSE@ALTIVEC_FLAG = 
 @HAS_ALTIVEC_TRUE@ALTIVEC_FLAG = -DHAS_ALTIVEC
@@ -426,6 +434,9 @@ test_isa_2_06_part1_CFLAGS = $(AM_CFLAGS
 test_isa_2_06_part2_CFLAGS = $(AM_CFLAGS) -Winline -Wall -O -g -mregnames $(VSX_FLAG) \
 			@FLAG_M64@ $(ALTIVEC_FLAG) $(BUILD_FLAG_VSX)
 
+test_isa_2_06_part3_CFLAGS = $(AM_CFLAGS) -Winline -Wall -O -lm -g -mregnames $(VSX_FLAG) \
+			@FLAG_M64@ $(ALTIVEC_FLAG) $(BUILD_FLAG_VSX)
+
 jm_insns_CFLAGS = $(AM_CFLAGS) -Winline -Wall -O -g -mregnames -maltivec \
 			@FLAG_M64@ $(ALTIVEC_FLAG)
 
@@ -490,6 +501,9 @@ test_isa_2_06_part1$(EXEEXT): $(test_isa
 test_isa_2_06_part2$(EXEEXT): $(test_isa_2_06_part2_OBJECTS) $(test_isa_2_06_part2_DEPENDENCIES) 
 	@rm -f test_isa_2_06_part2$(EXEEXT)
 	$(test_isa_2_06_part2_LINK) $(test_isa_2_06_part2_OBJECTS) $(test_isa_2_06_part2_LDADD) $(LIBS)
+test_isa_2_06_part3$(EXEEXT): $(test_isa_2_06_part3_OBJECTS) $(test_isa_2_06_part3_DEPENDENCIES) 
+	@rm -f test_isa_2_06_part3$(EXEEXT)
+	$(test_isa_2_06_part3_LINK) $(test_isa_2_06_part3_OBJECTS) $(test_isa_2_06_part3_LDADD) $(LIBS)
 tw_td$(EXEEXT): $(tw_td_OBJECTS) $(tw_td_DEPENDENCIES) 
 	@rm -f tw_td$(EXEEXT)
 	$(LINK) $(tw_td_OBJECTS) $(tw_td_LDADD) $(LIBS)
@@ -511,6 +525,7 @@ distclean-compile:
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/std_reg_imm.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/test_isa_2_06_part1-test_isa_2_06_part1.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/test_isa_2_06_part2-test_isa_2_06_part2.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/test_isa_2_06_part3-test_isa_2_06_part3.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/tw_td.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/twi_tdi.Po@am__quote@
 
@@ -570,6 +585,20 @@ test_isa_2_06_part2-test_isa_2_06_part2.
 @AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
 @am__fastdepCC_FALSE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(test_isa_2_06_part2_CFLAGS) $(CFLAGS) -c -o test_isa_2_06_part2-test_isa_2_06_part2.obj `if test -f 'test_isa_2_06_part2.c'; then $(CYGPATH_W) 'test_isa_2_06_part2.c'; else $(CYGPATH_W) '$(srcdir)/test_isa_2_06_part2.c'; fi`
 
+test_isa_2_06_part3-test_isa_2_06_part3.o: test_isa_2_06_part3.c
+@am__fastdepCC_TRUE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(test_isa_2_06_part3_CFLAGS) $(CFLAGS) -MT test_isa_2_06_part3-test_isa_2_06_part3.o -MD -MP -MF $(DEPDIR)/test_isa_2_06_part3-test_isa_2_06_part3.Tpo -c -o test_isa_2_06_part3-test_isa_2_06_part3.o `test -f 'test_isa_2_06_part3.c' || echo '$(srcdir)/'`test_isa_2_06_part3.c
+@am__fastdepCC_TRUE@	$(am__mv) $(DEPDIR)/test_isa_2_06_part3-test_isa_2_06_part3.Tpo $(DEPDIR)/test_isa_2_06_part3-test_isa_2_06_part3.Po
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='test_isa_2_06_part3.c' object='test_isa_2_06_part3-test_isa_2_06_part3.o' libtool=no @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@am__fastdepCC_FALSE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(test_isa_2_06_part3_CFLAGS) $(CFLAGS) -c -o test_isa_2_06_part3-test_isa_2_06_part3.o `test -f 'test_isa_2_06_part3.c' || echo '$(srcdir)/'`test_isa_2_06_part3.c
+
+test_isa_2_06_part3-test_isa_2_06_part3.obj: test_isa_2_06_part3.c
+@am__fastdepCC_TRUE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(test_isa_2_06_part3_CFLAGS) $(CFLAGS) -MT test_isa_2_06_part3-test_isa_2_06_part3.obj -MD -MP -MF $(DEPDIR)/test_isa_2_06_part3-test_isa_2_06_part3.Tpo -c -o test_isa_2_06_part3-test_isa_2_06_part3.obj `if test -f 'test_isa_2_06_part3.c'; then $(CYGPATH_W) 'test_isa_2_06_part3.c'; else $(CYGPATH_W) '$(srcdir)/test_isa_2_06_part3.c'; fi`
+@am__fastdepCC_TRUE@	$(am__mv) $(DEPDIR)/test_isa_2_06_part3-test_isa_2_06_part3.Tpo $(DEPDIR)/test_isa_2_06_part3-test_isa_2_06_part3.Po
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='test_isa_2_06_part3.c' object='test_isa_2_06_part3-test_isa_2_06_part3.obj' libtool=no @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@am__fastdepCC_FALSE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(test_isa_2_06_part3_CFLAGS) $(CFLAGS) -c -o test_isa_2_06_part3-test_isa_2_06_part3.obj `if test -f 'test_isa_2_06_part3.c'; then $(CYGPATH_W) 'test_isa_2_06_part3.c'; else $(CYGPATH_W) '$(srcdir)/test_isa_2_06_part3.c'; fi`
+
 ID: $(HEADERS) $(SOURCES) $(LISP) $(TAGS_FILES)
 	list='$(SOURCES) $(HEADERS) $(LISP) $(TAGS_FILES)'; \
 	unique=`for i in $$list; do \
